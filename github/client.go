// Package github provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package github

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Metaroot request
	Metaroot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetAuthenticated request
	AppsgetAuthenticated(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppscreateFromManifest request
	AppscreateFromManifest(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetWebhookConfigForApp request
	AppsgetWebhookConfigForApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsupdateWebhookConfigForApp request with any body
	AppsupdateWebhookConfigForAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsupdateWebhookConfigForApp(ctx context.Context, body AppsupdateWebhookConfigForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistWebhookDeliveries request
	AppslistWebhookDeliveries(ctx context.Context, params *AppslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetWebhookDelivery request
	AppsgetWebhookDelivery(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsredeliverWebhookDelivery request
	AppsredeliverWebhookDelivery(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistInstallations request
	AppslistInstallations(ctx context.Context, params *AppslistInstallationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsdeleteInstallation request
	AppsdeleteInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetInstallation request
	AppsgetInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppscreateInstallationAccessToken request with any body
	AppscreateInstallationAccessTokenWithBody(ctx context.Context, installationId InstallationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppscreateInstallationAccessToken(ctx context.Context, installationId InstallationId, body AppscreateInstallationAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsunsuspendInstallation request
	AppsunsuspendInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppssuspendInstallation request
	AppssuspendInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationslistGrants request
	OauthAuthorizationslistGrants(ctx context.Context, params *OauthAuthorizationslistGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsdeleteGrant request
	OauthAuthorizationsdeleteGrant(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsgetGrant request
	OauthAuthorizationsgetGrant(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsdeleteAuthorization request with any body
	AppsdeleteAuthorizationWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsdeleteAuthorization(ctx context.Context, clientId ClientId, body AppsdeleteAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsdeleteToken request with any body
	AppsdeleteTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsdeleteToken(ctx context.Context, clientId ClientId, body AppsdeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsresetToken request with any body
	AppsresetTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsresetToken(ctx context.Context, clientId ClientId, body AppsresetTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppscheckToken request with any body
	AppscheckTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppscheckToken(ctx context.Context, clientId ClientId, body AppscheckTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsscopeToken request with any body
	AppsscopeTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AppsscopeToken(ctx context.Context, clientId ClientId, body AppsscopeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetBySlug request
	AppsgetBySlug(ctx context.Context, appSlug AppSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationslistAuthorizations request
	OauthAuthorizationslistAuthorizations(ctx context.Context, params *OauthAuthorizationslistAuthorizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationscreateAuthorization request with any body
	OauthAuthorizationscreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthAuthorizationscreateAuthorization(ctx context.Context, body OauthAuthorizationscreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsgetOrCreateAuthorizationForApp request with any body
	OauthAuthorizationsgetOrCreateAuthorizationForAppWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthAuthorizationsgetOrCreateAuthorizationForApp(ctx context.Context, clientId ClientId, body OauthAuthorizationsgetOrCreateAuthorizationForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint request with any body
	OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBody(ctx context.Context, clientId ClientId, fingerprint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, clientId ClientId, fingerprint string, body OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsdeleteAuthorization request
	OauthAuthorizationsdeleteAuthorization(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsgetAuthorization request
	OauthAuthorizationsgetAuthorization(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OauthAuthorizationsupdateAuthorization request with any body
	OauthAuthorizationsupdateAuthorizationWithBody(ctx context.Context, authorizationId AuthorizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OauthAuthorizationsupdateAuthorization(ctx context.Context, authorizationId AuthorizationId, body OauthAuthorizationsupdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodesOfConductgetAllCodesOfConduct request
	CodesOfConductgetAllCodesOfConduct(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodesOfConductgetConductCode request
	CodesOfConductgetConductCode(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Emojisget request
	Emojisget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetServerStatistics request
	EnterpriseAdmingetServerStatistics(ctx context.Context, enterpriseOrOrg EnterpriseOrOrg, params *EnterpriseAdmingetServerStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetActionsCacheUsageForEnterprise request
	ActionsgetActionsCacheUsageForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetGithubActionsPermissionsEnterprise request
	EnterpriseAdmingetGithubActionsPermissionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetGithubActionsPermissionsEnterprise request with any body
	EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetGithubActionsPermissionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetGithubActionsPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise request
	EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise request with any body
	EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise request
	EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise request
	EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetAllowedActionsEnterprise request
	EnterpriseAdmingetAllowedActionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetAllowedActionsEnterprise request with any body
	EnterpriseAdminsetAllowedActionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetAllowedActionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetAllowedActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise request
	ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise Enterprise, body ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise request
	EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise request with any body
	EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise request
	EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise request
	EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise request with any body
	EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise request with any body
	EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise request
	EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise request with any body
	EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise request
	EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise request
	EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistSelfHostedRunnersForEnterprise request
	EnterpriseAdminlistSelfHostedRunnersForEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnersForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistRunnerApplicationsForEnterprise request
	EnterpriseAdminlistRunnerApplicationsForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmincreateRegistrationTokenForEnterprise request
	EnterpriseAdmincreateRegistrationTokenForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmincreateRemoveTokenForEnterprise request
	EnterpriseAdmincreateRemoveTokenForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise request
	EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetSelfHostedRunnerForEnterprise request
	EnterpriseAdmingetSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise request
	EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise request
	EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise request with any body
	EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise request with any body
	EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise request
	EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetAuditLog request
	EnterpriseAdmingetAuditLog(ctx context.Context, enterprise Enterprise, params *EnterpriseAdmingetAuditLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanninglistAlertsForEnterprise request
	SecretScanninglistAlertsForEnterprise(ctx context.Context, enterprise Enterprise, params *SecretScanninglistAlertsForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubActionsBillingGhe request
	BillinggetGithubActionsBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubAdvancedSecurityBillingGhe request
	BillinggetGithubAdvancedSecurityBillingGhe(ctx context.Context, enterprise Enterprise, params *BillinggetGithubAdvancedSecurityBillingGheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubPackagesBillingGhe request
	BillinggetGithubPackagesBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetSharedStorageBillingGhe request
	BillinggetSharedStorageBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistPublicEvents request
	ActivitylistPublicEvents(ctx context.Context, params *ActivitylistPublicEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitygetFeeds request
	ActivitygetFeeds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistslist request
	Gistslist(ctx context.Context, params *GistslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistscreate request with any body
	GistscreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Gistscreate(ctx context.Context, body GistscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistPublic request
	GistslistPublic(ctx context.Context, params *GistslistPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistStarred request
	GistslistStarred(ctx context.Context, params *GistslistStarredParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsdelete request
	Gistsdelete(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsget request
	Gistsget(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsupdate request with any body
	GistsupdateWithBody(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Gistsupdate(ctx context.Context, gistId GistId, body GistsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistComments request
	GistslistComments(ctx context.Context, gistId GistId, params *GistslistCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistscreateComment request with any body
	GistscreateCommentWithBody(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GistscreateComment(ctx context.Context, gistId GistId, body GistscreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistsdeleteComment request
	GistsdeleteComment(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistsgetComment request
	GistsgetComment(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistsupdateComment request with any body
	GistsupdateCommentWithBody(ctx context.Context, gistId GistId, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GistsupdateComment(ctx context.Context, gistId GistId, commentId CommentId, body GistsupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistCommits request
	GistslistCommits(ctx context.Context, gistId GistId, params *GistslistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistForks request
	GistslistForks(ctx context.Context, gistId GistId, params *GistslistForksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsfork request
	Gistsfork(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsunstar request
	Gistsunstar(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistscheckIsStarred request
	GistscheckIsStarred(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Gistsstar request
	Gistsstar(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistsgetRevision request
	GistsgetRevision(ctx context.Context, gistId GistId, sha string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitignoregetAllTemplates request
	GitignoregetAllTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitignoregetTemplate request
	GitignoregetTemplate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistReposAccessibleToInstallation request
	AppslistReposAccessibleToInstallation(ctx context.Context, params *AppslistReposAccessibleToInstallationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsrevokeInstallationAccessToken request
	AppsrevokeInstallationAccessToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issueslist request
	Issueslist(ctx context.Context, params *IssueslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LicensesgetAllCommonlyUsed request
	LicensesgetAllCommonlyUsed(ctx context.Context, params *LicensesgetAllCommonlyUsedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Licensesget request
	Licensesget(ctx context.Context, license string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Markdownrender request with any body
	MarkdownrenderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Markdownrender(ctx context.Context, body MarkdownrenderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MarkdownrenderRaw request with any body
	MarkdownrenderRawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetSubscriptionPlanForAccount request
	AppsgetSubscriptionPlanForAccount(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistPlans request
	AppslistPlans(ctx context.Context, params *AppslistPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistAccountsForPlan request
	AppslistAccountsForPlan(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetSubscriptionPlanForAccountStubbed request
	AppsgetSubscriptionPlanForAccountStubbed(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistPlansStubbed request
	AppslistPlansStubbed(ctx context.Context, params *AppslistPlansStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistAccountsForPlanStubbed request
	AppslistAccountsForPlanStubbed(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Metaget request
	Metaget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistPublicEventsForRepoNetwork request
	ActivitylistPublicEventsForRepoNetwork(ctx context.Context, owner Owner, repo Repo, params *ActivitylistPublicEventsForRepoNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistNotificationsForAuthenticatedUser request
	ActivitylistNotificationsForAuthenticatedUser(ctx context.Context, params *ActivitylistNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitymarkNotificationsAsRead request with any body
	ActivitymarkNotificationsAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivitymarkNotificationsAsRead(ctx context.Context, body ActivitymarkNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitygetThread request
	ActivitygetThread(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitymarkThreadAsRead request
	ActivitymarkThreadAsRead(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitydeleteThreadSubscription request
	ActivitydeleteThreadSubscription(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitygetThreadSubscriptionForAuthenticatedUser request
	ActivitygetThreadSubscriptionForAuthenticatedUser(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitysetThreadSubscription request with any body
	ActivitysetThreadSubscriptionWithBody(ctx context.Context, threadId ThreadId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivitysetThreadSubscription(ctx context.Context, threadId ThreadId, body ActivitysetThreadSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetagetOctocat request
	MetagetOctocat(ctx context.Context, params *MetagetOctocatParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Orgslist request
	Orgslist(ctx context.Context, params *OrgslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistCustomRoles request
	OrgslistCustomRoles(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Orgsget request
	Orgsget(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Orgsupdate request with any body
	OrgsupdateWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Orgsupdate(ctx context.Context, org Org, body OrgsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetActionsCacheUsageForOrg request
	ActionsgetActionsCacheUsageForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetActionsCacheUsageByRepoForOrg request
	ActionsgetActionsCacheUsageByRepoForOrg(ctx context.Context, org Org, params *ActionsgetActionsCacheUsageByRepoForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetGithubActionsPermissionsOrganization request
	ActionsgetGithubActionsPermissionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetGithubActionsPermissionsOrganization request with any body
	ActionssetGithubActionsPermissionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetGithubActionsPermissionsOrganization(ctx context.Context, org Org, body ActionssetGithubActionsPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelectedRepositoriesEnabledGithubActionsOrganization request
	ActionslistSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org Org, params *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetSelectedRepositoriesEnabledGithubActionsOrganization request with any body
	ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org Org, body ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdisableSelectedRepositoryGithubActionsOrganization request
	ActionsdisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsenableSelectedRepositoryGithubActionsOrganization request
	ActionsenableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetAllowedActionsOrganization request
	ActionsgetAllowedActionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetAllowedActionsOrganization request with any body
	ActionssetAllowedActionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetAllowedActionsOrganization(ctx context.Context, org Org, body ActionssetAllowedActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization request
	ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsOrganization request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org Org, body ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelfHostedRunnerGroupsForOrg request
	ActionslistSelfHostedRunnerGroupsForOrg(ctx context.Context, org Org, params *ActionslistSelfHostedRunnerGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateSelfHostedRunnerGroupForOrg request with any body
	ActionscreateSelfHostedRunnerGroupForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionscreateSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, body ActionscreateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteSelfHostedRunnerGroupFromOrg request
	ActionsdeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetSelfHostedRunnerGroupForOrg request
	ActionsgetSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsupdateSelfHostedRunnerGroupForOrg request with any body
	ActionsupdateSelfHostedRunnerGroupForOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsupdateSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionsupdateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionslistRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetRepoAccessToSelfHostedRunnerGroupInOrg request with any body
	ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetRepoAccessToSelfHostedRunnerGroupInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelfHostedRunnersInGroupForOrg request
	ActionslistSelfHostedRunnersInGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistSelfHostedRunnersInGroupForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetSelfHostedRunnersInGroupForOrg request with any body
	ActionssetSelfHostedRunnersInGroupForOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetSelfHostedRunnersInGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetSelfHostedRunnersInGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveSelfHostedRunnerFromGroupForOrg request
	ActionsremoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsaddSelfHostedRunnerToGroupForOrg request
	ActionsaddSelfHostedRunnerToGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelfHostedRunnersForOrg request
	ActionslistSelfHostedRunnersForOrg(ctx context.Context, org Org, params *ActionslistSelfHostedRunnersForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistRunnerApplicationsForOrg request
	ActionslistRunnerApplicationsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateRegistrationTokenForOrg request
	ActionscreateRegistrationTokenForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateRemoveTokenForOrg request
	ActionscreateRemoveTokenForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteSelfHostedRunnerFromOrg request
	ActionsdeleteSelfHostedRunnerFromOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetSelfHostedRunnerForOrg request
	ActionsgetSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg request
	ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistLabelsForSelfHostedRunnerForOrg request
	ActionslistLabelsForSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsaddCustomLabelsToSelfHostedRunnerForOrg request with any body
	ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBody(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsaddCustomLabelsToSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetCustomLabelsForSelfHostedRunnerForOrg request with any body
	ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBody(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetCustomLabelsForSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveCustomLabelFromSelfHostedRunnerForOrg request
	ActionsremoveCustomLabelFromSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistOrgSecrets request
	ActionslistOrgSecrets(ctx context.Context, org Org, params *ActionslistOrgSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetOrgPublicKey request
	ActionsgetOrgPublicKey(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteOrgSecret request
	ActionsdeleteOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetOrgSecret request
	ActionsgetOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateOrUpdateOrgSecret request with any body
	ActionscreateOrUpdateOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionscreateOrUpdateOrgSecret(ctx context.Context, org Org, secretName SecretName, body ActionscreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelectedReposForOrgSecret request
	ActionslistSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, params *ActionslistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetSelectedReposForOrgSecret request with any body
	ActionssetSelectedReposForOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, body ActionssetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveSelectedRepoFromOrgSecret request
	ActionsremoveSelectedRepoFromOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsaddSelectedRepoToOrgSecret request
	ActionsaddSelectedRepoToOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetAuditLog request
	OrgsgetAuditLog(ctx context.Context, org Org, params *OrgsgetAuditLogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistBlockedUsers request
	OrgslistBlockedUsers(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsunblockUser request
	OrgsunblockUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscheckBlockedUser request
	OrgscheckBlockedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsblockUser request
	OrgsblockUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninglistAlertsForOrg request
	CodeScanninglistAlertsForOrg(ctx context.Context, org Org, params *CodeScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistSamlSsoAuthorizations request
	OrgslistSamlSsoAuthorizations(ctx context.Context, org Org, params *OrgslistSamlSsoAuthorizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsremoveSamlSsoAuthorization request
	OrgsremoveSamlSsoAuthorization(ctx context.Context, org Org, credentialId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotlistOrgSecrets request
	DependabotlistOrgSecrets(ctx context.Context, org Org, params *DependabotlistOrgSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotgetOrgPublicKey request
	DependabotgetOrgPublicKey(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotdeleteOrgSecret request
	DependabotdeleteOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotgetOrgSecret request
	DependabotgetOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotcreateOrUpdateOrgSecret request with any body
	DependabotcreateOrUpdateOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DependabotcreateOrUpdateOrgSecret(ctx context.Context, org Org, secretName SecretName, body DependabotcreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotlistSelectedReposForOrgSecret request
	DependabotlistSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, params *DependabotlistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotsetSelectedReposForOrgSecret request with any body
	DependabotsetSelectedReposForOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DependabotsetSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, body DependabotsetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotremoveSelectedRepoFromOrgSecret request
	DependabotremoveSelectedRepoFromOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotaddSelectedRepoToOrgSecret request
	DependabotaddSelectedRepoToOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistPublicOrgEvents request
	ActivitylistPublicOrgEvents(ctx context.Context, org Org, params *ActivitylistPublicOrgEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsexternalIdpGroupInfoForOrg request
	TeamsexternalIdpGroupInfoForOrg(ctx context.Context, org Org, groupId GroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistExternalIdpGroupsForOrg request
	TeamslistExternalIdpGroupsForOrg(ctx context.Context, org Org, params *TeamslistExternalIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistFailedInvitations request
	OrgslistFailedInvitations(ctx context.Context, org Org, params *OrgslistFailedInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistWebhooks request
	OrgslistWebhooks(ctx context.Context, org Org, params *OrgslistWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscreateWebhook request with any body
	OrgscreateWebhookWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgscreateWebhook(ctx context.Context, org Org, body OrgscreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsdeleteWebhook request
	OrgsdeleteWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetWebhook request
	OrgsgetWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsupdateWebhook request with any body
	OrgsupdateWebhookWithBody(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgsupdateWebhook(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetWebhookConfigForOrg request
	OrgsgetWebhookConfigForOrg(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsupdateWebhookConfigForOrg request with any body
	OrgsupdateWebhookConfigForOrgWithBody(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgsupdateWebhookConfigForOrg(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookConfigForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistWebhookDeliveries request
	OrgslistWebhookDeliveries(ctx context.Context, org Org, hookId HookId, params *OrgslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetWebhookDelivery request
	OrgsgetWebhookDelivery(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsredeliverWebhookDelivery request
	OrgsredeliverWebhookDelivery(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgspingWebhook request
	OrgspingWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetOrgInstallation request
	AppsgetOrgInstallation(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistAppInstallations request
	OrgslistAppInstallations(ctx context.Context, org Org, params *OrgslistAppInstallationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsremoveRestrictionsForOrg request
	InteractionsremoveRestrictionsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsgetRestrictionsForOrg request
	InteractionsgetRestrictionsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionssetRestrictionsForOrg request with any body
	InteractionssetRestrictionsForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InteractionssetRestrictionsForOrg(ctx context.Context, org Org, body InteractionssetRestrictionsForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistPendingInvitations request
	OrgslistPendingInvitations(ctx context.Context, org Org, params *OrgslistPendingInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscreateInvitation request with any body
	OrgscreateInvitationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgscreateInvitation(ctx context.Context, org Org, body OrgscreateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscancelInvitation request
	OrgscancelInvitation(ctx context.Context, org Org, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistInvitationTeams request
	OrgslistInvitationTeams(ctx context.Context, org Org, invitationId InvitationId, params *OrgslistInvitationTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistForOrg request
	IssueslistForOrg(ctx context.Context, org Org, params *IssueslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistMembers request
	OrgslistMembers(ctx context.Context, org Org, params *OrgslistMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsremoveMember request
	OrgsremoveMember(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscheckMembershipForUser request
	OrgscheckMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsremoveMembershipForUser request
	OrgsremoveMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetMembershipForUser request
	OrgsgetMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgssetMembershipForUser request with any body
	OrgssetMembershipForUserWithBody(ctx context.Context, org Org, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgssetMembershipForUser(ctx context.Context, org Org, username Username, body OrgssetMembershipForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationslistForOrg request
	MigrationslistForOrg(ctx context.Context, org Org, params *MigrationslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsstartForOrg request with any body
	MigrationsstartForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationsstartForOrg(ctx context.Context, org Org, body MigrationsstartForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetStatusForOrg request
	MigrationsgetStatusForOrg(ctx context.Context, org Org, migrationId MigrationId, params *MigrationsgetStatusForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsdeleteArchiveForOrg request
	MigrationsdeleteArchiveForOrg(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsdownloadArchiveForOrg request
	MigrationsdownloadArchiveForOrg(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsunlockRepoForOrg request
	MigrationsunlockRepoForOrg(ctx context.Context, org Org, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationslistReposForOrg request
	MigrationslistReposForOrg(ctx context.Context, org Org, migrationId MigrationId, params *MigrationslistReposForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistOutsideCollaborators request
	OrgslistOutsideCollaborators(ctx context.Context, org Org, params *OrgslistOutsideCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsremoveOutsideCollaborator request
	OrgsremoveOutsideCollaborator(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsconvertMemberToOutsideCollaborator request
	OrgsconvertMemberToOutsideCollaborator(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackageslistPackagesForOrganization request
	PackageslistPackagesForOrganization(ctx context.Context, org Org, params *PackageslistPackagesForOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageForOrg request
	PackagesdeletePackageForOrg(ctx context.Context, org Org, packageType PackagesdeletePackageForOrgParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageForOrganization request
	PackagesgetPackageForOrganization(ctx context.Context, org Org, packageType PackagesgetPackageForOrganizationParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageForOrg request
	PackagesrestorePackageForOrg(ctx context.Context, org Org, packageType PackagesrestorePackageForOrgParamsPackageType, packageName PackageName, params *PackagesrestorePackageForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByOrg request
	PackagesgetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, org Org, packageType PackagesgetAllPackageVersionsForPackageOwnedByOrgParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageVersionForOrg request
	PackagesdeletePackageVersionForOrg(ctx context.Context, org Org, packageType PackagesdeletePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageVersionForOrganization request
	PackagesgetPackageVersionForOrganization(ctx context.Context, org Org, packageType PackagesgetPackageVersionForOrganizationParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageVersionForOrg request
	PackagesrestorePackageVersionForOrg(ctx context.Context, org Org, packageType PackagesrestorePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistForOrg request
	ProjectslistForOrg(ctx context.Context, org Org, params *ProjectslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectscreateForOrg request with any body
	ProjectscreateForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectscreateForOrg(ctx context.Context, org Org, body ProjectscreateForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistPublicMembers request
	OrgslistPublicMembers(ctx context.Context, org Org, params *OrgslistPublicMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsremovePublicMembershipForAuthenticatedUser request
	OrgsremovePublicMembershipForAuthenticatedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgscheckPublicMembershipForUser request
	OrgscheckPublicMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgssetPublicMembershipForAuthenticatedUser request
	OrgssetPublicMembershipForAuthenticatedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistForOrg request
	ReposlistForOrg(ctx context.Context, org Org, params *ReposlistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateInOrg request with any body
	ReposcreateInOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateInOrg(ctx context.Context, org Org, body ReposcreateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanninglistAlertsForOrg request
	SecretScanninglistAlertsForOrg(ctx context.Context, org Org, params *SecretScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubActionsBillingOrg request
	BillinggetGithubActionsBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubAdvancedSecurityBillingOrg request
	BillinggetGithubAdvancedSecurityBillingOrg(ctx context.Context, org Org, params *BillinggetGithubAdvancedSecurityBillingOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubPackagesBillingOrg request
	BillinggetGithubPackagesBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetSharedStorageBillingOrg request
	BillinggetSharedStorageBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistIdpGroupsForOrg request
	TeamslistIdpGroupsForOrg(ctx context.Context, org Org, params *TeamslistIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Teamslist request
	Teamslist(ctx context.Context, org Org, params *TeamslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Teamscreate request with any body
	TeamscreateWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Teamscreate(ctx context.Context, org Org, body TeamscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteInOrg request
	TeamsdeleteInOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetByName request
	TeamsgetByName(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateInOrg request with any body
	TeamsupdateInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamsupdateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistDiscussionsInOrg request
	TeamslistDiscussionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistDiscussionsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateDiscussionInOrg request with any body
	TeamscreateDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteDiscussionInOrg request
	TeamsdeleteDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetDiscussionInOrg request
	TeamsgetDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateDiscussionInOrg request with any body
	TeamsupdateDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamsupdateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistDiscussionCommentsInOrg request
	TeamslistDiscussionCommentsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateDiscussionCommentInOrg request with any body
	TeamscreateDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteDiscussionCommentInOrg request
	TeamsdeleteDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetDiscussionCommentInOrg request
	TeamsgetDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateDiscussionCommentInOrg request with any body
	TeamsupdateDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForTeamDiscussionCommentInOrg request
	ReactionslistForTeamDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForTeamDiscussionCommentInOrg request with any body
	ReactionscreateForTeamDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForTeamDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForTeamDiscussionComment request
	ReactionsdeleteForTeamDiscussionComment(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForTeamDiscussionInOrg request
	ReactionslistForTeamDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForTeamDiscussionInOrg request with any body
	ReactionscreateForTeamDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForTeamDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForTeamDiscussion request
	ReactionsdeleteForTeamDiscussion(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsunlinkExternalIdpGroupFromTeamForOrg request
	TeamsunlinkExternalIdpGroupFromTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistLinkedExternalIdpGroupsToTeamForOrg request
	TeamslistLinkedExternalIdpGroupsToTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslinkExternalIdpGroupToTeamForOrg request with any body
	TeamslinkExternalIdpGroupToTeamForOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamslinkExternalIdpGroupToTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamslinkExternalIdpGroupToTeamForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistPendingInvitationsInOrg request
	TeamslistPendingInvitationsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistPendingInvitationsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistMembersInOrg request
	TeamslistMembersInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistMembersInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveMembershipForUserInOrg request
	TeamsremoveMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetMembershipForUserInOrg request
	TeamsgetMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateMembershipForUserInOrg request with any body
	TeamsaddOrUpdateMembershipForUserInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, body TeamsaddOrUpdateMembershipForUserInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistProjectsInOrg request
	TeamslistProjectsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistProjectsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveProjectInOrg request
	TeamsremoveProjectInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscheckPermissionsForProjectInOrg request
	TeamscheckPermissionsForProjectInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateProjectPermissionsInOrg request with any body
	TeamsaddOrUpdateProjectPermissionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateProjectPermissionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistReposInOrg request
	TeamslistReposInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistReposInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveRepoInOrg request
	TeamsremoveRepoInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscheckPermissionsForRepoInOrg request
	TeamscheckPermissionsForRepoInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateRepoPermissionsInOrg request with any body
	TeamsaddOrUpdateRepoPermissionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateRepoPermissionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistIdpGroupsInOrg request
	TeamslistIdpGroupsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateOrUpdateIdpGroupConnectionsInOrg request with any body
	TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateOrUpdateIdpGroupConnectionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistChildInOrg request
	TeamslistChildInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistChildInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsdeleteCard request
	ProjectsdeleteCard(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsgetCard request
	ProjectsgetCard(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsupdateCard request with any body
	ProjectsupdateCardWithBody(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsupdateCard(ctx context.Context, cardId CardId, body ProjectsupdateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsmoveCard request with any body
	ProjectsmoveCardWithBody(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsmoveCard(ctx context.Context, cardId CardId, body ProjectsmoveCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsdeleteColumn request
	ProjectsdeleteColumn(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsgetColumn request
	ProjectsgetColumn(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsupdateColumn request with any body
	ProjectsupdateColumnWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsupdateColumn(ctx context.Context, columnId ColumnId, body ProjectsupdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistCards request
	ProjectslistCards(ctx context.Context, columnId ColumnId, params *ProjectslistCardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectscreateCard request with any body
	ProjectscreateCardWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectscreateCard(ctx context.Context, columnId ColumnId, body ProjectscreateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsmoveColumn request with any body
	ProjectsmoveColumnWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsmoveColumn(ctx context.Context, columnId ColumnId, body ProjectsmoveColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Projectsdelete request
	Projectsdelete(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Projectsget request
	Projectsget(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Projectsupdate request with any body
	ProjectsupdateWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Projectsupdate(ctx context.Context, projectId ProjectId, body ProjectsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistCollaborators request
	ProjectslistCollaborators(ctx context.Context, projectId ProjectId, params *ProjectslistCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsremoveCollaborator request
	ProjectsremoveCollaborator(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsaddCollaborator request with any body
	ProjectsaddCollaboratorWithBody(ctx context.Context, projectId ProjectId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectsaddCollaborator(ctx context.Context, projectId ProjectId, username Username, body ProjectsaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectsgetPermissionForUser request
	ProjectsgetPermissionForUser(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistColumns request
	ProjectslistColumns(ctx context.Context, projectId ProjectId, params *ProjectslistColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectscreateColumn request with any body
	ProjectscreateColumnWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectscreateColumn(ctx context.Context, projectId ProjectId, body ProjectscreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RateLimitget request
	RateLimitget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reposdelete request
	Reposdelete(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reposget request
	Reposget(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reposupdate request with any body
	ReposupdateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Reposupdate(ctx context.Context, owner Owner, repo Repo, body ReposupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistArtifactsForRepo request
	ActionslistArtifactsForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistArtifactsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteArtifact request
	ActionsdeleteArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetArtifact request
	ActionsgetArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdownloadArtifact request
	ActionsdownloadArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, archiveFormat string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetActionsCacheUsage request
	ActionsgetActionsCacheUsage(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetJobForWorkflowRun request
	ActionsgetJobForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdownloadJobLogsForWorkflowRun request
	ActionsdownloadJobLogsForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsreRunJobForWorkflowRun request with any body
	ActionsreRunJobForWorkflowRunWithBody(ctx context.Context, owner Owner, repo Repo, jobId JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsreRunJobForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, body ActionsreRunJobForWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetGithubActionsPermissionsRepository request
	ActionsgetGithubActionsPermissionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetGithubActionsPermissionsRepository request with any body
	ActionssetGithubActionsPermissionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetGithubActionsPermissionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflowAccessToRepository request
	ActionsgetWorkflowAccessToRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetWorkflowAccessToRepository request with any body
	ActionssetWorkflowAccessToRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetWorkflowAccessToRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetWorkflowAccessToRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetAllowedActionsRepository request
	ActionsgetAllowedActionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetAllowedActionsRepository request with any body
	ActionssetAllowedActionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetAllowedActionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetAllowedActionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsRepository request
	ActionsgetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsRepository request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistSelfHostedRunnersForRepo request
	ActionslistSelfHostedRunnersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistSelfHostedRunnersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistRunnerApplicationsForRepo request
	ActionslistRunnerApplicationsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateRegistrationTokenForRepo request
	ActionscreateRegistrationTokenForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateRemoveTokenForRepo request
	ActionscreateRemoveTokenForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteSelfHostedRunnerFromRepo request
	ActionsdeleteSelfHostedRunnerFromRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetSelfHostedRunnerForRepo request
	ActionsgetSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo request
	ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistLabelsForSelfHostedRunnerForRepo request
	ActionslistLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsaddCustomLabelsToSelfHostedRunnerForRepo request with any body
	ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBody(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsaddCustomLabelsToSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionssetCustomLabelsForSelfHostedRunnerForRepo request with any body
	ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBody(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionssetCustomLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsremoveCustomLabelFromSelfHostedRunnerForRepo request
	ActionsremoveCustomLabelFromSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistWorkflowRunsForRepo request
	ActionslistWorkflowRunsForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistWorkflowRunsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteWorkflowRun request
	ActionsdeleteWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflowRun request
	ActionsgetWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionsgetWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetReviewsForRun request
	ActionsgetReviewsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsapproveWorkflowRun request
	ActionsapproveWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistWorkflowRunArtifacts request
	ActionslistWorkflowRunArtifacts(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistWorkflowRunArtifactsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflowRunAttempt request
	ActionsgetWorkflowRunAttempt(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionsgetWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistJobsForWorkflowRunAttempt request
	ActionslistJobsForWorkflowRunAttempt(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionslistJobsForWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdownloadWorkflowRunAttemptLogs request
	ActionsdownloadWorkflowRunAttemptLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscancelWorkflowRun request
	ActionscancelWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistJobsForWorkflowRun request
	ActionslistJobsForWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistJobsForWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteWorkflowRunLogs request
	ActionsdeleteWorkflowRunLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdownloadWorkflowRunLogs request
	ActionsdownloadWorkflowRunLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetPendingDeploymentsForRun request
	ActionsgetPendingDeploymentsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsreviewPendingDeploymentsForRun request with any body
	ActionsreviewPendingDeploymentsForRunWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsreviewPendingDeploymentsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreviewPendingDeploymentsForRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsreRunWorkflow request with any body
	ActionsreRunWorkflowWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsreRunWorkflow(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsreRunWorkflowFailedJobs request with any body
	ActionsreRunWorkflowFailedJobsWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionsreRunWorkflowFailedJobs(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowFailedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflowRunUsage request
	ActionsgetWorkflowRunUsage(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistRepoSecrets request
	ActionslistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetRepoPublicKey request
	ActionsgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteRepoSecret request
	ActionsdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetRepoSecret request
	ActionsgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateOrUpdateRepoSecret request with any body
	ActionscreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionscreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body ActionscreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistRepoWorkflows request
	ActionslistRepoWorkflows(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflow request
	ActionsgetWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdisableWorkflow request
	ActionsdisableWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateWorkflowDispatch request with any body
	ActionscreateWorkflowDispatchWithBody(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionscreateWorkflowDispatch(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, body ActionscreateWorkflowDispatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsenableWorkflow request
	ActionsenableWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistWorkflowRuns request
	ActionslistWorkflowRuns(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, params *ActionslistWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetWorkflowUsage request
	ActionsgetWorkflowUsage(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistAssignees request
	IssueslistAssignees(ctx context.Context, owner Owner, repo Repo, params *IssueslistAssigneesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuescheckUserCanBeAssigned request
	IssuescheckUserCanBeAssigned(ctx context.Context, owner Owner, repo Repo, assignee string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistAutolinks request
	ReposlistAutolinks(ctx context.Context, owner Owner, repo Repo, params *ReposlistAutolinksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateAutolink request with any body
	ReposcreateAutolinkWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateAutolink(ctx context.Context, owner Owner, repo Repo, body ReposcreateAutolinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteAutolink request
	ReposdeleteAutolink(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAutolink request
	ReposgetAutolink(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdisableAutomatedSecurityFixes request
	ReposdisableAutomatedSecurityFixes(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposenableAutomatedSecurityFixes request
	ReposenableAutomatedSecurityFixes(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistBranches request
	ReposlistBranches(ctx context.Context, owner Owner, repo Repo, params *ReposlistBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetBranch request
	ReposgetBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteBranchProtection request
	ReposdeleteBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetBranchProtection request
	ReposgetBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateBranchProtection request with any body
	ReposupdateBranchProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateBranchProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteAdminBranchProtection request
	ReposdeleteAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAdminBranchProtection request
	ReposgetAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepossetAdminBranchProtection request
	RepossetAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeletePullRequestReviewProtection request
	ReposdeletePullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetPullRequestReviewProtection request
	ReposgetPullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdatePullRequestReviewProtection request with any body
	ReposupdatePullRequestReviewProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdatePullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdatePullRequestReviewProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteCommitSignatureProtection request
	ReposdeleteCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCommitSignatureProtection request
	ReposgetCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateCommitSignatureProtection request
	ReposcreateCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveStatusCheckProtection request
	ReposremoveStatusCheckProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetStatusChecksProtection request
	ReposgetStatusChecksProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateStatusCheckProtection request with any body
	ReposupdateStatusCheckProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateStatusCheckProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateStatusCheckProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveStatusCheckContexts request with any body
	ReposremoveStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposremoveStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAllStatusCheckContexts request
	ReposgetAllStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposaddStatusCheckContexts request with any body
	ReposaddStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposaddStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepossetStatusCheckContexts request with any body
	RepossetStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepossetStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteAccessRestrictions request
	ReposdeleteAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAccessRestrictions request
	ReposgetAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveAppAccessRestrictions request with any body
	ReposremoveAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposremoveAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAppsWithAccessToProtectedBranch request
	ReposgetAppsWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposaddAppAccessRestrictions request with any body
	ReposaddAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposaddAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepossetAppAccessRestrictions request with any body
	RepossetAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepossetAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveTeamAccessRestrictions request with any body
	ReposremoveTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposremoveTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetTeamsWithAccessToProtectedBranch request
	ReposgetTeamsWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposaddTeamAccessRestrictions request with any body
	ReposaddTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposaddTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepossetTeamAccessRestrictions request with any body
	RepossetTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepossetTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveUserAccessRestrictions request with any body
	ReposremoveUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposremoveUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetUsersWithAccessToProtectedBranch request
	ReposgetUsersWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposaddUserAccessRestrictions request with any body
	ReposaddUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposaddUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepossetUserAccessRestrictions request with any body
	RepossetUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RepossetUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposrenameBranch request with any body
	ReposrenameBranchWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposrenameBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposrenameBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Checkscreate request with any body
	CheckscreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Checkscreate(ctx context.Context, owner Owner, repo Repo, body CheckscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Checksget request
	Checksget(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Checksupdate request with any body
	ChecksupdateWithBody(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Checksupdate(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, body ChecksupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckslistAnnotations request
	CheckslistAnnotations(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, params *CheckslistAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChecksrerequestRun request
	ChecksrerequestRun(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckscreateSuite request with any body
	CheckscreateSuiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckscreateSuite(ctx context.Context, owner Owner, repo Repo, body CheckscreateSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckssetSuitesPreferences request with any body
	CheckssetSuitesPreferencesWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckssetSuitesPreferences(ctx context.Context, owner Owner, repo Repo, body CheckssetSuitesPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChecksgetSuite request
	ChecksgetSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckslistForSuite request
	CheckslistForSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, params *CheckslistForSuiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChecksrerequestSuite request
	ChecksrerequestSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninglistAlertsForRepo request
	CodeScanninglistAlertsForRepo(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninggetAlert request
	CodeScanninggetAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanningupdateAlert request with any body
	CodeScanningupdateAlertWithBody(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeScanningupdateAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body CodeScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninglistAlertInstances request
	CodeScanninglistAlertInstances(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *CodeScanninglistAlertInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninglistRecentAnalyses request
	CodeScanninglistRecentAnalyses(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistRecentAnalysesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanningdeleteAnalysis request
	CodeScanningdeleteAnalysis(ctx context.Context, owner Owner, repo Repo, analysisId int, params *CodeScanningdeleteAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninggetAnalysis request
	CodeScanninggetAnalysis(ctx context.Context, owner Owner, repo Repo, analysisId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninguploadSarif request with any body
	CodeScanninguploadSarifWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodeScanninguploadSarif(ctx context.Context, owner Owner, repo Repo, body CodeScanninguploadSarifJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodeScanninggetSarif request
	CodeScanninggetSarif(ctx context.Context, owner Owner, repo Repo, sarifId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcodeownersErrors request
	ReposcodeownersErrors(ctx context.Context, owner Owner, repo Repo, params *ReposcodeownersErrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistInRepositoryForAuthenticatedUser request
	CodespaceslistInRepositoryForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescreateWithRepoForAuthenticatedUser request with any body
	CodespacescreateWithRepoForAuthenticatedUserWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacescreateWithRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, body CodespacescreateWithRepoForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistDevcontainersInRepositoryForAuthenticatedUser request
	CodespaceslistDevcontainersInRepositoryForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesrepoMachinesForAuthenticatedUser request
	CodespacesrepoMachinesForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespacesrepoMachinesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistRepoSecrets request
	CodespaceslistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetRepoPublicKey request
	CodespacesgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesdeleteRepoSecret request
	CodespacesdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetRepoSecret request
	CodespacesgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescreateOrUpdateRepoSecret request with any body
	CodespacescreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacescreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body CodespacescreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistCollaborators request
	ReposlistCollaborators(ctx context.Context, owner Owner, repo Repo, params *ReposlistCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposremoveCollaborator request
	ReposremoveCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcheckCollaborator request
	ReposcheckCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposaddCollaborator request with any body
	ReposaddCollaboratorWithBody(ctx context.Context, owner Owner, repo Repo, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposaddCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, body ReposaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCollaboratorPermissionLevel request
	ReposgetCollaboratorPermissionLevel(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistCommitCommentsForRepo request
	ReposlistCommitCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteCommitComment request
	ReposdeleteCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCommitComment request
	ReposgetCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateCommitComment request with any body
	ReposupdateCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReposupdateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForCommitComment request
	ReactionslistForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForCommitCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForCommitComment request with any body
	ReactionscreateForCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForCommitComment request
	ReactionsdeleteForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistCommits request
	ReposlistCommits(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistBranchesForHeadCommit request
	ReposlistBranchesForHeadCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistCommentsForCommit request
	ReposlistCommentsForCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistCommentsForCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateCommitComment request with any body
	ReposcreateCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateCommitComment(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, body ReposcreateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistPullRequestsAssociatedWithCommit request
	ReposlistPullRequestsAssociatedWithCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistPullRequestsAssociatedWithCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCommit request
	ReposgetCommit(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckslistForRef request
	CheckslistForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckslistSuitesForRef request
	CheckslistSuitesForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistSuitesForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCombinedStatusForRef request
	ReposgetCombinedStatusForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCombinedStatusForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistCommitStatusesForRef request
	ReposlistCommitStatusesForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposlistCommitStatusesForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCommunityProfileMetrics request
	ReposgetCommunityProfileMetrics(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcompareCommits request
	ReposcompareCommits(ctx context.Context, owner Owner, repo Repo, basehead string, params *ReposcompareCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteFile request with any body
	ReposdeleteFileWithBody(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposdeleteFile(ctx context.Context, owner Owner, repo Repo, path string, body ReposdeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetContent request
	ReposgetContent(ctx context.Context, owner Owner, repo Repo, path string, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateOrUpdateFileContents request with any body
	ReposcreateOrUpdateFileContentsWithBody(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateOrUpdateFileContents(ctx context.Context, owner Owner, repo Repo, path string, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistContributors request
	ReposlistContributors(ctx context.Context, owner Owner, repo Repo, params *ReposlistContributorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotlistRepoSecrets request
	DependabotlistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *DependabotlistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotgetRepoPublicKey request
	DependabotgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotdeleteRepoSecret request
	DependabotdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotgetRepoSecret request
	DependabotgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependabotcreateOrUpdateRepoSecret request with any body
	DependabotcreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DependabotcreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body DependabotcreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DependencyGraphdiffRange request
	DependencyGraphdiffRange(ctx context.Context, owner Owner, repo Repo, basehead string, params *DependencyGraphdiffRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistDeployments request
	ReposlistDeployments(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateDeployment request with any body
	ReposcreateDeploymentWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateDeployment(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteDeployment request
	ReposdeleteDeployment(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetDeployment request
	ReposgetDeployment(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistDeploymentStatuses request
	ReposlistDeploymentStatuses(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, params *ReposlistDeploymentStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateDeploymentStatus request with any body
	ReposcreateDeploymentStatusWithBody(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateDeploymentStatus(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, body ReposcreateDeploymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetDeploymentStatus request
	ReposgetDeploymentStatus(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, statusId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateDispatchEvent request with any body
	ReposcreateDispatchEventWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateDispatchEvent(ctx context.Context, owner Owner, repo Repo, body ReposcreateDispatchEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAllEnvironments request
	ReposgetAllEnvironments(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteAnEnvironment request
	ReposdeleteAnEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetEnvironment request
	ReposgetEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateOrUpdateEnvironment request with any body
	ReposcreateOrUpdateEnvironmentWithBody(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateOrUpdateEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, body ReposcreateOrUpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistRepoEvents request
	ActivitylistRepoEvents(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistForks request
	ReposlistForks(ctx context.Context, owner Owner, repo Repo, params *ReposlistForksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateFork request with any body
	ReposcreateForkWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateFork(ctx context.Context, owner Owner, repo Repo, body ReposcreateForkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitcreateBlob request with any body
	GitcreateBlobWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitcreateBlob(ctx context.Context, owner Owner, repo Repo, body GitcreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitgetBlob request
	GitgetBlob(ctx context.Context, owner Owner, repo Repo, fileSha string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitcreateCommit request with any body
	GitcreateCommitWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitcreateCommit(ctx context.Context, owner Owner, repo Repo, body GitcreateCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitgetCommit request
	GitgetCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitlistMatchingRefs request
	GitlistMatchingRefs(ctx context.Context, owner Owner, repo Repo, ref string, params *GitlistMatchingRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitgetRef request
	GitgetRef(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitcreateRef request with any body
	GitcreateRefWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitcreateRef(ctx context.Context, owner Owner, repo Repo, body GitcreateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitdeleteRef request
	GitdeleteRef(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitupdateRef request with any body
	GitupdateRefWithBody(ctx context.Context, owner Owner, repo Repo, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitupdateRef(ctx context.Context, owner Owner, repo Repo, ref string, body GitupdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitcreateTag request with any body
	GitcreateTagWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitcreateTag(ctx context.Context, owner Owner, repo Repo, body GitcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitgetTag request
	GitgetTag(ctx context.Context, owner Owner, repo Repo, tagSha string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitcreateTree request with any body
	GitcreateTreeWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GitcreateTree(ctx context.Context, owner Owner, repo Repo, body GitcreateTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GitgetTree request
	GitgetTree(ctx context.Context, owner Owner, repo Repo, treeSha string, params *GitgetTreeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistWebhooks request
	ReposlistWebhooks(ctx context.Context, owner Owner, repo Repo, params *ReposlistWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateWebhook request with any body
	ReposcreateWebhookWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateWebhook(ctx context.Context, owner Owner, repo Repo, body ReposcreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteWebhook request
	ReposdeleteWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetWebhook request
	ReposgetWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateWebhook request with any body
	ReposupdateWebhookWithBody(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetWebhookConfigForRepo request
	ReposgetWebhookConfigForRepo(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateWebhookConfigForRepo request with any body
	ReposupdateWebhookConfigForRepoWithBody(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateWebhookConfigForRepo(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookConfigForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistWebhookDeliveries request
	ReposlistWebhookDeliveries(ctx context.Context, owner Owner, repo Repo, hookId HookId, params *ReposlistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetWebhookDelivery request
	ReposgetWebhookDelivery(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposredeliverWebhookDelivery request
	ReposredeliverWebhookDelivery(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepospingWebhook request
	RepospingWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RepostestPushWebhook request
	RepostestPushWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationscancelImport request
	MigrationscancelImport(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetImportStatus request
	MigrationsgetImportStatus(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsupdateImport request with any body
	MigrationsupdateImportWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationsupdateImport(ctx context.Context, owner Owner, repo Repo, body MigrationsupdateImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsstartImport request with any body
	MigrationsstartImportWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationsstartImport(ctx context.Context, owner Owner, repo Repo, body MigrationsstartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetCommitAuthors request
	MigrationsgetCommitAuthors(ctx context.Context, owner Owner, repo Repo, params *MigrationsgetCommitAuthorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsmapCommitAuthor request with any body
	MigrationsmapCommitAuthorWithBody(ctx context.Context, owner Owner, repo Repo, authorId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationsmapCommitAuthor(ctx context.Context, owner Owner, repo Repo, authorId int, body MigrationsmapCommitAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetLargeFiles request
	MigrationsgetLargeFiles(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationssetLfsPreference request with any body
	MigrationssetLfsPreferenceWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationssetLfsPreference(ctx context.Context, owner Owner, repo Repo, body MigrationssetLfsPreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetRepoInstallation request
	AppsgetRepoInstallation(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsremoveRestrictionsForRepo request
	InteractionsremoveRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsgetRestrictionsForRepo request
	InteractionsgetRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionssetRestrictionsForRepo request with any body
	InteractionssetRestrictionsForRepoWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InteractionssetRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, body InteractionssetRestrictionsForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistInvitations request
	ReposlistInvitations(ctx context.Context, owner Owner, repo Repo, params *ReposlistInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteInvitation request
	ReposdeleteInvitation(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateInvitation request with any body
	ReposupdateInvitationWithBody(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateInvitation(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, body ReposupdateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistForRepo request
	IssueslistForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issuescreate request with any body
	IssuescreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Issuescreate(ctx context.Context, owner Owner, repo Repo, body IssuescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistCommentsForRepo request
	IssueslistCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesdeleteComment request
	IssuesdeleteComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesgetComment request
	IssuesgetComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesupdateComment request with any body
	IssuesupdateCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesupdateComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body IssuesupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForIssueComment request
	ReactionslistForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForIssueCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForIssueComment request with any body
	ReactionscreateForIssueCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForIssueCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForIssueComment request
	ReactionsdeleteForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistEventsForRepo request
	IssueslistEventsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistEventsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesgetEvent request
	IssuesgetEvent(ctx context.Context, owner Owner, repo Repo, eventId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issuesget request
	Issuesget(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issuesupdate request with any body
	IssuesupdateWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Issuesupdate(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesremoveAssignees request with any body
	IssuesremoveAssigneesWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesremoveAssignees(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesremoveAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesaddAssignees request with any body
	IssuesaddAssigneesWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesaddAssignees(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistComments request
	IssueslistComments(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuescreateComment request with any body
	IssuescreateCommentWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuescreateComment(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuescreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistEvents request
	IssueslistEvents(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesremoveAllLabels request
	IssuesremoveAllLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistLabelsOnIssue request
	IssueslistLabelsOnIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistLabelsOnIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesaddLabels request with any body
	IssuesaddLabelsWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesaddLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuessetLabels request with any body
	IssuessetLabelsWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuessetLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuessetLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesremoveLabel request
	IssuesremoveLabel(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issuesunlock request
	Issuesunlock(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issueslock request with any body
	IssueslockWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Issueslock(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssueslockJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForIssue request
	ReactionslistForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *ReactionslistForIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForIssue request with any body
	ReactionscreateForIssueWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body ReactionscreateForIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForIssue request
	ReactionsdeleteForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistEventsForTimeline request
	IssueslistEventsForTimeline(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsForTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistDeployKeys request
	ReposlistDeployKeys(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeployKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateDeployKey request with any body
	ReposcreateDeployKeyWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateDeployKey(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeployKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteDeployKey request
	ReposdeleteDeployKey(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetDeployKey request
	ReposgetDeployKey(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistLabelsForRepo request
	IssueslistLabelsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistLabelsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuescreateLabel request with any body
	IssuescreateLabelWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuescreateLabel(ctx context.Context, owner Owner, repo Repo, body IssuescreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesdeleteLabel request
	IssuesdeleteLabel(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesgetLabel request
	IssuesgetLabel(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesupdateLabel request with any body
	IssuesupdateLabelWithBody(ctx context.Context, owner Owner, repo Repo, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesupdateLabel(ctx context.Context, owner Owner, repo Repo, name string, body IssuesupdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistLanguages request
	ReposlistLanguages(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdisableLfsForRepo request
	ReposdisableLfsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposenableLfsForRepo request
	ReposenableLfsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LicensesgetForRepo request
	LicensesgetForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposmergeUpstream request with any body
	ReposmergeUpstreamWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposmergeUpstream(ctx context.Context, owner Owner, repo Repo, body ReposmergeUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Reposmerge request with any body
	ReposmergeWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Reposmerge(ctx context.Context, owner Owner, repo Repo, body ReposmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistMilestones request
	IssueslistMilestones(ctx context.Context, owner Owner, repo Repo, params *IssueslistMilestonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuescreateMilestone request with any body
	IssuescreateMilestoneWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuescreateMilestone(ctx context.Context, owner Owner, repo Repo, body IssuescreateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesdeleteMilestone request
	IssuesdeleteMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesgetMilestone request
	IssuesgetMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssuesupdateMilestone request with any body
	IssuesupdateMilestoneWithBody(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	IssuesupdateMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, body IssuesupdateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistLabelsForMilestone request
	IssueslistLabelsForMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, params *IssueslistLabelsForMilestoneParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistRepoNotificationsForAuthenticatedUser request
	ActivitylistRepoNotificationsForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitymarkRepoNotificationsAsRead request with any body
	ActivitymarkRepoNotificationsAsReadWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivitymarkRepoNotificationsAsRead(ctx context.Context, owner Owner, repo Repo, body ActivitymarkRepoNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeletePagesSite request
	ReposdeletePagesSite(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetPages request
	ReposgetPages(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreatePagesSite request with any body
	ReposcreatePagesSiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreatePagesSite(ctx context.Context, owner Owner, repo Repo, body ReposcreatePagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateInformationAboutPagesSite request with any body
	ReposupdateInformationAboutPagesSiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateInformationAboutPagesSite(ctx context.Context, owner Owner, repo Repo, body ReposupdateInformationAboutPagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistPagesBuilds request
	ReposlistPagesBuilds(ctx context.Context, owner Owner, repo Repo, params *ReposlistPagesBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposrequestPagesBuild request
	ReposrequestPagesBuild(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetLatestPagesBuild request
	ReposgetLatestPagesBuild(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetPagesBuild request
	ReposgetPagesBuild(ctx context.Context, owner Owner, repo Repo, buildId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetPagesHealthCheck request
	ReposgetPagesHealthCheck(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistForRepo request
	ProjectslistForRepo(ctx context.Context, owner Owner, repo Repo, params *ProjectslistForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectscreateForRepo request with any body
	ProjectscreateForRepoWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectscreateForRepo(ctx context.Context, owner Owner, repo Repo, body ProjectscreateForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pullslist request
	Pullslist(ctx context.Context, owner Owner, repo Repo, params *PullslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pullscreate request with any body
	PullscreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Pullscreate(ctx context.Context, owner Owner, repo Repo, body PullscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistReviewCommentsForRepo request
	PullslistReviewCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *PullslistReviewCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsdeleteReviewComment request
	PullsdeleteReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsgetReviewComment request
	PullsgetReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsupdateReviewComment request with any body
	PullsupdateReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsupdateReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body PullsupdateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForPullRequestReviewComment request
	ReactionslistForPullRequestReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForPullRequestReviewCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForPullRequestReviewComment request with any body
	ReactionscreateForPullRequestReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForPullRequestReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForPullRequestReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForPullRequestComment request
	ReactionsdeleteForPullRequestComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pullsget request
	Pullsget(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pullsupdate request with any body
	PullsupdateWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Pullsupdate(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescreateWithPrForAuthenticatedUser request with any body
	CodespacescreateWithPrForAuthenticatedUserWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacescreateWithPrForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body CodespacescreateWithPrForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistReviewComments request
	PullslistReviewComments(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullscreateReviewComment request with any body
	PullscreateReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullscreateReviewComment(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullscreateReplyForReviewComment request with any body
	PullscreateReplyForReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullscreateReplyForReviewComment(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, body PullscreateReplyForReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistCommits request
	PullslistCommits(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistFiles request
	PullslistFiles(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullscheckIfMerged request
	PullscheckIfMerged(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Pullsmerge request with any body
	PullsmergeWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Pullsmerge(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsremoveRequestedReviewers request with any body
	PullsremoveRequestedReviewersWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsremoveRequestedReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsremoveRequestedReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistRequestedReviewers request
	PullslistRequestedReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistRequestedReviewersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsrequestReviewers request with any body
	PullsrequestReviewersWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsrequestReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsrequestReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistReviews request
	PullslistReviews(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullscreateReview request with any body
	PullscreateReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullscreateReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsdeletePendingReview request
	PullsdeletePendingReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsgetReview request
	PullsgetReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsupdateReview request with any body
	PullsupdateReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsupdateReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsupdateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullslistCommentsForReview request
	PullslistCommentsForReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, params *PullslistCommentsForReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsdismissReview request with any body
	PullsdismissReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsdismissReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsdismissReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullssubmitReview request with any body
	PullssubmitReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullssubmitReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullssubmitReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PullsupdateBranch request with any body
	PullsupdateBranchWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PullsupdateBranch(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetReadme request
	ReposgetReadme(ctx context.Context, owner Owner, repo Repo, params *ReposgetReadmeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetReadmeInDirectory request
	ReposgetReadmeInDirectory(ctx context.Context, owner Owner, repo Repo, dir string, params *ReposgetReadmeInDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistReleases request
	ReposlistReleases(ctx context.Context, owner Owner, repo Repo, params *ReposlistReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateRelease request with any body
	ReposcreateReleaseWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateRelease(ctx context.Context, owner Owner, repo Repo, body ReposcreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteReleaseAsset request
	ReposdeleteReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetReleaseAsset request
	ReposgetReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateReleaseAsset request with any body
	ReposupdateReleaseAssetWithBody(ctx context.Context, owner Owner, repo Repo, assetId AssetId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, body ReposupdateReleaseAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgenerateReleaseNotes request with any body
	ReposgenerateReleaseNotesWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposgenerateReleaseNotes(ctx context.Context, owner Owner, repo Repo, body ReposgenerateReleaseNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetLatestRelease request
	ReposgetLatestRelease(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetReleaseByTag request
	ReposgetReleaseByTag(ctx context.Context, owner Owner, repo Repo, tag string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteRelease request
	ReposdeleteRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetRelease request
	ReposgetRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposupdateRelease request with any body
	ReposupdateReleaseWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposupdateRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReposupdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistReleaseAssets request
	ReposlistReleaseAssets(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposlistReleaseAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposuploadReleaseAsset request with any body
	ReposuploadReleaseAssetWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposuploadReleaseAssetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForRelease request
	ReactionslistForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReactionslistForReleaseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForRelease request with any body
	ReactionscreateForReleaseWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReactionscreateForReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionsdeleteForRelease request
	ReactionsdeleteForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanninglistAlertsForRepo request
	SecretScanninglistAlertsForRepo(ctx context.Context, owner Owner, repo Repo, params *SecretScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanninggetAlert request
	SecretScanninggetAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanningupdateAlert request with any body
	SecretScanningupdateAlertWithBody(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SecretScanningupdateAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body SecretScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SecretScanninglistLocationsForAlert request
	SecretScanninglistLocationsForAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *SecretScanninglistLocationsForAlertParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistStargazersForRepo request
	ActivitylistStargazersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActivitylistStargazersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCodeFrequencyStats request
	ReposgetCodeFrequencyStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetCommitActivityStats request
	ReposgetCommitActivityStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetContributorsStats request
	ReposgetContributorsStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetParticipationStats request
	ReposgetParticipationStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetPunchCardStats request
	ReposgetPunchCardStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateCommitStatus request with any body
	ReposcreateCommitStatusWithBody(ctx context.Context, owner Owner, repo Repo, sha string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateCommitStatus(ctx context.Context, owner Owner, repo Repo, sha string, body ReposcreateCommitStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistWatchersForRepo request
	ActivitylistWatchersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActivitylistWatchersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitydeleteRepoSubscription request
	ActivitydeleteRepoSubscription(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitygetRepoSubscription request
	ActivitygetRepoSubscription(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitysetRepoSubscription request with any body
	ActivitysetRepoSubscriptionWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActivitysetRepoSubscription(ctx context.Context, owner Owner, repo Repo, body ActivitysetRepoSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistTags request
	ReposlistTags(ctx context.Context, owner Owner, repo Repo, params *ReposlistTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistTagProtection request
	ReposlistTagProtection(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateTagProtection request with any body
	ReposcreateTagProtectionWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateTagProtection(ctx context.Context, owner Owner, repo Repo, body ReposcreateTagProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeleteTagProtection request
	ReposdeleteTagProtection(ctx context.Context, owner Owner, repo Repo, tagProtectionId TagProtectionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdownloadTarballArchive request
	ReposdownloadTarballArchive(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistTeams request
	ReposlistTeams(ctx context.Context, owner Owner, repo Repo, params *ReposlistTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetAllTopics request
	ReposgetAllTopics(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposreplaceAllTopics request with any body
	ReposreplaceAllTopicsWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposreplaceAllTopics(ctx context.Context, owner Owner, repo Repo, body ReposreplaceAllTopicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetClones request
	ReposgetClones(ctx context.Context, owner Owner, repo Repo, params *ReposgetClonesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetTopPaths request
	ReposgetTopPaths(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetTopReferrers request
	ReposgetTopReferrers(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposgetViews request
	ReposgetViews(ctx context.Context, owner Owner, repo Repo, params *ReposgetViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Repostransfer request with any body
	RepostransferWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Repostransfer(ctx context.Context, owner Owner, repo Repo, body RepostransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdisableVulnerabilityAlerts request
	ReposdisableVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcheckVulnerabilityAlerts request
	ReposcheckVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposenableVulnerabilityAlerts request
	ReposenableVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdownloadZipballArchive request
	ReposdownloadZipballArchive(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateUsingTemplate request with any body
	ReposcreateUsingTemplateWithBody(ctx context.Context, templateOwner string, templateRepo string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateUsingTemplate(ctx context.Context, templateOwner string, templateRepo string, body ReposcreateUsingTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistPublic request
	ReposlistPublic(ctx context.Context, params *ReposlistPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionslistEnvironmentSecrets request
	ActionslistEnvironmentSecrets(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, params *ActionslistEnvironmentSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetEnvironmentPublicKey request
	ActionsgetEnvironmentPublicKey(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsdeleteEnvironmentSecret request
	ActionsdeleteEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionsgetEnvironmentSecret request
	ActionsgetEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActionscreateOrUpdateEnvironmentSecret request with any body
	ActionscreateOrUpdateEnvironmentSecretWithBody(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ActionscreateOrUpdateEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, body ActionscreateOrUpdateEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistProvisionedGroupsEnterprise request
	EnterpriseAdminlistProvisionedGroupsEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedGroupsEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminprovisionAndInviteEnterpriseGroup request with any body
	EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminprovisionAndInviteEnterpriseGroup(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmindeleteScimGroupFromEnterprise request
	EnterpriseAdmindeleteScimGroupFromEnterprise(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetProvisioningInformationForEnterpriseGroup request
	EnterpriseAdmingetProvisioningInformationForEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, params *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminupdateAttributeForEnterpriseGroup request with any body
	EnterpriseAdminupdateAttributeForEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminupdateAttributeForEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminupdateAttributeForEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetInformationForProvisionedEnterpriseGroup request with any body
	EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetInformationForProvisionedEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminsetInformationForProvisionedEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminlistProvisionedIdentitiesEnterprise request
	EnterpriseAdminlistProvisionedIdentitiesEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedIdentitiesEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminprovisionAndInviteEnterpriseUser request with any body
	EnterpriseAdminprovisionAndInviteEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminprovisionAndInviteEnterpriseUser(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmindeleteUserFromEnterprise request
	EnterpriseAdmindeleteUserFromEnterprise(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdmingetProvisioningInformationForEnterpriseUser request
	EnterpriseAdmingetProvisioningInformationForEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminupdateAttributeForEnterpriseUser request with any body
	EnterpriseAdminupdateAttributeForEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminupdateAttributeForEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminupdateAttributeForEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnterpriseAdminsetInformationForProvisionedEnterpriseUser request with any body
	EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnterpriseAdminsetInformationForProvisionedEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminsetInformationForProvisionedEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimlistProvisionedIdentities request
	ScimlistProvisionedIdentities(ctx context.Context, org Org, params *ScimlistProvisionedIdentitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimprovisionAndInviteUser request with any body
	ScimprovisionAndInviteUserWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScimprovisionAndInviteUser(ctx context.Context, org Org, body ScimprovisionAndInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimdeleteUserFromOrg request
	ScimdeleteUserFromOrg(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimgetProvisioningInformationForUser request
	ScimgetProvisioningInformationForUser(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimupdateAttributeForUser request with any body
	ScimupdateAttributeForUserWithBody(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScimupdateAttributeForUser(ctx context.Context, org Org, scimUserId ScimUserId, body ScimupdateAttributeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScimsetInformationForProvisionedUser request with any body
	ScimsetInformationForProvisionedUserWithBody(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScimsetInformationForProvisionedUser(ctx context.Context, org Org, scimUserId ScimUserId, body ScimsetInformationForProvisionedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchcode request
	Searchcode(ctx context.Context, params *SearchcodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchcommits request
	Searchcommits(ctx context.Context, params *SearchcommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchissuesAndPullRequests request
	SearchissuesAndPullRequests(ctx context.Context, params *SearchissuesAndPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchlabels request
	Searchlabels(ctx context.Context, params *SearchlabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchrepos request
	Searchrepos(ctx context.Context, params *SearchreposParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchtopics request
	Searchtopics(ctx context.Context, params *SearchtopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Searchusers request
	Searchusers(ctx context.Context, params *SearchusersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteLegacy request
	TeamsdeleteLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetLegacy request
	TeamsgetLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateLegacy request with any body
	TeamsupdateLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateLegacy(ctx context.Context, teamId TeamId, body TeamsupdateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistDiscussionsLegacy request
	TeamslistDiscussionsLegacy(ctx context.Context, teamId TeamId, params *TeamslistDiscussionsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateDiscussionLegacy request with any body
	TeamscreateDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateDiscussionLegacy(ctx context.Context, teamId TeamId, body TeamscreateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteDiscussionLegacy request
	TeamsdeleteDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetDiscussionLegacy request
	TeamsgetDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateDiscussionLegacy request with any body
	TeamsupdateDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamsupdateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistDiscussionCommentsLegacy request
	TeamslistDiscussionCommentsLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateDiscussionCommentLegacy request with any body
	TeamscreateDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsdeleteDiscussionCommentLegacy request
	TeamsdeleteDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetDiscussionCommentLegacy request
	TeamsgetDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsupdateDiscussionCommentLegacy request with any body
	TeamsupdateDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsupdateDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForTeamDiscussionCommentLegacy request
	ReactionslistForTeamDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForTeamDiscussionCommentLegacy request with any body
	ReactionscreateForTeamDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForTeamDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionslistForTeamDiscussionLegacy request
	ReactionslistForTeamDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReactionscreateForTeamDiscussionLegacy request with any body
	ReactionscreateForTeamDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReactionscreateForTeamDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistPendingInvitationsLegacy request
	TeamslistPendingInvitationsLegacy(ctx context.Context, teamId TeamId, params *TeamslistPendingInvitationsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistMembersLegacy request
	TeamslistMembersLegacy(ctx context.Context, teamId TeamId, params *TeamslistMembersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveMemberLegacy request
	TeamsremoveMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetMemberLegacy request
	TeamsgetMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddMemberLegacy request
	TeamsaddMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveMembershipForUserLegacy request
	TeamsremoveMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsgetMembershipForUserLegacy request
	TeamsgetMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateMembershipForUserLegacy request with any body
	TeamsaddOrUpdateMembershipForUserLegacyWithBody(ctx context.Context, teamId TeamId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, body TeamsaddOrUpdateMembershipForUserLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistProjectsLegacy request
	TeamslistProjectsLegacy(ctx context.Context, teamId TeamId, params *TeamslistProjectsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveProjectLegacy request
	TeamsremoveProjectLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscheckPermissionsForProjectLegacy request
	TeamscheckPermissionsForProjectLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateProjectPermissionsLegacy request with any body
	TeamsaddOrUpdateProjectPermissionsLegacyWithBody(ctx context.Context, teamId TeamId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateProjectPermissionsLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistReposLegacy request
	TeamslistReposLegacy(ctx context.Context, teamId TeamId, params *TeamslistReposLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsremoveRepoLegacy request
	TeamsremoveRepoLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscheckPermissionsForRepoLegacy request
	TeamscheckPermissionsForRepoLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamsaddOrUpdateRepoPermissionsLegacy request with any body
	TeamsaddOrUpdateRepoPermissionsLegacyWithBody(ctx context.Context, teamId TeamId, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamsaddOrUpdateRepoPermissionsLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistIdpGroupsForLegacy request
	TeamslistIdpGroupsForLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamscreateOrUpdateIdpGroupConnectionsLegacy request with any body
	TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TeamscreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, teamId TeamId, body TeamscreateOrUpdateIdpGroupConnectionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistChildLegacy request
	TeamslistChildLegacy(ctx context.Context, teamId TeamId, params *TeamslistChildLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersgetAuthenticated request
	UsersgetAuthenticated(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersupdateAuthenticated request with any body
	UsersupdateAuthenticatedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersupdateAuthenticated(ctx context.Context, body UsersupdateAuthenticatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistBlockedByAuthenticatedUser request
	UserslistBlockedByAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usersunblock request
	Usersunblock(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserscheckBlocked request
	UserscheckBlocked(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usersblock request
	Usersblock(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistForAuthenticatedUser request
	CodespaceslistForAuthenticatedUser(ctx context.Context, params *CodespaceslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescreateForAuthenticatedUser request with any body
	CodespacescreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacescreateForAuthenticatedUser(ctx context.Context, body CodespacescreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistSecretsForAuthenticatedUser request
	CodespaceslistSecretsForAuthenticatedUser(ctx context.Context, params *CodespaceslistSecretsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetPublicKeyForAuthenticatedUser request
	CodespacesgetPublicKeyForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesdeleteSecretForAuthenticatedUser request
	CodespacesdeleteSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetSecretForAuthenticatedUser request
	CodespacesgetSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescreateOrUpdateSecretForAuthenticatedUser request with any body
	CodespacescreateOrUpdateSecretForAuthenticatedUserWithBody(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacescreateOrUpdateSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, body CodespacescreateOrUpdateSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespaceslistRepositoriesForSecretForAuthenticatedUser request
	CodespaceslistRepositoriesForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacessetRepositoriesForSecretForAuthenticatedUser request with any body
	CodespacessetRepositoriesForSecretForAuthenticatedUserWithBody(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacessetRepositoriesForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, body CodespacessetRepositoriesForSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesremoveRepositoryForSecretForAuthenticatedUser request
	CodespacesremoveRepositoryForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesaddRepositoryForSecretForAuthenticatedUser request
	CodespacesaddRepositoryForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesdeleteForAuthenticatedUser request
	CodespacesdeleteForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetForAuthenticatedUser request
	CodespacesgetForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesupdateForAuthenticatedUser request with any body
	CodespacesupdateForAuthenticatedUserWithBody(ctx context.Context, codespaceName CodespaceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CodespacesupdateForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, body CodespacesupdateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesexportForAuthenticatedUser request
	CodespacesexportForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesgetExportDetailsForAuthenticatedUser request
	CodespacesgetExportDetailsForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, exportId ExportId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacescodespaceMachinesForAuthenticatedUser request
	CodespacescodespaceMachinesForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesstartForAuthenticatedUser request
	CodespacesstartForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CodespacesstopForAuthenticatedUser request
	CodespacesstopForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserssetPrimaryEmailVisibilityForAuthenticatedUser request with any body
	UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserssetPrimaryEmailVisibilityForAuthenticatedUser(ctx context.Context, body UserssetPrimaryEmailVisibilityForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersdeleteEmailForAuthenticatedUser request with any body
	UsersdeleteEmailForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersdeleteEmailForAuthenticatedUser(ctx context.Context, body UsersdeleteEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistEmailsForAuthenticatedUser request
	UserslistEmailsForAuthenticatedUser(ctx context.Context, params *UserslistEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersaddEmailForAuthenticatedUser request with any body
	UsersaddEmailForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UsersaddEmailForAuthenticatedUser(ctx context.Context, body UsersaddEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistFollowersForAuthenticatedUser request
	UserslistFollowersForAuthenticatedUser(ctx context.Context, params *UserslistFollowersForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistFollowedByAuthenticatedUser request
	UserslistFollowedByAuthenticatedUser(ctx context.Context, params *UserslistFollowedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usersunfollow request
	Usersunfollow(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserscheckPersonIsFollowedByAuthenticated request
	UserscheckPersonIsFollowedByAuthenticated(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Usersfollow request
	Usersfollow(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistGpgKeysForAuthenticatedUser request
	UserslistGpgKeysForAuthenticatedUser(ctx context.Context, params *UserslistGpgKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserscreateGpgKeyForAuthenticatedUser request with any body
	UserscreateGpgKeyForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserscreateGpgKeyForAuthenticatedUser(ctx context.Context, body UserscreateGpgKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersdeleteGpgKeyForAuthenticatedUser request
	UsersdeleteGpgKeyForAuthenticatedUser(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersgetGpgKeyForAuthenticatedUser request
	UsersgetGpgKeyForAuthenticatedUser(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistInstallationsForAuthenticatedUser request
	AppslistInstallationsForAuthenticatedUser(ctx context.Context, params *AppslistInstallationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistInstallationReposForAuthenticatedUser request
	AppslistInstallationReposForAuthenticatedUser(ctx context.Context, installationId InstallationId, params *AppslistInstallationReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsremoveRepoFromInstallationForAuthenticatedUser request
	AppsremoveRepoFromInstallationForAuthenticatedUser(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsaddRepoToInstallationForAuthenticatedUser request
	AppsaddRepoToInstallationForAuthenticatedUser(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsremoveRestrictionsForAuthenticatedUser request
	InteractionsremoveRestrictionsForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionsgetRestrictionsForAuthenticatedUser request
	InteractionsgetRestrictionsForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InteractionssetRestrictionsForAuthenticatedUser request with any body
	InteractionssetRestrictionsForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InteractionssetRestrictionsForAuthenticatedUser(ctx context.Context, body InteractionssetRestrictionsForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IssueslistForAuthenticatedUser request
	IssueslistForAuthenticatedUser(ctx context.Context, params *IssueslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistPublicSshKeysForAuthenticatedUser request
	UserslistPublicSshKeysForAuthenticatedUser(ctx context.Context, params *UserslistPublicSshKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserscreatePublicSshKeyForAuthenticatedUser request with any body
	UserscreatePublicSshKeyForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserscreatePublicSshKeyForAuthenticatedUser(ctx context.Context, body UserscreatePublicSshKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersdeletePublicSshKeyForAuthenticatedUser request
	UsersdeletePublicSshKeyForAuthenticatedUser(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersgetPublicSshKeyForAuthenticatedUser request
	UsersgetPublicSshKeyForAuthenticatedUser(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistSubscriptionsForAuthenticatedUser request
	AppslistSubscriptionsForAuthenticatedUser(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppslistSubscriptionsForAuthenticatedUserStubbed request
	AppslistSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistMembershipsForAuthenticatedUser request
	OrgslistMembershipsForAuthenticatedUser(ctx context.Context, params *OrgslistMembershipsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsgetMembershipForAuthenticatedUser request
	OrgsgetMembershipForAuthenticatedUser(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgsupdateMembershipForAuthenticatedUser request with any body
	OrgsupdateMembershipForAuthenticatedUserWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	OrgsupdateMembershipForAuthenticatedUser(ctx context.Context, org Org, body OrgsupdateMembershipForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationslistForAuthenticatedUser request
	MigrationslistForAuthenticatedUser(ctx context.Context, params *MigrationslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsstartForAuthenticatedUser request with any body
	MigrationsstartForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MigrationsstartForAuthenticatedUser(ctx context.Context, body MigrationsstartForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetStatusForAuthenticatedUser request
	MigrationsgetStatusForAuthenticatedUser(ctx context.Context, migrationId MigrationId, params *MigrationsgetStatusForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsdeleteArchiveForAuthenticatedUser request
	MigrationsdeleteArchiveForAuthenticatedUser(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsgetArchiveForAuthenticatedUser request
	MigrationsgetArchiveForAuthenticatedUser(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationsunlockRepoForAuthenticatedUser request
	MigrationsunlockRepoForAuthenticatedUser(ctx context.Context, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MigrationslistReposForAuthenticatedUser request
	MigrationslistReposForAuthenticatedUser(ctx context.Context, migrationId MigrationId, params *MigrationslistReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistForAuthenticatedUser request
	OrgslistForAuthenticatedUser(ctx context.Context, params *OrgslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackageslistPackagesForAuthenticatedUser request
	PackageslistPackagesForAuthenticatedUser(ctx context.Context, params *PackageslistPackagesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageForAuthenticatedUser request
	PackagesdeletePackageForAuthenticatedUser(ctx context.Context, packageType PackagesdeletePackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageForAuthenticatedUser request
	PackagesgetPackageForAuthenticatedUser(ctx context.Context, packageType PackagesgetPackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageForAuthenticatedUser request
	PackagesrestorePackageForAuthenticatedUser(ctx context.Context, packageType PackagesrestorePackageForAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser request
	PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, packageType PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageVersionForAuthenticatedUser request
	PackagesdeletePackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesdeletePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageVersionForAuthenticatedUser request
	PackagesgetPackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesgetPackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageVersionForAuthenticatedUser request
	PackagesrestorePackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesrestorePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectscreateForAuthenticatedUser request with any body
	ProjectscreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ProjectscreateForAuthenticatedUser(ctx context.Context, body ProjectscreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistPublicEmailsForAuthenticatedUser request
	UserslistPublicEmailsForAuthenticatedUser(ctx context.Context, params *UserslistPublicEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistForAuthenticatedUser request
	ReposlistForAuthenticatedUser(ctx context.Context, params *ReposlistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposcreateForAuthenticatedUser request with any body
	ReposcreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReposcreateForAuthenticatedUser(ctx context.Context, body ReposcreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistInvitationsForAuthenticatedUser request
	ReposlistInvitationsForAuthenticatedUser(ctx context.Context, params *ReposlistInvitationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposdeclineInvitationForAuthenticatedUser request
	ReposdeclineInvitationForAuthenticatedUser(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposacceptInvitationForAuthenticatedUser request
	ReposacceptInvitationForAuthenticatedUser(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistReposStarredByAuthenticatedUser request
	ActivitylistReposStarredByAuthenticatedUser(ctx context.Context, params *ActivitylistReposStarredByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivityunstarRepoForAuthenticatedUser request
	ActivityunstarRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitycheckRepoIsStarredByAuthenticatedUser request
	ActivitycheckRepoIsStarredByAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitystarRepoForAuthenticatedUser request
	ActivitystarRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistWatchedReposForAuthenticatedUser request
	ActivitylistWatchedReposForAuthenticatedUser(ctx context.Context, params *ActivitylistWatchedReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TeamslistForAuthenticatedUser request
	TeamslistForAuthenticatedUser(ctx context.Context, params *TeamslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Userslist request
	Userslist(ctx context.Context, params *UserslistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersgetByUsername request
	UsersgetByUsername(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistEventsForAuthenticatedUser request
	ActivitylistEventsForAuthenticatedUser(ctx context.Context, username Username, params *ActivitylistEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistOrgEventsForAuthenticatedUser request
	ActivitylistOrgEventsForAuthenticatedUser(ctx context.Context, username Username, org Org, params *ActivitylistOrgEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistPublicEventsForUser request
	ActivitylistPublicEventsForUser(ctx context.Context, username Username, params *ActivitylistPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistFollowersForUser request
	UserslistFollowersForUser(ctx context.Context, username Username, params *UserslistFollowersForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistFollowingForUser request
	UserslistFollowingForUser(ctx context.Context, username Username, params *UserslistFollowingForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserscheckFollowingForUser request
	UserscheckFollowingForUser(ctx context.Context, username Username, targetUser string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GistslistForUser request
	GistslistForUser(ctx context.Context, username Username, params *GistslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistGpgKeysForUser request
	UserslistGpgKeysForUser(ctx context.Context, username Username, params *UserslistGpgKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UsersgetContextForUser request
	UsersgetContextForUser(ctx context.Context, username Username, params *UsersgetContextForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AppsgetUserInstallation request
	AppsgetUserInstallation(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserslistPublicKeysForUser request
	UserslistPublicKeysForUser(ctx context.Context, username Username, params *UserslistPublicKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// OrgslistForUser request
	OrgslistForUser(ctx context.Context, username Username, params *OrgslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackageslistPackagesForUser request
	PackageslistPackagesForUser(ctx context.Context, username Username, params *PackageslistPackagesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageForUser request
	PackagesdeletePackageForUser(ctx context.Context, username Username, packageType PackagesdeletePackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageForUser request
	PackagesgetPackageForUser(ctx context.Context, username Username, packageType PackagesgetPackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageForUser request
	PackagesrestorePackageForUser(ctx context.Context, username Username, packageType PackagesrestorePackageForUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByUser request
	PackagesgetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, username Username, packageType PackagesgetAllPackageVersionsForPackageOwnedByUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesdeletePackageVersionForUser request
	PackagesdeletePackageVersionForUser(ctx context.Context, username Username, packageType PackagesdeletePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesgetPackageVersionForUser request
	PackagesgetPackageVersionForUser(ctx context.Context, username Username, packageType PackagesgetPackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PackagesrestorePackageVersionForUser request
	PackagesrestorePackageVersionForUser(ctx context.Context, username Username, packageType PackagesrestorePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProjectslistForUser request
	ProjectslistForUser(ctx context.Context, username Username, params *ProjectslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistReceivedEventsForUser request
	ActivitylistReceivedEventsForUser(ctx context.Context, username Username, params *ActivitylistReceivedEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistReceivedPublicEventsForUser request
	ActivitylistReceivedPublicEventsForUser(ctx context.Context, username Username, params *ActivitylistReceivedPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReposlistForUser request
	ReposlistForUser(ctx context.Context, username Username, params *ReposlistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubActionsBillingUser request
	BillinggetGithubActionsBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetGithubPackagesBillingUser request
	BillinggetGithubPackagesBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BillinggetSharedStorageBillingUser request
	BillinggetSharedStorageBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistReposStarredByUser request
	ActivitylistReposStarredByUser(ctx context.Context, username Username, params *ActivitylistReposStarredByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ActivitylistReposWatchedByUser request
	ActivitylistReposWatchedByUser(ctx context.Context, username Username, params *ActivitylistReposWatchedByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MetagetZen request
	MetagetZen(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Metaroot(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetarootRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetAuthenticated(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetAuthenticatedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppscreateFromManifest(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppscreateFromManifestRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetWebhookConfigForApp(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetWebhookConfigForAppRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsupdateWebhookConfigForAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsupdateWebhookConfigForAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsupdateWebhookConfigForApp(ctx context.Context, body AppsupdateWebhookConfigForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsupdateWebhookConfigForAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistWebhookDeliveries(ctx context.Context, params *AppslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistWebhookDeliveriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetWebhookDelivery(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetWebhookDeliveryRequest(c.Server, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsredeliverWebhookDelivery(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsredeliverWebhookDeliveryRequest(c.Server, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistInstallations(ctx context.Context, params *AppslistInstallationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistInstallationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsdeleteInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsdeleteInstallationRequest(c.Server, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetInstallationRequest(c.Server, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppscreateInstallationAccessTokenWithBody(ctx context.Context, installationId InstallationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppscreateInstallationAccessTokenRequestWithBody(c.Server, installationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppscreateInstallationAccessToken(ctx context.Context, installationId InstallationId, body AppscreateInstallationAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppscreateInstallationAccessTokenRequest(c.Server, installationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsunsuspendInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsunsuspendInstallationRequest(c.Server, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppssuspendInstallation(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppssuspendInstallationRequest(c.Server, installationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationslistGrants(ctx context.Context, params *OauthAuthorizationslistGrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationslistGrantsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsdeleteGrant(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsdeleteGrantRequest(c.Server, grantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetGrant(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetGrantRequest(c.Server, grantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsdeleteAuthorizationWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsdeleteAuthorizationRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsdeleteAuthorization(ctx context.Context, clientId ClientId, body AppsdeleteAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsdeleteAuthorizationRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsdeleteTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsdeleteTokenRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsdeleteToken(ctx context.Context, clientId ClientId, body AppsdeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsdeleteTokenRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsresetTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsresetTokenRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsresetToken(ctx context.Context, clientId ClientId, body AppsresetTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsresetTokenRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppscheckTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppscheckTokenRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppscheckToken(ctx context.Context, clientId ClientId, body AppscheckTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppscheckTokenRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsscopeTokenWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsscopeTokenRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsscopeToken(ctx context.Context, clientId ClientId, body AppsscopeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsscopeTokenRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetBySlug(ctx context.Context, appSlug AppSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetBySlugRequest(c.Server, appSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationslistAuthorizations(ctx context.Context, params *OauthAuthorizationslistAuthorizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationslistAuthorizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationscreateAuthorizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationscreateAuthorizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationscreateAuthorization(ctx context.Context, body OauthAuthorizationscreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationscreateAuthorizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetOrCreateAuthorizationForAppWithBody(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequestWithBody(c.Server, clientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetOrCreateAuthorizationForApp(ctx context.Context, clientId ClientId, body OauthAuthorizationsgetOrCreateAuthorizationForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequest(c.Server, clientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBody(ctx context.Context, clientId ClientId, fingerprint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequestWithBody(c.Server, clientId, fingerprint, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint(ctx context.Context, clientId ClientId, fingerprint string, body OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequest(c.Server, clientId, fingerprint, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsdeleteAuthorization(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsdeleteAuthorizationRequest(c.Server, authorizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsgetAuthorization(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsgetAuthorizationRequest(c.Server, authorizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsupdateAuthorizationWithBody(ctx context.Context, authorizationId AuthorizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsupdateAuthorizationRequestWithBody(c.Server, authorizationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OauthAuthorizationsupdateAuthorization(ctx context.Context, authorizationId AuthorizationId, body OauthAuthorizationsupdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOauthAuthorizationsupdateAuthorizationRequest(c.Server, authorizationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodesOfConductgetAllCodesOfConduct(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodesOfConductgetAllCodesOfConductRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodesOfConductgetConductCode(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodesOfConductgetConductCodeRequest(c.Server, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Emojisget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmojisgetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetServerStatistics(ctx context.Context, enterpriseOrOrg EnterpriseOrOrg, params *EnterpriseAdmingetServerStatisticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetServerStatisticsRequest(c.Server, enterpriseOrOrg, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetActionsCacheUsageForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetActionsCacheUsageForEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetGithubActionsPermissionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetGithubActionsPermissionsEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetGithubActionsPermissionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetGithubActionsPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseRequest(c.Server, enterprise, orgId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseRequest(c.Server, enterprise, orgId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetAllowedActionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetAllowedActionsEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetAllowedActionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetAllowedActionsEnterpriseRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetAllowedActionsEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetAllowedActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetAllowedActionsEnterpriseRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx context.Context, enterprise Enterprise, body ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, body EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseRequest(c.Server, enterprise, runnerGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequestWithBody(c.Server, enterprise, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(c.Server, enterprise, runnerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestWithBody(c.Server, enterprise, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(c.Server, enterprise, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(c.Server, enterprise, runnerGroupId, orgId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(c.Server, enterprise, runnerGroupId, orgId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequestWithBody(c.Server, enterprise, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseRequest(c.Server, enterprise, runnerGroupId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistSelfHostedRunnersForEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnersForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistSelfHostedRunnersForEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistRunnerApplicationsForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistRunnerApplicationsForEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmincreateRegistrationTokenForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmincreateRegistrationTokenForEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmincreateRemoveTokenForEnterprise(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmincreateRemoveTokenForEnterpriseRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseRequest(c.Server, enterprise, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequestWithBody(c.Server, enterprise, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBody(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequestWithBody(c.Server, enterprise, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise(ctx context.Context, enterprise Enterprise, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest(c.Server, enterprise, runnerId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetAuditLog(ctx context.Context, enterprise Enterprise, params *EnterpriseAdmingetAuditLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetAuditLogRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanninglistAlertsForEnterprise(ctx context.Context, enterprise Enterprise, params *SecretScanninglistAlertsForEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanninglistAlertsForEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubActionsBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubActionsBillingGheRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubAdvancedSecurityBillingGhe(ctx context.Context, enterprise Enterprise, params *BillinggetGithubAdvancedSecurityBillingGheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubAdvancedSecurityBillingGheRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubPackagesBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubPackagesBillingGheRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetSharedStorageBillingGhe(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetSharedStorageBillingGheRequest(c.Server, enterprise)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistPublicEvents(ctx context.Context, params *ActivitylistPublicEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistPublicEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitygetFeeds(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitygetFeedsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistslist(ctx context.Context, params *GistslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistscreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistscreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistscreate(ctx context.Context, body GistscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistscreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistPublic(ctx context.Context, params *GistslistPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistPublicRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistStarred(ctx context.Context, params *GistslistStarredParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistStarredRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsdelete(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsdeleteRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsget(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsgetRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsupdateWithBody(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsupdateRequestWithBody(c.Server, gistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsupdate(ctx context.Context, gistId GistId, body GistsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsupdateRequest(c.Server, gistId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistComments(ctx context.Context, gistId GistId, params *GistslistCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistCommentsRequest(c.Server, gistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistscreateCommentWithBody(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistscreateCommentRequestWithBody(c.Server, gistId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistscreateComment(ctx context.Context, gistId GistId, body GistscreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistscreateCommentRequest(c.Server, gistId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsdeleteComment(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsdeleteCommentRequest(c.Server, gistId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsgetComment(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsgetCommentRequest(c.Server, gistId, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsupdateCommentWithBody(ctx context.Context, gistId GistId, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsupdateCommentRequestWithBody(c.Server, gistId, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsupdateComment(ctx context.Context, gistId GistId, commentId CommentId, body GistsupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsupdateCommentRequest(c.Server, gistId, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistCommits(ctx context.Context, gistId GistId, params *GistslistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistCommitsRequest(c.Server, gistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistForks(ctx context.Context, gistId GistId, params *GistslistForksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistForksRequest(c.Server, gistId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsfork(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsforkRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsunstar(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsunstarRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistscheckIsStarred(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistscheckIsStarredRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Gistsstar(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsstarRequest(c.Server, gistId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistsgetRevision(ctx context.Context, gistId GistId, sha string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistsgetRevisionRequest(c.Server, gistId, sha)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitignoregetAllTemplates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitignoregetAllTemplatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitignoregetTemplate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitignoregetTemplateRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistReposAccessibleToInstallation(ctx context.Context, params *AppslistReposAccessibleToInstallationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistReposAccessibleToInstallationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsrevokeInstallationAccessToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsrevokeInstallationAccessTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issueslist(ctx context.Context, params *IssueslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LicensesgetAllCommonlyUsed(ctx context.Context, params *LicensesgetAllCommonlyUsedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLicensesgetAllCommonlyUsedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Licensesget(ctx context.Context, license string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLicensesgetRequest(c.Server, license)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkdownrenderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkdownrenderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Markdownrender(ctx context.Context, body MarkdownrenderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkdownrenderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MarkdownrenderRawWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMarkdownrenderRawRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetSubscriptionPlanForAccount(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetSubscriptionPlanForAccountRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistPlans(ctx context.Context, params *AppslistPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistAccountsForPlan(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistAccountsForPlanRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetSubscriptionPlanForAccountStubbed(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetSubscriptionPlanForAccountStubbedRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistPlansStubbed(ctx context.Context, params *AppslistPlansStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistPlansStubbedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistAccountsForPlanStubbed(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistAccountsForPlanStubbedRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Metaget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetagetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistPublicEventsForRepoNetwork(ctx context.Context, owner Owner, repo Repo, params *ActivitylistPublicEventsForRepoNetworkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistPublicEventsForRepoNetworkRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistNotificationsForAuthenticatedUser(ctx context.Context, params *ActivitylistNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistNotificationsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitymarkNotificationsAsReadWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitymarkNotificationsAsReadRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitymarkNotificationsAsRead(ctx context.Context, body ActivitymarkNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitymarkNotificationsAsReadRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitygetThread(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitygetThreadRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitymarkThreadAsRead(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitymarkThreadAsReadRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitydeleteThreadSubscription(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitydeleteThreadSubscriptionRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitygetThreadSubscriptionForAuthenticatedUser(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitygetThreadSubscriptionForAuthenticatedUserRequest(c.Server, threadId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitysetThreadSubscriptionWithBody(ctx context.Context, threadId ThreadId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitysetThreadSubscriptionRequestWithBody(c.Server, threadId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitysetThreadSubscription(ctx context.Context, threadId ThreadId, body ActivitysetThreadSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitysetThreadSubscriptionRequest(c.Server, threadId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetagetOctocat(ctx context.Context, params *MetagetOctocatParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetagetOctocatRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Orgslist(ctx context.Context, params *OrgslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistCustomRoles(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistCustomRolesRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Orgsget(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Orgsupdate(ctx context.Context, org Org, body OrgsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetActionsCacheUsageForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetActionsCacheUsageForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetActionsCacheUsageByRepoForOrg(ctx context.Context, org Org, params *ActionsgetActionsCacheUsageByRepoForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetActionsCacheUsageByRepoForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetGithubActionsPermissionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetGithubActionsPermissionsOrganizationRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsPermissionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsPermissionsOrganizationRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsPermissionsOrganization(ctx context.Context, org Org, body ActionssetGithubActionsPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsPermissionsOrganizationRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org Org, params *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelectedRepositoriesEnabledGithubActionsOrganizationRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelectedRepositoriesEnabledGithubActionsOrganization(ctx context.Context, org Org, body ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdisableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdisableSelectedRepositoryGithubActionsOrganizationRequest(c.Server, org, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsenableSelectedRepositoryGithubActionsOrganization(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsenableSelectedRepositoryGithubActionsOrganizationRequest(c.Server, org, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetAllowedActionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetAllowedActionsOrganizationRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetAllowedActionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetAllowedActionsOrganizationRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetAllowedActionsOrganization(ctx context.Context, org Org, body ActionssetAllowedActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetAllowedActionsOrganizationRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsOrganization(ctx context.Context, org Org, body ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelfHostedRunnerGroupsForOrg(ctx context.Context, org Org, params *ActionslistSelfHostedRunnerGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelfHostedRunnerGroupsForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateSelfHostedRunnerGroupForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateSelfHostedRunnerGroupForOrgRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, body ActionscreateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateSelfHostedRunnerGroupForOrgRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteSelfHostedRunnerGroupFromOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteSelfHostedRunnerGroupFromOrgRequest(c.Server, org, runnerGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetSelfHostedRunnerGroupForOrgRequest(c.Server, org, runnerGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsupdateSelfHostedRunnerGroupForOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsupdateSelfHostedRunnerGroupForOrgRequestWithBody(c.Server, org, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsupdateSelfHostedRunnerGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionsupdateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsupdateSelfHostedRunnerGroupForOrgRequest(c.Server, org, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistRepoAccessToSelfHostedRunnerGroupInOrgRequest(c.Server, org, runnerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequestWithBody(c.Server, org, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetRepoAccessToSelfHostedRunnerGroupInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequest(c.Server, org, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(c.Server, org, runnerGroupId, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddRepoAccessToSelfHostedRunnerGroupInOrgRequest(c.Server, org, runnerGroupId, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelfHostedRunnersInGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistSelfHostedRunnersInGroupForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelfHostedRunnersInGroupForOrgRequest(c.Server, org, runnerGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelfHostedRunnersInGroupForOrgWithBody(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelfHostedRunnersInGroupForOrgRequestWithBody(c.Server, org, runnerGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelfHostedRunnersInGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetSelfHostedRunnersInGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelfHostedRunnersInGroupForOrgRequest(c.Server, org, runnerGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveSelfHostedRunnerFromGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveSelfHostedRunnerFromGroupForOrgRequest(c.Server, org, runnerGroupId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddSelfHostedRunnerToGroupForOrg(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddSelfHostedRunnerToGroupForOrgRequest(c.Server, org, runnerGroupId, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelfHostedRunnersForOrg(ctx context.Context, org Org, params *ActionslistSelfHostedRunnersForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelfHostedRunnersForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistRunnerApplicationsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistRunnerApplicationsForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateRegistrationTokenForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateRegistrationTokenForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateRemoveTokenForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateRemoveTokenForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteSelfHostedRunnerFromOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteSelfHostedRunnerFromOrgRequest(c.Server, org, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetSelfHostedRunnerForOrgRequest(c.Server, org, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest(c.Server, org, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistLabelsForSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistLabelsForSelfHostedRunnerForOrgRequest(c.Server, org, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBody(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequestWithBody(c.Server, org, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddCustomLabelsToSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequest(c.Server, org, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBody(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequestWithBody(c.Server, org, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetCustomLabelsForSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequest(c.Server, org, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveCustomLabelFromSelfHostedRunnerForOrg(ctx context.Context, org Org, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveCustomLabelFromSelfHostedRunnerForOrgRequest(c.Server, org, runnerId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistOrgSecrets(ctx context.Context, org Org, params *ActionslistOrgSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistOrgSecretsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetOrgPublicKey(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetOrgPublicKeyRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteOrgSecretRequest(c.Server, org, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetOrgSecretRequest(c.Server, org, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateOrgSecretRequestWithBody(c.Server, org, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateOrgSecret(ctx context.Context, org Org, secretName SecretName, body ActionscreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateOrgSecretRequest(c.Server, org, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, params *ActionslistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelectedReposForOrgSecretRequest(c.Server, org, secretName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelectedReposForOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelectedReposForOrgSecretRequestWithBody(c.Server, org, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, body ActionssetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetSelectedReposForOrgSecretRequest(c.Server, org, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveSelectedRepoFromOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveSelectedRepoFromOrgSecretRequest(c.Server, org, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddSelectedRepoToOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddSelectedRepoToOrgSecretRequest(c.Server, org, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetAuditLog(ctx context.Context, org Org, params *OrgsgetAuditLogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetAuditLogRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistBlockedUsers(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistBlockedUsersRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsunblockUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsunblockUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscheckBlockedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscheckBlockedUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsblockUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsblockUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninglistAlertsForOrg(ctx context.Context, org Org, params *CodeScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninglistAlertsForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistSamlSsoAuthorizations(ctx context.Context, org Org, params *OrgslistSamlSsoAuthorizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistSamlSsoAuthorizationsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsremoveSamlSsoAuthorization(ctx context.Context, org Org, credentialId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsremoveSamlSsoAuthorizationRequest(c.Server, org, credentialId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotlistOrgSecrets(ctx context.Context, org Org, params *DependabotlistOrgSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotlistOrgSecretsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotgetOrgPublicKey(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotgetOrgPublicKeyRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotdeleteOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotdeleteOrgSecretRequest(c.Server, org, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotgetOrgSecret(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotgetOrgSecretRequest(c.Server, org, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotcreateOrUpdateOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotcreateOrUpdateOrgSecretRequestWithBody(c.Server, org, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotcreateOrUpdateOrgSecret(ctx context.Context, org Org, secretName SecretName, body DependabotcreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotcreateOrUpdateOrgSecretRequest(c.Server, org, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotlistSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, params *DependabotlistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotlistSelectedReposForOrgSecretRequest(c.Server, org, secretName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotsetSelectedReposForOrgSecretWithBody(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotsetSelectedReposForOrgSecretRequestWithBody(c.Server, org, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotsetSelectedReposForOrgSecret(ctx context.Context, org Org, secretName SecretName, body DependabotsetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotsetSelectedReposForOrgSecretRequest(c.Server, org, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotremoveSelectedRepoFromOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotremoveSelectedRepoFromOrgSecretRequest(c.Server, org, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotaddSelectedRepoToOrgSecret(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotaddSelectedRepoToOrgSecretRequest(c.Server, org, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistPublicOrgEvents(ctx context.Context, org Org, params *ActivitylistPublicOrgEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistPublicOrgEventsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsexternalIdpGroupInfoForOrg(ctx context.Context, org Org, groupId GroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsexternalIdpGroupInfoForOrgRequest(c.Server, org, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistExternalIdpGroupsForOrg(ctx context.Context, org Org, params *TeamslistExternalIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistExternalIdpGroupsForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistFailedInvitations(ctx context.Context, org Org, params *OrgslistFailedInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistFailedInvitationsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistWebhooks(ctx context.Context, org Org, params *OrgslistWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistWebhooksRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscreateWebhookWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscreateWebhookRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscreateWebhook(ctx context.Context, org Org, body OrgscreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscreateWebhookRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsdeleteWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsdeleteWebhookRequest(c.Server, org, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetWebhookRequest(c.Server, org, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateWebhookWithBody(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateWebhookRequestWithBody(c.Server, org, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateWebhook(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateWebhookRequest(c.Server, org, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetWebhookConfigForOrg(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetWebhookConfigForOrgRequest(c.Server, org, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateWebhookConfigForOrgWithBody(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateWebhookConfigForOrgRequestWithBody(c.Server, org, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateWebhookConfigForOrg(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookConfigForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateWebhookConfigForOrgRequest(c.Server, org, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistWebhookDeliveries(ctx context.Context, org Org, hookId HookId, params *OrgslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistWebhookDeliveriesRequest(c.Server, org, hookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetWebhookDelivery(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetWebhookDeliveryRequest(c.Server, org, hookId, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsredeliverWebhookDelivery(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsredeliverWebhookDeliveryRequest(c.Server, org, hookId, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgspingWebhook(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgspingWebhookRequest(c.Server, org, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetOrgInstallation(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetOrgInstallationRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistAppInstallations(ctx context.Context, org Org, params *OrgslistAppInstallationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistAppInstallationsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsremoveRestrictionsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsremoveRestrictionsForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsgetRestrictionsForOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsgetRestrictionsForOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForOrgRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForOrg(ctx context.Context, org Org, body InteractionssetRestrictionsForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForOrgRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistPendingInvitations(ctx context.Context, org Org, params *OrgslistPendingInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistPendingInvitationsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscreateInvitationWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscreateInvitationRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscreateInvitation(ctx context.Context, org Org, body OrgscreateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscreateInvitationRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscancelInvitation(ctx context.Context, org Org, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscancelInvitationRequest(c.Server, org, invitationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistInvitationTeams(ctx context.Context, org Org, invitationId InvitationId, params *OrgslistInvitationTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistInvitationTeamsRequest(c.Server, org, invitationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistForOrg(ctx context.Context, org Org, params *IssueslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistMembers(ctx context.Context, org Org, params *OrgslistMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistMembersRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsremoveMember(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsremoveMemberRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscheckMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscheckMembershipForUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsremoveMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsremoveMembershipForUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetMembershipForUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgssetMembershipForUserWithBody(ctx context.Context, org Org, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgssetMembershipForUserRequestWithBody(c.Server, org, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgssetMembershipForUser(ctx context.Context, org Org, username Username, body OrgssetMembershipForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgssetMembershipForUserRequest(c.Server, org, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationslistForOrg(ctx context.Context, org Org, params *MigrationslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationslistForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartForOrgRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartForOrg(ctx context.Context, org Org, body MigrationsstartForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartForOrgRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetStatusForOrg(ctx context.Context, org Org, migrationId MigrationId, params *MigrationsgetStatusForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetStatusForOrgRequest(c.Server, org, migrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsdeleteArchiveForOrg(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsdeleteArchiveForOrgRequest(c.Server, org, migrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsdownloadArchiveForOrg(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsdownloadArchiveForOrgRequest(c.Server, org, migrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsunlockRepoForOrg(ctx context.Context, org Org, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsunlockRepoForOrgRequest(c.Server, org, migrationId, repoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationslistReposForOrg(ctx context.Context, org Org, migrationId MigrationId, params *MigrationslistReposForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationslistReposForOrgRequest(c.Server, org, migrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistOutsideCollaborators(ctx context.Context, org Org, params *OrgslistOutsideCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistOutsideCollaboratorsRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsremoveOutsideCollaborator(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsremoveOutsideCollaboratorRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsconvertMemberToOutsideCollaborator(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsconvertMemberToOutsideCollaboratorRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackageslistPackagesForOrganization(ctx context.Context, org Org, params *PackageslistPackagesForOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackageslistPackagesForOrganizationRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageForOrg(ctx context.Context, org Org, packageType PackagesdeletePackageForOrgParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageForOrgRequest(c.Server, org, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageForOrganization(ctx context.Context, org Org, packageType PackagesgetPackageForOrganizationParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageForOrganizationRequest(c.Server, org, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageForOrg(ctx context.Context, org Org, packageType PackagesrestorePackageForOrgParamsPackageType, packageName PackageName, params *PackagesrestorePackageForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageForOrgRequest(c.Server, org, packageType, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetAllPackageVersionsForPackageOwnedByOrg(ctx context.Context, org Org, packageType PackagesgetAllPackageVersionsForPackageOwnedByOrgParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetAllPackageVersionsForPackageOwnedByOrgRequest(c.Server, org, packageType, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageVersionForOrg(ctx context.Context, org Org, packageType PackagesdeletePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageVersionForOrgRequest(c.Server, org, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageVersionForOrganization(ctx context.Context, org Org, packageType PackagesgetPackageVersionForOrganizationParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageVersionForOrganizationRequest(c.Server, org, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageVersionForOrg(ctx context.Context, org Org, packageType PackagesrestorePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageVersionForOrgRequest(c.Server, org, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistForOrg(ctx context.Context, org Org, params *ProjectslistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForOrgRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForOrg(ctx context.Context, org Org, body ProjectscreateForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForOrgRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistPublicMembers(ctx context.Context, org Org, params *OrgslistPublicMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistPublicMembersRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsremovePublicMembershipForAuthenticatedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsremovePublicMembershipForAuthenticatedUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgscheckPublicMembershipForUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgscheckPublicMembershipForUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgssetPublicMembershipForAuthenticatedUser(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgssetPublicMembershipForAuthenticatedUserRequest(c.Server, org, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistForOrg(ctx context.Context, org Org, params *ReposlistForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateInOrgWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateInOrgRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateInOrg(ctx context.Context, org Org, body ReposcreateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateInOrgRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanninglistAlertsForOrg(ctx context.Context, org Org, params *SecretScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanninglistAlertsForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubActionsBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubActionsBillingOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubAdvancedSecurityBillingOrg(ctx context.Context, org Org, params *BillinggetGithubAdvancedSecurityBillingOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubAdvancedSecurityBillingOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubPackagesBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubPackagesBillingOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetSharedStorageBillingOrg(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetSharedStorageBillingOrgRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistIdpGroupsForOrg(ctx context.Context, org Org, params *TeamslistIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistIdpGroupsForOrgRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Teamslist(ctx context.Context, org Org, params *TeamslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Teamscreate(ctx context.Context, org Org, body TeamscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteInOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteInOrgRequest(c.Server, org, teamSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetByName(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetByNameRequest(c.Server, org, teamSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateInOrgRequestWithBody(c.Server, org, teamSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamsupdateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateInOrgRequest(c.Server, org, teamSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistDiscussionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistDiscussionsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistDiscussionsInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionInOrgRequestWithBody(c.Server, org, teamSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionInOrgRequest(c.Server, org, teamSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteDiscussionInOrgRequest(c.Server, org, teamSlug, discussionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetDiscussionInOrgRequest(c.Server, org, teamSlug, discussionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionInOrgRequestWithBody(c.Server, org, teamSlug, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamsupdateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionInOrgRequest(c.Server, org, teamSlug, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistDiscussionCommentsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistDiscussionCommentsInOrgRequest(c.Server, org, teamSlug, discussionNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionCommentInOrgRequestWithBody(c.Server, org, teamSlug, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, commentNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, commentNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionCommentInOrgRequestWithBody(c.Server, org, teamSlug, discussionNumber, commentNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, commentNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForTeamDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForTeamDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, commentNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionCommentInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionCommentInOrgRequestWithBody(c.Server, org, teamSlug, discussionNumber, commentNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionCommentInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionCommentInOrgRequest(c.Server, org, teamSlug, discussionNumber, commentNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForTeamDiscussionComment(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForTeamDiscussionCommentRequest(c.Server, org, teamSlug, discussionNumber, commentNumber, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForTeamDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForTeamDiscussionInOrgRequest(c.Server, org, teamSlug, discussionNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionInOrgRequestWithBody(c.Server, org, teamSlug, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionInOrg(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionInOrgRequest(c.Server, org, teamSlug, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForTeamDiscussion(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForTeamDiscussionRequest(c.Server, org, teamSlug, discussionNumber, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsunlinkExternalIdpGroupFromTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsunlinkExternalIdpGroupFromTeamForOrgRequest(c.Server, org, teamSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistLinkedExternalIdpGroupsToTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistLinkedExternalIdpGroupsToTeamForOrgRequest(c.Server, org, teamSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslinkExternalIdpGroupToTeamForOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslinkExternalIdpGroupToTeamForOrgRequestWithBody(c.Server, org, teamSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslinkExternalIdpGroupToTeamForOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamslinkExternalIdpGroupToTeamForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslinkExternalIdpGroupToTeamForOrgRequest(c.Server, org, teamSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistPendingInvitationsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistPendingInvitationsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistPendingInvitationsInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistMembersInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistMembersInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistMembersInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveMembershipForUserInOrgRequest(c.Server, org, teamSlug, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetMembershipForUserInOrgRequest(c.Server, org, teamSlug, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateMembershipForUserInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateMembershipForUserInOrgRequestWithBody(c.Server, org, teamSlug, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateMembershipForUserInOrg(ctx context.Context, org Org, teamSlug TeamSlug, username Username, body TeamsaddOrUpdateMembershipForUserInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateMembershipForUserInOrgRequest(c.Server, org, teamSlug, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistProjectsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistProjectsInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistProjectsInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveProjectInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveProjectInOrgRequest(c.Server, org, teamSlug, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscheckPermissionsForProjectInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscheckPermissionsForProjectInOrgRequest(c.Server, org, teamSlug, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateProjectPermissionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateProjectPermissionsInOrgRequestWithBody(c.Server, org, teamSlug, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateProjectPermissionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateProjectPermissionsInOrgRequest(c.Server, org, teamSlug, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistReposInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistReposInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistReposInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveRepoInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveRepoInOrgRequest(c.Server, org, teamSlug, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscheckPermissionsForRepoInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscheckPermissionsForRepoInOrgRequest(c.Server, org, teamSlug, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateRepoPermissionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateRepoPermissionsInOrgRequestWithBody(c.Server, org, teamSlug, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateRepoPermissionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateRepoPermissionsInOrgRequest(c.Server, org, teamSlug, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistIdpGroupsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistIdpGroupsInOrgRequest(c.Server, org, teamSlug)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBody(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequestWithBody(c.Server, org, teamSlug, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateOrUpdateIdpGroupConnectionsInOrg(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateOrUpdateIdpGroupConnectionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequest(c.Server, org, teamSlug, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistChildInOrg(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistChildInOrgParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistChildInOrgRequest(c.Server, org, teamSlug, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsdeleteCard(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsdeleteCardRequest(c.Server, cardId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsgetCard(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsgetCardRequest(c.Server, cardId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsupdateCardWithBody(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateCardRequestWithBody(c.Server, cardId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsupdateCard(ctx context.Context, cardId CardId, body ProjectsupdateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateCardRequest(c.Server, cardId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsmoveCardWithBody(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsmoveCardRequestWithBody(c.Server, cardId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsmoveCard(ctx context.Context, cardId CardId, body ProjectsmoveCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsmoveCardRequest(c.Server, cardId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsdeleteColumn(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsdeleteColumnRequest(c.Server, columnId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsgetColumn(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsgetColumnRequest(c.Server, columnId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsupdateColumnWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateColumnRequestWithBody(c.Server, columnId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsupdateColumn(ctx context.Context, columnId ColumnId, body ProjectsupdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateColumnRequest(c.Server, columnId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistCards(ctx context.Context, columnId ColumnId, params *ProjectslistCardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistCardsRequest(c.Server, columnId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateCardWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateCardRequestWithBody(c.Server, columnId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateCard(ctx context.Context, columnId ColumnId, body ProjectscreateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateCardRequest(c.Server, columnId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsmoveColumnWithBody(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsmoveColumnRequestWithBody(c.Server, columnId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsmoveColumn(ctx context.Context, columnId ColumnId, body ProjectsmoveColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsmoveColumnRequest(c.Server, columnId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Projectsdelete(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsdeleteRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Projectsget(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsgetRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsupdateWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Projectsupdate(ctx context.Context, projectId ProjectId, body ProjectsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsupdateRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistCollaborators(ctx context.Context, projectId ProjectId, params *ProjectslistCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistCollaboratorsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsremoveCollaborator(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsremoveCollaboratorRequest(c.Server, projectId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsaddCollaboratorWithBody(ctx context.Context, projectId ProjectId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsaddCollaboratorRequestWithBody(c.Server, projectId, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsaddCollaborator(ctx context.Context, projectId ProjectId, username Username, body ProjectsaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsaddCollaboratorRequest(c.Server, projectId, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectsgetPermissionForUser(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsgetPermissionForUserRequest(c.Server, projectId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistColumns(ctx context.Context, projectId ProjectId, params *ProjectslistColumnsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistColumnsRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateColumnWithBody(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateColumnRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateColumn(ctx context.Context, projectId ProjectId, body ProjectscreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateColumnRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RateLimitget(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRateLimitgetRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reposdelete(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reposget(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reposupdate(ctx context.Context, owner Owner, repo Repo, body ReposupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistArtifactsForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistArtifactsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistArtifactsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteArtifactRequest(c.Server, owner, repo, artifactId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetArtifactRequest(c.Server, owner, repo, artifactId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdownloadArtifact(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, archiveFormat string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdownloadArtifactRequest(c.Server, owner, repo, artifactId, archiveFormat)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetActionsCacheUsage(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetActionsCacheUsageRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetJobForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetJobForWorkflowRunRequest(c.Server, owner, repo, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdownloadJobLogsForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdownloadJobLogsForWorkflowRunRequest(c.Server, owner, repo, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunJobForWorkflowRunWithBody(ctx context.Context, owner Owner, repo Repo, jobId JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunJobForWorkflowRunRequestWithBody(c.Server, owner, repo, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunJobForWorkflowRun(ctx context.Context, owner Owner, repo Repo, jobId JobId, body ActionsreRunJobForWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunJobForWorkflowRunRequest(c.Server, owner, repo, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetGithubActionsPermissionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetGithubActionsPermissionsRepositoryRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsPermissionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsPermissionsRepositoryRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsPermissionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsPermissionsRepositoryRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflowAccessToRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowAccessToRepositoryRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetWorkflowAccessToRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetWorkflowAccessToRepositoryRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetWorkflowAccessToRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetWorkflowAccessToRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetWorkflowAccessToRepositoryRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetAllowedActionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetAllowedActionsRepositoryRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetAllowedActionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetAllowedActionsRepositoryRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetAllowedActionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetAllowedActionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetAllowedActionsRepositoryRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetGithubActionsDefaultWorkflowPermissionsRepository(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistSelfHostedRunnersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistSelfHostedRunnersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistSelfHostedRunnersForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistRunnerApplicationsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistRunnerApplicationsForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateRegistrationTokenForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateRegistrationTokenForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateRemoveTokenForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateRemoveTokenForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteSelfHostedRunnerFromRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteSelfHostedRunnerFromRepoRequest(c.Server, owner, repo, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistLabelsForSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBody(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequestWithBody(c.Server, owner, repo, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsaddCustomLabelsToSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBody(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequestWithBody(c.Server, owner, repo, runnerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionssetCustomLabelsForSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsremoveCustomLabelFromSelfHostedRunnerForRepo(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsremoveCustomLabelFromSelfHostedRunnerForRepoRequest(c.Server, owner, repo, runnerId, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistWorkflowRunsForRepo(ctx context.Context, owner Owner, repo Repo, params *ActionslistWorkflowRunsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistWorkflowRunsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteWorkflowRunRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionsgetWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowRunRequest(c.Server, owner, repo, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetReviewsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetReviewsForRunRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsapproveWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsapproveWorkflowRunRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistWorkflowRunArtifacts(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistWorkflowRunArtifactsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistWorkflowRunArtifactsRequest(c.Server, owner, repo, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflowRunAttempt(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionsgetWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowRunAttemptRequest(c.Server, owner, repo, runId, attemptNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistJobsForWorkflowRunAttempt(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionslistJobsForWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistJobsForWorkflowRunAttemptRequest(c.Server, owner, repo, runId, attemptNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdownloadWorkflowRunAttemptLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdownloadWorkflowRunAttemptLogsRequest(c.Server, owner, repo, runId, attemptNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscancelWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscancelWorkflowRunRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistJobsForWorkflowRun(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistJobsForWorkflowRunParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistJobsForWorkflowRunRequest(c.Server, owner, repo, runId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteWorkflowRunLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteWorkflowRunLogsRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdownloadWorkflowRunLogs(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdownloadWorkflowRunLogsRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetPendingDeploymentsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetPendingDeploymentsForRunRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreviewPendingDeploymentsForRunWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreviewPendingDeploymentsForRunRequestWithBody(c.Server, owner, repo, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreviewPendingDeploymentsForRun(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreviewPendingDeploymentsForRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreviewPendingDeploymentsForRunRequest(c.Server, owner, repo, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunWorkflowWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunWorkflowRequestWithBody(c.Server, owner, repo, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunWorkflow(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunWorkflowRequest(c.Server, owner, repo, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunWorkflowFailedJobsWithBody(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunWorkflowFailedJobsRequestWithBody(c.Server, owner, repo, runId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsreRunWorkflowFailedJobs(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowFailedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsreRunWorkflowFailedJobsRequest(c.Server, owner, repo, runId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflowRunUsage(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowRunUsageRequest(c.Server, owner, repo, runId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistRepoSecretsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetRepoPublicKeyRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateRepoSecretRequestWithBody(c.Server, owner, repo, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body ActionscreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateRepoSecretRequest(c.Server, owner, repo, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistRepoWorkflows(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoWorkflowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistRepoWorkflowsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowRequest(c.Server, owner, repo, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdisableWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdisableWorkflowRequest(c.Server, owner, repo, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateWorkflowDispatchWithBody(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateWorkflowDispatchRequestWithBody(c.Server, owner, repo, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateWorkflowDispatch(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, body ActionscreateWorkflowDispatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateWorkflowDispatchRequest(c.Server, owner, repo, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsenableWorkflow(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsenableWorkflowRequest(c.Server, owner, repo, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistWorkflowRuns(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, params *ActionslistWorkflowRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistWorkflowRunsRequest(c.Server, owner, repo, workflowId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetWorkflowUsage(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetWorkflowUsageRequest(c.Server, owner, repo, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistAssignees(ctx context.Context, owner Owner, repo Repo, params *IssueslistAssigneesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistAssigneesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescheckUserCanBeAssigned(ctx context.Context, owner Owner, repo Repo, assignee string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescheckUserCanBeAssignedRequest(c.Server, owner, repo, assignee)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistAutolinks(ctx context.Context, owner Owner, repo Repo, params *ReposlistAutolinksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistAutolinksRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateAutolinkWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateAutolinkRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateAutolink(ctx context.Context, owner Owner, repo Repo, body ReposcreateAutolinkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateAutolinkRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteAutolink(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteAutolinkRequest(c.Server, owner, repo, autolinkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAutolink(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAutolinkRequest(c.Server, owner, repo, autolinkId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdisableAutomatedSecurityFixes(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdisableAutomatedSecurityFixesRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposenableAutomatedSecurityFixes(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposenableAutomatedSecurityFixesRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistBranches(ctx context.Context, owner Owner, repo Repo, params *ReposlistBranchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistBranchesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetBranchRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteBranchProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetBranchProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateBranchProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateBranchProtectionRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateBranchProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateBranchProtectionRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteAdminBranchProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAdminBranchProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetAdminBranchProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetAdminBranchProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeletePullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeletePullRequestReviewProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetPullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetPullRequestReviewProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdatePullRequestReviewProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdatePullRequestReviewProtectionRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdatePullRequestReviewProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdatePullRequestReviewProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdatePullRequestReviewProtectionRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteCommitSignatureProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommitSignatureProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateCommitSignatureProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateCommitSignatureProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveStatusCheckProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveStatusCheckProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetStatusChecksProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetStatusChecksProtectionRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateStatusCheckProtectionWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateStatusCheckProtectionRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateStatusCheckProtection(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateStatusCheckProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateStatusCheckProtectionRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveStatusCheckContextsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveStatusCheckContextsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAllStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAllStatusCheckContextsRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddStatusCheckContextsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddStatusCheckContextsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetStatusCheckContextsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetStatusCheckContextsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetStatusCheckContexts(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetStatusCheckContextsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteAccessRestrictionsRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAccessRestrictionsRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveAppAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveAppAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAppsWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAppsWithAccessToProtectedBranchRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddAppAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddAppAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetAppAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetAppAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetAppAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetAppAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveTeamAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveTeamAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetTeamsWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetTeamsWithAccessToProtectedBranchRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddTeamAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddTeamAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetTeamAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetTeamAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetTeamAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetTeamAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveUserAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveUserAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetUsersWithAccessToProtectedBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetUsersWithAccessToProtectedBranchRequest(c.Server, owner, repo, branch)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddUserAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddUserAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetUserAccessRestrictionsWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetUserAccessRestrictionsRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepossetUserAccessRestrictions(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepossetUserAccessRestrictionsRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposrenameBranchWithBody(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposrenameBranchRequestWithBody(c.Server, owner, repo, branch, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposrenameBranch(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposrenameBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposrenameBranchRequest(c.Server, owner, repo, branch, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckscreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckscreateRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Checkscreate(ctx context.Context, owner Owner, repo Repo, body CheckscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckscreateRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Checksget(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksgetRequest(c.Server, owner, repo, checkRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChecksupdateWithBody(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksupdateRequestWithBody(c.Server, owner, repo, checkRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Checksupdate(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, body ChecksupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksupdateRequest(c.Server, owner, repo, checkRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckslistAnnotations(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, params *CheckslistAnnotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckslistAnnotationsRequest(c.Server, owner, repo, checkRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChecksrerequestRun(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksrerequestRunRequest(c.Server, owner, repo, checkRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckscreateSuiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckscreateSuiteRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckscreateSuite(ctx context.Context, owner Owner, repo Repo, body CheckscreateSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckscreateSuiteRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckssetSuitesPreferencesWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckssetSuitesPreferencesRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckssetSuitesPreferences(ctx context.Context, owner Owner, repo Repo, body CheckssetSuitesPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckssetSuitesPreferencesRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChecksgetSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksgetSuiteRequest(c.Server, owner, repo, checkSuiteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckslistForSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, params *CheckslistForSuiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckslistForSuiteRequest(c.Server, owner, repo, checkSuiteId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChecksrerequestSuite(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChecksrerequestSuiteRequest(c.Server, owner, repo, checkSuiteId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninglistAlertsForRepo(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninglistAlertsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninggetAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninggetAlertRequest(c.Server, owner, repo, alertNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanningupdateAlertWithBody(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanningupdateAlertRequestWithBody(c.Server, owner, repo, alertNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanningupdateAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body CodeScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanningupdateAlertRequest(c.Server, owner, repo, alertNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninglistAlertInstances(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *CodeScanninglistAlertInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninglistAlertInstancesRequest(c.Server, owner, repo, alertNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninglistRecentAnalyses(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistRecentAnalysesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninglistRecentAnalysesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanningdeleteAnalysis(ctx context.Context, owner Owner, repo Repo, analysisId int, params *CodeScanningdeleteAnalysisParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanningdeleteAnalysisRequest(c.Server, owner, repo, analysisId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninggetAnalysis(ctx context.Context, owner Owner, repo Repo, analysisId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninggetAnalysisRequest(c.Server, owner, repo, analysisId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninguploadSarifWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninguploadSarifRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninguploadSarif(ctx context.Context, owner Owner, repo Repo, body CodeScanninguploadSarifJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninguploadSarifRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodeScanninggetSarif(ctx context.Context, owner Owner, repo Repo, sarifId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodeScanninggetSarifRequest(c.Server, owner, repo, sarifId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcodeownersErrors(ctx context.Context, owner Owner, repo Repo, params *ReposcodeownersErrorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcodeownersErrorsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistInRepositoryForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistInRepositoryForAuthenticatedUserRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateWithRepoForAuthenticatedUserWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateWithRepoForAuthenticatedUserRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateWithRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, body CodespacescreateWithRepoForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateWithRepoForAuthenticatedUserRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistDevcontainersInRepositoryForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistDevcontainersInRepositoryForAuthenticatedUserRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesrepoMachinesForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *CodespacesrepoMachinesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesrepoMachinesForAuthenticatedUserRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistRepoSecretsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetRepoPublicKeyRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesdeleteRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateOrUpdateRepoSecretRequestWithBody(c.Server, owner, repo, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body CodespacescreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateOrUpdateRepoSecretRequest(c.Server, owner, repo, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistCollaborators(ctx context.Context, owner Owner, repo Repo, params *ReposlistCollaboratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistCollaboratorsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposremoveCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposremoveCollaboratorRequest(c.Server, owner, repo, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcheckCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcheckCollaboratorRequest(c.Server, owner, repo, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddCollaboratorWithBody(ctx context.Context, owner Owner, repo Repo, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddCollaboratorRequestWithBody(c.Server, owner, repo, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposaddCollaborator(ctx context.Context, owner Owner, repo Repo, username Username, body ReposaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposaddCollaboratorRequest(c.Server, owner, repo, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCollaboratorPermissionLevel(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCollaboratorPermissionLevelRequest(c.Server, owner, repo, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistCommitCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistCommitCommentsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteCommitCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommitCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateCommitCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReposupdateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateCommitCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForCommitCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForCommitCommentRequest(c.Server, owner, repo, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForCommitCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForCommitCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForCommitComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForCommitCommentRequest(c.Server, owner, repo, commentId, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistCommits(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistCommitsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistBranchesForHeadCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistBranchesForHeadCommitRequest(c.Server, owner, repo, commitSha)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistCommentsForCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistCommentsForCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistCommentsForCommitRequest(c.Server, owner, repo, commitSha, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateCommitCommentWithBody(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateCommitCommentRequestWithBody(c.Server, owner, repo, commitSha, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateCommitComment(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, body ReposcreateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateCommitCommentRequest(c.Server, owner, repo, commitSha, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistPullRequestsAssociatedWithCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistPullRequestsAssociatedWithCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistPullRequestsAssociatedWithCommitRequest(c.Server, owner, repo, commitSha, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCommit(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCommitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommitRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckslistForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckslistForRefRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckslistSuitesForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistSuitesForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckslistSuitesForRefRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCombinedStatusForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCombinedStatusForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCombinedStatusForRefRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistCommitStatusesForRef(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposlistCommitStatusesForRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistCommitStatusesForRefRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCommunityProfileMetrics(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommunityProfileMetricsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcompareCommits(ctx context.Context, owner Owner, repo Repo, basehead string, params *ReposcompareCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcompareCommitsRequest(c.Server, owner, repo, basehead, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteFileWithBody(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteFileRequestWithBody(c.Server, owner, repo, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteFile(ctx context.Context, owner Owner, repo Repo, path string, body ReposdeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteFileRequest(c.Server, owner, repo, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetContent(ctx context.Context, owner Owner, repo Repo, path string, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetContentRequest(c.Server, owner, repo, path, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateFileContentsWithBody(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateFileContentsRequestWithBody(c.Server, owner, repo, path, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateFileContents(ctx context.Context, owner Owner, repo Repo, path string, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateFileContentsRequest(c.Server, owner, repo, path, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistContributors(ctx context.Context, owner Owner, repo Repo, params *ReposlistContributorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistContributorsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotlistRepoSecrets(ctx context.Context, owner Owner, repo Repo, params *DependabotlistRepoSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotlistRepoSecretsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotgetRepoPublicKey(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotgetRepoPublicKeyRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotdeleteRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotdeleteRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotgetRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotgetRepoSecretRequest(c.Server, owner, repo, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotcreateOrUpdateRepoSecretWithBody(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotcreateOrUpdateRepoSecretRequestWithBody(c.Server, owner, repo, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependabotcreateOrUpdateRepoSecret(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body DependabotcreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependabotcreateOrUpdateRepoSecretRequest(c.Server, owner, repo, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DependencyGraphdiffRange(ctx context.Context, owner Owner, repo Repo, basehead string, params *DependencyGraphdiffRangeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDependencyGraphdiffRangeRequest(c.Server, owner, repo, basehead, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistDeployments(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeploymentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistDeploymentsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeploymentWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeploymentRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeployment(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeploymentRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteDeployment(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteDeploymentRequest(c.Server, owner, repo, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetDeployment(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetDeploymentRequest(c.Server, owner, repo, deploymentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistDeploymentStatuses(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, params *ReposlistDeploymentStatusesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistDeploymentStatusesRequest(c.Server, owner, repo, deploymentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeploymentStatusWithBody(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeploymentStatusRequestWithBody(c.Server, owner, repo, deploymentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeploymentStatus(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, body ReposcreateDeploymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeploymentStatusRequest(c.Server, owner, repo, deploymentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetDeploymentStatus(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, statusId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetDeploymentStatusRequest(c.Server, owner, repo, deploymentId, statusId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDispatchEventWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDispatchEventRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDispatchEvent(ctx context.Context, owner Owner, repo Repo, body ReposcreateDispatchEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDispatchEventRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAllEnvironments(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllEnvironmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAllEnvironmentsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteAnEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteAnEnvironmentRequest(c.Server, owner, repo, environmentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetEnvironmentRequest(c.Server, owner, repo, environmentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateEnvironmentWithBody(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateEnvironmentRequestWithBody(c.Server, owner, repo, environmentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateOrUpdateEnvironment(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, body ReposcreateOrUpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateOrUpdateEnvironmentRequest(c.Server, owner, repo, environmentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistRepoEvents(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistRepoEventsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistForks(ctx context.Context, owner Owner, repo Repo, params *ReposlistForksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistForksRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateForkWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateForkRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateFork(ctx context.Context, owner Owner, repo Repo, body ReposcreateForkJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateForkRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateBlobWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateBlobRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateBlob(ctx context.Context, owner Owner, repo Repo, body GitcreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateBlobRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitgetBlob(ctx context.Context, owner Owner, repo Repo, fileSha string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitgetBlobRequest(c.Server, owner, repo, fileSha)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateCommitWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateCommitRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateCommit(ctx context.Context, owner Owner, repo Repo, body GitcreateCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateCommitRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitgetCommit(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitgetCommitRequest(c.Server, owner, repo, commitSha)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitlistMatchingRefs(ctx context.Context, owner Owner, repo Repo, ref string, params *GitlistMatchingRefsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitlistMatchingRefsRequest(c.Server, owner, repo, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitgetRef(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitgetRefRequest(c.Server, owner, repo, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateRefWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateRefRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateRef(ctx context.Context, owner Owner, repo Repo, body GitcreateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateRefRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitdeleteRef(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitdeleteRefRequest(c.Server, owner, repo, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitupdateRefWithBody(ctx context.Context, owner Owner, repo Repo, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitupdateRefRequestWithBody(c.Server, owner, repo, ref, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitupdateRef(ctx context.Context, owner Owner, repo Repo, ref string, body GitupdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitupdateRefRequest(c.Server, owner, repo, ref, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateTagWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateTagRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateTag(ctx context.Context, owner Owner, repo Repo, body GitcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateTagRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitgetTag(ctx context.Context, owner Owner, repo Repo, tagSha string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitgetTagRequest(c.Server, owner, repo, tagSha)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateTreeWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateTreeRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitcreateTree(ctx context.Context, owner Owner, repo Repo, body GitcreateTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitcreateTreeRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GitgetTree(ctx context.Context, owner Owner, repo Repo, treeSha string, params *GitgetTreeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGitgetTreeRequest(c.Server, owner, repo, treeSha, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistWebhooks(ctx context.Context, owner Owner, repo Repo, params *ReposlistWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistWebhooksRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateWebhookWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateWebhookRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateWebhook(ctx context.Context, owner Owner, repo Repo, body ReposcreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateWebhookRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteWebhookRequest(c.Server, owner, repo, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetWebhookRequest(c.Server, owner, repo, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateWebhookWithBody(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateWebhookRequestWithBody(c.Server, owner, repo, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateWebhookRequest(c.Server, owner, repo, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetWebhookConfigForRepo(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetWebhookConfigForRepoRequest(c.Server, owner, repo, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateWebhookConfigForRepoWithBody(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateWebhookConfigForRepoRequestWithBody(c.Server, owner, repo, hookId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateWebhookConfigForRepo(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookConfigForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateWebhookConfigForRepoRequest(c.Server, owner, repo, hookId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistWebhookDeliveries(ctx context.Context, owner Owner, repo Repo, hookId HookId, params *ReposlistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistWebhookDeliveriesRequest(c.Server, owner, repo, hookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetWebhookDelivery(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetWebhookDeliveryRequest(c.Server, owner, repo, hookId, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposredeliverWebhookDelivery(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposredeliverWebhookDeliveryRequest(c.Server, owner, repo, hookId, deliveryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepospingWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepospingWebhookRequest(c.Server, owner, repo, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepostestPushWebhook(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepostestPushWebhookRequest(c.Server, owner, repo, hookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationscancelImport(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationscancelImportRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetImportStatus(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetImportStatusRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsupdateImportWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsupdateImportRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsupdateImport(ctx context.Context, owner Owner, repo Repo, body MigrationsupdateImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsupdateImportRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartImportWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartImportRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartImport(ctx context.Context, owner Owner, repo Repo, body MigrationsstartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartImportRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetCommitAuthors(ctx context.Context, owner Owner, repo Repo, params *MigrationsgetCommitAuthorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetCommitAuthorsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsmapCommitAuthorWithBody(ctx context.Context, owner Owner, repo Repo, authorId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsmapCommitAuthorRequestWithBody(c.Server, owner, repo, authorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsmapCommitAuthor(ctx context.Context, owner Owner, repo Repo, authorId int, body MigrationsmapCommitAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsmapCommitAuthorRequest(c.Server, owner, repo, authorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetLargeFiles(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetLargeFilesRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationssetLfsPreferenceWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationssetLfsPreferenceRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationssetLfsPreference(ctx context.Context, owner Owner, repo Repo, body MigrationssetLfsPreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationssetLfsPreferenceRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetRepoInstallation(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetRepoInstallationRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsremoveRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsremoveRestrictionsForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsgetRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsgetRestrictionsForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForRepoWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForRepoRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForRepo(ctx context.Context, owner Owner, repo Repo, body InteractionssetRestrictionsForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForRepoRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistInvitations(ctx context.Context, owner Owner, repo Repo, params *ReposlistInvitationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistInvitationsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteInvitation(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteInvitationRequest(c.Server, owner, repo, invitationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateInvitationWithBody(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateInvitationRequestWithBody(c.Server, owner, repo, invitationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateInvitation(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, body ReposupdateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateInvitationRequest(c.Server, owner, repo, invitationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issuescreate(ctx context.Context, owner Owner, repo Repo, body IssuescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistCommentsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesdeleteComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesdeleteCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesgetComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesgetCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body IssuesupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForIssueCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForIssueCommentRequest(c.Server, owner, repo, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForIssueCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForIssueCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForIssueCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForIssueCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForIssueComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForIssueCommentRequest(c.Server, owner, repo, commentId, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistEventsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistEventsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistEventsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesgetEvent(ctx context.Context, owner Owner, repo Repo, eventId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesgetEventRequest(c.Server, owner, repo, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issuesget(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesgetRequest(c.Server, owner, repo, issueNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issuesupdate(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesremoveAssigneesWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesremoveAssigneesRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesremoveAssignees(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesremoveAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesremoveAssigneesRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesaddAssigneesWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesaddAssigneesRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesaddAssignees(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesaddAssigneesRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistComments(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistCommentsRequest(c.Server, owner, repo, issueNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateCommentWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateCommentRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateComment(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuescreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateCommentRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistEvents(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistEventsRequest(c.Server, owner, repo, issueNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesremoveAllLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesremoveAllLabelsRequest(c.Server, owner, repo, issueNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistLabelsOnIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistLabelsOnIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistLabelsOnIssueRequest(c.Server, owner, repo, issueNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesaddLabelsWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesaddLabelsRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesaddLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesaddLabelsRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuessetLabelsWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuessetLabelsRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuessetLabels(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuessetLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuessetLabelsRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesremoveLabel(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesremoveLabelRequest(c.Server, owner, repo, issueNumber, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issuesunlock(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesunlockRequest(c.Server, owner, repo, issueNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslockWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslockRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issueslock(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssueslockJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslockRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *ReactionslistForIssueParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForIssueRequest(c.Server, owner, repo, issueNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForIssueWithBody(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForIssueRequestWithBody(c.Server, owner, repo, issueNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body ReactionscreateForIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForIssueRequest(c.Server, owner, repo, issueNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForIssue(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForIssueRequest(c.Server, owner, repo, issueNumber, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistEventsForTimeline(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsForTimelineParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistEventsForTimelineRequest(c.Server, owner, repo, issueNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistDeployKeys(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeployKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistDeployKeysRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeployKeyWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeployKeyRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateDeployKey(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeployKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateDeployKeyRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteDeployKey(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteDeployKeyRequest(c.Server, owner, repo, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetDeployKey(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetDeployKeyRequest(c.Server, owner, repo, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistLabelsForRepo(ctx context.Context, owner Owner, repo Repo, params *IssueslistLabelsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistLabelsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateLabelWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateLabelRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateLabel(ctx context.Context, owner Owner, repo Repo, body IssuescreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateLabelRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesdeleteLabel(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesdeleteLabelRequest(c.Server, owner, repo, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesgetLabel(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesgetLabelRequest(c.Server, owner, repo, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateLabelWithBody(ctx context.Context, owner Owner, repo Repo, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateLabelRequestWithBody(c.Server, owner, repo, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateLabel(ctx context.Context, owner Owner, repo Repo, name string, body IssuesupdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateLabelRequest(c.Server, owner, repo, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistLanguages(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistLanguagesRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdisableLfsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdisableLfsForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposenableLfsForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposenableLfsForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LicensesgetForRepo(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLicensesgetForRepoRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposmergeUpstreamWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposmergeUpstreamRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposmergeUpstream(ctx context.Context, owner Owner, repo Repo, body ReposmergeUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposmergeUpstreamRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposmergeWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposmergeRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Reposmerge(ctx context.Context, owner Owner, repo Repo, body ReposmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposmergeRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistMilestones(ctx context.Context, owner Owner, repo Repo, params *IssueslistMilestonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistMilestonesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateMilestoneWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateMilestoneRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuescreateMilestone(ctx context.Context, owner Owner, repo Repo, body IssuescreateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuescreateMilestoneRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesdeleteMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesdeleteMilestoneRequest(c.Server, owner, repo, milestoneNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesgetMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesgetMilestoneRequest(c.Server, owner, repo, milestoneNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateMilestoneWithBody(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateMilestoneRequestWithBody(c.Server, owner, repo, milestoneNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssuesupdateMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, body IssuesupdateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesupdateMilestoneRequest(c.Server, owner, repo, milestoneNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistLabelsForMilestone(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, params *IssueslistLabelsForMilestoneParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistLabelsForMilestoneRequest(c.Server, owner, repo, milestoneNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistRepoNotificationsForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistRepoNotificationsForAuthenticatedUserRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitymarkRepoNotificationsAsReadWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitymarkRepoNotificationsAsReadRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitymarkRepoNotificationsAsRead(ctx context.Context, owner Owner, repo Repo, body ActivitymarkRepoNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitymarkRepoNotificationsAsReadRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeletePagesSite(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeletePagesSiteRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetPages(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetPagesRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreatePagesSiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreatePagesSiteRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreatePagesSite(ctx context.Context, owner Owner, repo Repo, body ReposcreatePagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreatePagesSiteRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateInformationAboutPagesSiteWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateInformationAboutPagesSiteRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateInformationAboutPagesSite(ctx context.Context, owner Owner, repo Repo, body ReposupdateInformationAboutPagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateInformationAboutPagesSiteRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistPagesBuilds(ctx context.Context, owner Owner, repo Repo, params *ReposlistPagesBuildsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistPagesBuildsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposrequestPagesBuild(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposrequestPagesBuildRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetLatestPagesBuild(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetLatestPagesBuildRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetPagesBuild(ctx context.Context, owner Owner, repo Repo, buildId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetPagesBuildRequest(c.Server, owner, repo, buildId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetPagesHealthCheck(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetPagesHealthCheckRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistForRepo(ctx context.Context, owner Owner, repo Repo, params *ProjectslistForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForRepoWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForRepoRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForRepo(ctx context.Context, owner Owner, repo Repo, body ProjectscreateForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForRepoRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pullslist(ctx context.Context, owner Owner, repo Repo, params *PullslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pullscreate(ctx context.Context, owner Owner, repo Repo, body PullscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistReviewCommentsForRepo(ctx context.Context, owner Owner, repo Repo, params *PullslistReviewCommentsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistReviewCommentsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsdeleteReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsdeleteReviewCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsgetReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsgetReviewCommentRequest(c.Server, owner, repo, commentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateReviewCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body PullsupdateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateReviewCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForPullRequestReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForPullRequestReviewCommentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForPullRequestReviewCommentRequest(c.Server, owner, repo, commentId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForPullRequestReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForPullRequestReviewCommentRequestWithBody(c.Server, owner, repo, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForPullRequestReviewComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForPullRequestReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForPullRequestReviewCommentRequest(c.Server, owner, repo, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForPullRequestComment(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForPullRequestCommentRequest(c.Server, owner, repo, commentId, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pullsget(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsgetRequest(c.Server, owner, repo, pullNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pullsupdate(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateWithPrForAuthenticatedUserWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateWithPrForAuthenticatedUserRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateWithPrForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body CodespacescreateWithPrForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateWithPrForAuthenticatedUserRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistReviewComments(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistReviewCommentsRequest(c.Server, owner, repo, pullNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReviewCommentRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReviewComment(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReviewCommentRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReplyForReviewCommentWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReplyForReviewCommentRequestWithBody(c.Server, owner, repo, pullNumber, commentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReplyForReviewComment(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, body PullscreateReplyForReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReplyForReviewCommentRequest(c.Server, owner, repo, pullNumber, commentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistCommits(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistCommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistCommitsRequest(c.Server, owner, repo, pullNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistFiles(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistFilesRequest(c.Server, owner, repo, pullNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscheckIfMerged(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscheckIfMergedRequest(c.Server, owner, repo, pullNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsmergeWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsmergeRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Pullsmerge(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsmergeRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsremoveRequestedReviewersWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsremoveRequestedReviewersRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsremoveRequestedReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsremoveRequestedReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsremoveRequestedReviewersRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistRequestedReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistRequestedReviewersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistRequestedReviewersRequest(c.Server, owner, repo, pullNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsrequestReviewersWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsrequestReviewersRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsrequestReviewers(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsrequestReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsrequestReviewersRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistReviews(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistReviewsRequest(c.Server, owner, repo, pullNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReviewRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullscreateReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullscreateReviewRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsdeletePendingReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsdeletePendingReviewRequest(c.Server, owner, repo, pullNumber, reviewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsgetReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsgetReviewRequest(c.Server, owner, repo, pullNumber, reviewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateReviewRequestWithBody(c.Server, owner, repo, pullNumber, reviewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsupdateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateReviewRequest(c.Server, owner, repo, pullNumber, reviewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullslistCommentsForReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, params *PullslistCommentsForReviewParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullslistCommentsForReviewRequest(c.Server, owner, repo, pullNumber, reviewId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsdismissReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsdismissReviewRequestWithBody(c.Server, owner, repo, pullNumber, reviewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsdismissReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsdismissReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsdismissReviewRequest(c.Server, owner, repo, pullNumber, reviewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullssubmitReviewWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullssubmitReviewRequestWithBody(c.Server, owner, repo, pullNumber, reviewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullssubmitReview(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullssubmitReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullssubmitReviewRequest(c.Server, owner, repo, pullNumber, reviewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateBranchWithBody(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateBranchRequestWithBody(c.Server, owner, repo, pullNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PullsupdateBranch(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPullsupdateBranchRequest(c.Server, owner, repo, pullNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetReadme(ctx context.Context, owner Owner, repo Repo, params *ReposgetReadmeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetReadmeRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetReadmeInDirectory(ctx context.Context, owner Owner, repo Repo, dir string, params *ReposgetReadmeInDirectoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetReadmeInDirectoryRequest(c.Server, owner, repo, dir, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistReleases(ctx context.Context, owner Owner, repo Repo, params *ReposlistReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistReleasesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateReleaseWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateReleaseRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateRelease(ctx context.Context, owner Owner, repo Repo, body ReposcreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateReleaseRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteReleaseAssetRequest(c.Server, owner, repo, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetReleaseAssetRequest(c.Server, owner, repo, assetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateReleaseAssetWithBody(ctx context.Context, owner Owner, repo Repo, assetId AssetId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateReleaseAssetRequestWithBody(c.Server, owner, repo, assetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateReleaseAsset(ctx context.Context, owner Owner, repo Repo, assetId AssetId, body ReposupdateReleaseAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateReleaseAssetRequest(c.Server, owner, repo, assetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgenerateReleaseNotesWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgenerateReleaseNotesRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgenerateReleaseNotes(ctx context.Context, owner Owner, repo Repo, body ReposgenerateReleaseNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgenerateReleaseNotesRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetLatestRelease(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetLatestReleaseRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetReleaseByTag(ctx context.Context, owner Owner, repo Repo, tag string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetReleaseByTagRequest(c.Server, owner, repo, tag)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteReleaseRequest(c.Server, owner, repo, releaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetReleaseRequest(c.Server, owner, repo, releaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateReleaseWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateReleaseRequestWithBody(c.Server, owner, repo, releaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposupdateRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReposupdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposupdateReleaseRequest(c.Server, owner, repo, releaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistReleaseAssets(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposlistReleaseAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistReleaseAssetsRequest(c.Server, owner, repo, releaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposuploadReleaseAssetWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposuploadReleaseAssetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposuploadReleaseAssetRequestWithBody(c.Server, owner, repo, releaseId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReactionslistForReleaseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForReleaseRequest(c.Server, owner, repo, releaseId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForReleaseWithBody(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForReleaseRequestWithBody(c.Server, owner, repo, releaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReactionscreateForReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForReleaseRequest(c.Server, owner, repo, releaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionsdeleteForRelease(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionsdeleteForReleaseRequest(c.Server, owner, repo, releaseId, reactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanninglistAlertsForRepo(ctx context.Context, owner Owner, repo Repo, params *SecretScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanninglistAlertsForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanninggetAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanninggetAlertRequest(c.Server, owner, repo, alertNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanningupdateAlertWithBody(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanningupdateAlertRequestWithBody(c.Server, owner, repo, alertNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanningupdateAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body SecretScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanningupdateAlertRequest(c.Server, owner, repo, alertNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SecretScanninglistLocationsForAlert(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *SecretScanninglistLocationsForAlertParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSecretScanninglistLocationsForAlertRequest(c.Server, owner, repo, alertNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistStargazersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActivitylistStargazersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistStargazersForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCodeFrequencyStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCodeFrequencyStatsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetCommitActivityStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetCommitActivityStatsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetContributorsStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetContributorsStatsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetParticipationStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetParticipationStatsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetPunchCardStats(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetPunchCardStatsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateCommitStatusWithBody(ctx context.Context, owner Owner, repo Repo, sha string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateCommitStatusRequestWithBody(c.Server, owner, repo, sha, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateCommitStatus(ctx context.Context, owner Owner, repo Repo, sha string, body ReposcreateCommitStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateCommitStatusRequest(c.Server, owner, repo, sha, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistWatchersForRepo(ctx context.Context, owner Owner, repo Repo, params *ActivitylistWatchersForRepoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistWatchersForRepoRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitydeleteRepoSubscription(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitydeleteRepoSubscriptionRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitygetRepoSubscription(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitygetRepoSubscriptionRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitysetRepoSubscriptionWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitysetRepoSubscriptionRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitysetRepoSubscription(ctx context.Context, owner Owner, repo Repo, body ActivitysetRepoSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitysetRepoSubscriptionRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistTags(ctx context.Context, owner Owner, repo Repo, params *ReposlistTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistTagsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistTagProtection(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistTagProtectionRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateTagProtectionWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateTagProtectionRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateTagProtection(ctx context.Context, owner Owner, repo Repo, body ReposcreateTagProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateTagProtectionRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeleteTagProtection(ctx context.Context, owner Owner, repo Repo, tagProtectionId TagProtectionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeleteTagProtectionRequest(c.Server, owner, repo, tagProtectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdownloadTarballArchive(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdownloadTarballArchiveRequest(c.Server, owner, repo, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistTeams(ctx context.Context, owner Owner, repo Repo, params *ReposlistTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistTeamsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetAllTopics(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetAllTopicsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposreplaceAllTopicsWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposreplaceAllTopicsRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposreplaceAllTopics(ctx context.Context, owner Owner, repo Repo, body ReposreplaceAllTopicsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposreplaceAllTopicsRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetClones(ctx context.Context, owner Owner, repo Repo, params *ReposgetClonesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetClonesRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetTopPaths(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetTopPathsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetTopReferrers(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetTopReferrersRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposgetViews(ctx context.Context, owner Owner, repo Repo, params *ReposgetViewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposgetViewsRequest(c.Server, owner, repo, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RepostransferWithBody(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepostransferRequestWithBody(c.Server, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Repostransfer(ctx context.Context, owner Owner, repo Repo, body RepostransferJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRepostransferRequest(c.Server, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdisableVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdisableVulnerabilityAlertsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcheckVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcheckVulnerabilityAlertsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposenableVulnerabilityAlerts(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposenableVulnerabilityAlertsRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdownloadZipballArchive(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdownloadZipballArchiveRequest(c.Server, owner, repo, ref)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateUsingTemplateWithBody(ctx context.Context, templateOwner string, templateRepo string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateUsingTemplateRequestWithBody(c.Server, templateOwner, templateRepo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateUsingTemplate(ctx context.Context, templateOwner string, templateRepo string, body ReposcreateUsingTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateUsingTemplateRequest(c.Server, templateOwner, templateRepo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistPublic(ctx context.Context, params *ReposlistPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistPublicRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionslistEnvironmentSecrets(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, params *ActionslistEnvironmentSecretsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionslistEnvironmentSecretsRequest(c.Server, repositoryId, environmentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetEnvironmentPublicKey(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetEnvironmentPublicKeyRequest(c.Server, repositoryId, environmentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsdeleteEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsdeleteEnvironmentSecretRequest(c.Server, repositoryId, environmentName, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionsgetEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionsgetEnvironmentSecretRequest(c.Server, repositoryId, environmentName, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateEnvironmentSecretWithBody(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateEnvironmentSecretRequestWithBody(c.Server, repositoryId, environmentName, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActionscreateOrUpdateEnvironmentSecret(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, body ActionscreateOrUpdateEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActionscreateOrUpdateEnvironmentSecretRequest(c.Server, repositoryId, environmentName, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistProvisionedGroupsEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedGroupsEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistProvisionedGroupsEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminprovisionAndInviteEnterpriseGroup(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmindeleteScimGroupFromEnterprise(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmindeleteScimGroupFromEnterpriseRequest(c.Server, enterprise, scimGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetProvisioningInformationForEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, params *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetProvisioningInformationForEnterpriseGroupRequest(c.Server, enterprise, scimGroupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateAttributeForEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequestWithBody(c.Server, enterprise, scimGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateAttributeForEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminupdateAttributeForEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequest(c.Server, enterprise, scimGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBody(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequestWithBody(c.Server, enterprise, scimGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetInformationForProvisionedEnterpriseGroup(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminsetInformationForProvisionedEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequest(c.Server, enterprise, scimGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminlistProvisionedIdentitiesEnterprise(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedIdentitiesEnterpriseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminlistProvisionedIdentitiesEnterpriseRequest(c.Server, enterprise, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminprovisionAndInviteEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequestWithBody(c.Server, enterprise, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminprovisionAndInviteEnterpriseUser(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequest(c.Server, enterprise, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmindeleteUserFromEnterprise(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmindeleteUserFromEnterpriseRequest(c.Server, enterprise, scimUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdmingetProvisioningInformationForEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdmingetProvisioningInformationForEnterpriseUserRequest(c.Server, enterprise, scimUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateAttributeForEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateAttributeForEnterpriseUserRequestWithBody(c.Server, enterprise, scimUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminupdateAttributeForEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminupdateAttributeForEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminupdateAttributeForEnterpriseUserRequest(c.Server, enterprise, scimUserId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBody(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequestWithBody(c.Server, enterprise, scimUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnterpriseAdminsetInformationForProvisionedEnterpriseUser(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminsetInformationForProvisionedEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequest(c.Server, enterprise, scimUserId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimlistProvisionedIdentities(ctx context.Context, org Org, params *ScimlistProvisionedIdentitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimlistProvisionedIdentitiesRequest(c.Server, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimprovisionAndInviteUserWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimprovisionAndInviteUserRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimprovisionAndInviteUser(ctx context.Context, org Org, body ScimprovisionAndInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimprovisionAndInviteUserRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimdeleteUserFromOrg(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimdeleteUserFromOrgRequest(c.Server, org, scimUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimgetProvisioningInformationForUser(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimgetProvisioningInformationForUserRequest(c.Server, org, scimUserId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimupdateAttributeForUserWithBody(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimupdateAttributeForUserRequestWithBody(c.Server, org, scimUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimupdateAttributeForUser(ctx context.Context, org Org, scimUserId ScimUserId, body ScimupdateAttributeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimupdateAttributeForUserRequest(c.Server, org, scimUserId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimsetInformationForProvisionedUserWithBody(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimsetInformationForProvisionedUserRequestWithBody(c.Server, org, scimUserId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScimsetInformationForProvisionedUser(ctx context.Context, org Org, scimUserId ScimUserId, body ScimsetInformationForProvisionedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScimsetInformationForProvisionedUserRequest(c.Server, org, scimUserId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchcode(ctx context.Context, params *SearchcodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchcodeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchcommits(ctx context.Context, params *SearchcommitsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchcommitsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchissuesAndPullRequests(ctx context.Context, params *SearchissuesAndPullRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchissuesAndPullRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchlabels(ctx context.Context, params *SearchlabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchlabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchrepos(ctx context.Context, params *SearchreposParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchreposRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchtopics(ctx context.Context, params *SearchtopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchtopicsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Searchusers(ctx context.Context, params *SearchusersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchusersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteLegacyRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetLegacyRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateLegacyRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateLegacy(ctx context.Context, teamId TeamId, body TeamsupdateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateLegacyRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistDiscussionsLegacy(ctx context.Context, teamId TeamId, params *TeamslistDiscussionsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistDiscussionsLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionLegacyRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionLegacy(ctx context.Context, teamId TeamId, body TeamscreateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionLegacyRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteDiscussionLegacyRequest(c.Server, teamId, discussionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetDiscussionLegacyRequest(c.Server, teamId, discussionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionLegacyRequestWithBody(c.Server, teamId, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamsupdateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionLegacyRequest(c.Server, teamId, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistDiscussionCommentsLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistDiscussionCommentsLegacyRequest(c.Server, teamId, discussionNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionCommentLegacyRequestWithBody(c.Server, teamId, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsdeleteDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsdeleteDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, commentNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, commentNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionCommentLegacyRequestWithBody(c.Server, teamId, discussionNumber, commentNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsupdateDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsupdateDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, commentNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForTeamDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForTeamDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, commentNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionCommentLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionCommentLegacyRequestWithBody(c.Server, teamId, discussionNumber, commentNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionCommentLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionCommentLegacyRequest(c.Server, teamId, discussionNumber, commentNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionslistForTeamDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionslistForTeamDiscussionLegacyRequest(c.Server, teamId, discussionNumber, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionLegacyWithBody(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionLegacyRequestWithBody(c.Server, teamId, discussionNumber, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReactionscreateForTeamDiscussionLegacy(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReactionscreateForTeamDiscussionLegacyRequest(c.Server, teamId, discussionNumber, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistPendingInvitationsLegacy(ctx context.Context, teamId TeamId, params *TeamslistPendingInvitationsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistPendingInvitationsLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistMembersLegacy(ctx context.Context, teamId TeamId, params *TeamslistMembersLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistMembersLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveMemberLegacyRequest(c.Server, teamId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetMemberLegacyRequest(c.Server, teamId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddMemberLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddMemberLegacyRequest(c.Server, teamId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveMembershipForUserLegacyRequest(c.Server, teamId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsgetMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsgetMembershipForUserLegacyRequest(c.Server, teamId, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateMembershipForUserLegacyWithBody(ctx context.Context, teamId TeamId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateMembershipForUserLegacyRequestWithBody(c.Server, teamId, username, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateMembershipForUserLegacy(ctx context.Context, teamId TeamId, username Username, body TeamsaddOrUpdateMembershipForUserLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateMembershipForUserLegacyRequest(c.Server, teamId, username, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistProjectsLegacy(ctx context.Context, teamId TeamId, params *TeamslistProjectsLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistProjectsLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveProjectLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveProjectLegacyRequest(c.Server, teamId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscheckPermissionsForProjectLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscheckPermissionsForProjectLegacyRequest(c.Server, teamId, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateProjectPermissionsLegacyWithBody(ctx context.Context, teamId TeamId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateProjectPermissionsLegacyRequestWithBody(c.Server, teamId, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateProjectPermissionsLegacy(ctx context.Context, teamId TeamId, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateProjectPermissionsLegacyRequest(c.Server, teamId, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistReposLegacy(ctx context.Context, teamId TeamId, params *TeamslistReposLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistReposLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsremoveRepoLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsremoveRepoLegacyRequest(c.Server, teamId, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscheckPermissionsForRepoLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscheckPermissionsForRepoLegacyRequest(c.Server, teamId, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateRepoPermissionsLegacyWithBody(ctx context.Context, teamId TeamId, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateRepoPermissionsLegacyRequestWithBody(c.Server, teamId, owner, repo, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamsaddOrUpdateRepoPermissionsLegacy(ctx context.Context, teamId TeamId, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamsaddOrUpdateRepoPermissionsLegacyRequest(c.Server, teamId, owner, repo, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistIdpGroupsForLegacy(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistIdpGroupsForLegacyRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBody(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamscreateOrUpdateIdpGroupConnectionsLegacy(ctx context.Context, teamId TeamId, body TeamscreateOrUpdateIdpGroupConnectionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequest(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistChildLegacy(ctx context.Context, teamId TeamId, params *TeamslistChildLegacyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistChildLegacyRequest(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersgetAuthenticated(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersgetAuthenticatedRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersupdateAuthenticatedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersupdateAuthenticatedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersupdateAuthenticated(ctx context.Context, body UsersupdateAuthenticatedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersupdateAuthenticatedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistBlockedByAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistBlockedByAuthenticatedUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usersunblock(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersunblockRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscheckBlocked(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscheckBlockedRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usersblock(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersblockRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistForAuthenticatedUser(ctx context.Context, params *CodespaceslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateForAuthenticatedUser(ctx context.Context, body CodespacescreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistSecretsForAuthenticatedUser(ctx context.Context, params *CodespaceslistSecretsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistSecretsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetPublicKeyForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetPublicKeyForAuthenticatedUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesdeleteSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesdeleteSecretForAuthenticatedUserRequest(c.Server, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetSecretForAuthenticatedUserRequest(c.Server, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateOrUpdateSecretForAuthenticatedUserWithBody(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequestWithBody(c.Server, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescreateOrUpdateSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, body CodespacescreateOrUpdateSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequest(c.Server, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespaceslistRepositoriesForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespaceslistRepositoriesForSecretForAuthenticatedUserRequest(c.Server, secretName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacessetRepositoriesForSecretForAuthenticatedUserWithBody(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequestWithBody(c.Server, secretName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacessetRepositoriesForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, body CodespacessetRepositoriesForSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequest(c.Server, secretName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesremoveRepositoryForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesremoveRepositoryForSecretForAuthenticatedUserRequest(c.Server, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesaddRepositoryForSecretForAuthenticatedUser(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesaddRepositoryForSecretForAuthenticatedUserRequest(c.Server, secretName, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesdeleteForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesdeleteForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesupdateForAuthenticatedUserWithBody(ctx context.Context, codespaceName CodespaceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesupdateForAuthenticatedUserRequestWithBody(c.Server, codespaceName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesupdateForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, body CodespacesupdateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesupdateForAuthenticatedUserRequest(c.Server, codespaceName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesexportForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesexportForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesgetExportDetailsForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, exportId ExportId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesgetExportDetailsForAuthenticatedUserRequest(c.Server, codespaceName, exportId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacescodespaceMachinesForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacescodespaceMachinesForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesstartForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesstartForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CodespacesstopForAuthenticatedUser(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCodespacesstopForAuthenticatedUserRequest(c.Server, codespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserssetPrimaryEmailVisibilityForAuthenticatedUser(ctx context.Context, body UserssetPrimaryEmailVisibilityForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersdeleteEmailForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersdeleteEmailForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersdeleteEmailForAuthenticatedUser(ctx context.Context, body UsersdeleteEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersdeleteEmailForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistEmailsForAuthenticatedUser(ctx context.Context, params *UserslistEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistEmailsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersaddEmailForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersaddEmailForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersaddEmailForAuthenticatedUser(ctx context.Context, body UsersaddEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersaddEmailForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistFollowersForAuthenticatedUser(ctx context.Context, params *UserslistFollowersForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistFollowersForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistFollowedByAuthenticatedUser(ctx context.Context, params *UserslistFollowedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistFollowedByAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usersunfollow(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersunfollowRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscheckPersonIsFollowedByAuthenticated(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscheckPersonIsFollowedByAuthenticatedRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Usersfollow(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersfollowRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistGpgKeysForAuthenticatedUser(ctx context.Context, params *UserslistGpgKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistGpgKeysForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscreateGpgKeyForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscreateGpgKeyForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscreateGpgKeyForAuthenticatedUser(ctx context.Context, body UserscreateGpgKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscreateGpgKeyForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersdeleteGpgKeyForAuthenticatedUser(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersdeleteGpgKeyForAuthenticatedUserRequest(c.Server, gpgKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersgetGpgKeyForAuthenticatedUser(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersgetGpgKeyForAuthenticatedUserRequest(c.Server, gpgKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistInstallationsForAuthenticatedUser(ctx context.Context, params *AppslistInstallationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistInstallationsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistInstallationReposForAuthenticatedUser(ctx context.Context, installationId InstallationId, params *AppslistInstallationReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistInstallationReposForAuthenticatedUserRequest(c.Server, installationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsremoveRepoFromInstallationForAuthenticatedUser(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsremoveRepoFromInstallationForAuthenticatedUserRequest(c.Server, installationId, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsaddRepoToInstallationForAuthenticatedUser(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsaddRepoToInstallationForAuthenticatedUserRequest(c.Server, installationId, repositoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsremoveRestrictionsForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsremoveRestrictionsForAuthenticatedUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionsgetRestrictionsForAuthenticatedUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionsgetRestrictionsForAuthenticatedUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InteractionssetRestrictionsForAuthenticatedUser(ctx context.Context, body InteractionssetRestrictionsForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInteractionssetRestrictionsForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IssueslistForAuthenticatedUser(ctx context.Context, params *IssueslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssueslistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistPublicSshKeysForAuthenticatedUser(ctx context.Context, params *UserslistPublicSshKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistPublicSshKeysForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscreatePublicSshKeyForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscreatePublicSshKeyForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscreatePublicSshKeyForAuthenticatedUser(ctx context.Context, body UserscreatePublicSshKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscreatePublicSshKeyForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersdeletePublicSshKeyForAuthenticatedUser(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersdeletePublicSshKeyForAuthenticatedUserRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersgetPublicSshKeyForAuthenticatedUser(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersgetPublicSshKeyForAuthenticatedUserRequest(c.Server, keyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistSubscriptionsForAuthenticatedUser(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistSubscriptionsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppslistSubscriptionsForAuthenticatedUserStubbed(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserStubbedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppslistSubscriptionsForAuthenticatedUserStubbedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistMembershipsForAuthenticatedUser(ctx context.Context, params *OrgslistMembershipsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistMembershipsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsgetMembershipForAuthenticatedUser(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsgetMembershipForAuthenticatedUserRequest(c.Server, org)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateMembershipForAuthenticatedUserWithBody(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateMembershipForAuthenticatedUserRequestWithBody(c.Server, org, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgsupdateMembershipForAuthenticatedUser(ctx context.Context, org Org, body OrgsupdateMembershipForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgsupdateMembershipForAuthenticatedUserRequest(c.Server, org, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationslistForAuthenticatedUser(ctx context.Context, params *MigrationslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationslistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsstartForAuthenticatedUser(ctx context.Context, body MigrationsstartForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsstartForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetStatusForAuthenticatedUser(ctx context.Context, migrationId MigrationId, params *MigrationsgetStatusForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetStatusForAuthenticatedUserRequest(c.Server, migrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsdeleteArchiveForAuthenticatedUser(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsdeleteArchiveForAuthenticatedUserRequest(c.Server, migrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsgetArchiveForAuthenticatedUser(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsgetArchiveForAuthenticatedUserRequest(c.Server, migrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationsunlockRepoForAuthenticatedUser(ctx context.Context, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationsunlockRepoForAuthenticatedUserRequest(c.Server, migrationId, repoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MigrationslistReposForAuthenticatedUser(ctx context.Context, migrationId MigrationId, params *MigrationslistReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMigrationslistReposForAuthenticatedUserRequest(c.Server, migrationId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistForAuthenticatedUser(ctx context.Context, params *OrgslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackageslistPackagesForAuthenticatedUser(ctx context.Context, params *PackageslistPackagesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackageslistPackagesForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageForAuthenticatedUser(ctx context.Context, packageType PackagesdeletePackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageForAuthenticatedUserRequest(c.Server, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageForAuthenticatedUser(ctx context.Context, packageType PackagesgetPackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageForAuthenticatedUserRequest(c.Server, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageForAuthenticatedUser(ctx context.Context, packageType PackagesrestorePackageForAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageForAuthenticatedUserRequest(c.Server, packageType, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx context.Context, packageType PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(c.Server, packageType, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesdeletePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageVersionForAuthenticatedUserRequest(c.Server, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesgetPackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageVersionForAuthenticatedUserRequest(c.Server, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageVersionForAuthenticatedUser(ctx context.Context, packageType PackagesrestorePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageVersionForAuthenticatedUserRequest(c.Server, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectscreateForAuthenticatedUser(ctx context.Context, body ProjectscreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectscreateForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistPublicEmailsForAuthenticatedUser(ctx context.Context, params *UserslistPublicEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistPublicEmailsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistForAuthenticatedUser(ctx context.Context, params *ReposlistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateForAuthenticatedUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateForAuthenticatedUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposcreateForAuthenticatedUser(ctx context.Context, body ReposcreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposcreateForAuthenticatedUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistInvitationsForAuthenticatedUser(ctx context.Context, params *ReposlistInvitationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistInvitationsForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposdeclineInvitationForAuthenticatedUser(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposdeclineInvitationForAuthenticatedUserRequest(c.Server, invitationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposacceptInvitationForAuthenticatedUser(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposacceptInvitationForAuthenticatedUserRequest(c.Server, invitationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistReposStarredByAuthenticatedUser(ctx context.Context, params *ActivitylistReposStarredByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistReposStarredByAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivityunstarRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivityunstarRepoForAuthenticatedUserRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitycheckRepoIsStarredByAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitycheckRepoIsStarredByAuthenticatedUserRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitystarRepoForAuthenticatedUser(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitystarRepoForAuthenticatedUserRequest(c.Server, owner, repo)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistWatchedReposForAuthenticatedUser(ctx context.Context, params *ActivitylistWatchedReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistWatchedReposForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TeamslistForAuthenticatedUser(ctx context.Context, params *TeamslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTeamslistForAuthenticatedUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Userslist(ctx context.Context, params *UserslistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersgetByUsername(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersgetByUsernameRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistEventsForAuthenticatedUser(ctx context.Context, username Username, params *ActivitylistEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistEventsForAuthenticatedUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistOrgEventsForAuthenticatedUser(ctx context.Context, username Username, org Org, params *ActivitylistOrgEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistOrgEventsForAuthenticatedUserRequest(c.Server, username, org, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistPublicEventsForUser(ctx context.Context, username Username, params *ActivitylistPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistPublicEventsForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistFollowersForUser(ctx context.Context, username Username, params *UserslistFollowersForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistFollowersForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistFollowingForUser(ctx context.Context, username Username, params *UserslistFollowingForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistFollowingForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserscheckFollowingForUser(ctx context.Context, username Username, targetUser string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserscheckFollowingForUserRequest(c.Server, username, targetUser)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GistslistForUser(ctx context.Context, username Username, params *GistslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGistslistForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistGpgKeysForUser(ctx context.Context, username Username, params *UserslistGpgKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistGpgKeysForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UsersgetContextForUser(ctx context.Context, username Username, params *UsersgetContextForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersgetContextForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AppsgetUserInstallation(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAppsgetUserInstallationRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserslistPublicKeysForUser(ctx context.Context, username Username, params *UserslistPublicKeysForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserslistPublicKeysForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) OrgslistForUser(ctx context.Context, username Username, params *OrgslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewOrgslistForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackageslistPackagesForUser(ctx context.Context, username Username, params *PackageslistPackagesForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackageslistPackagesForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageForUser(ctx context.Context, username Username, packageType PackagesdeletePackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageForUserRequest(c.Server, username, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageForUser(ctx context.Context, username Username, packageType PackagesgetPackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageForUserRequest(c.Server, username, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageForUser(ctx context.Context, username Username, packageType PackagesrestorePackageForUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageForUserRequest(c.Server, username, packageType, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetAllPackageVersionsForPackageOwnedByUser(ctx context.Context, username Username, packageType PackagesgetAllPackageVersionsForPackageOwnedByUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetAllPackageVersionsForPackageOwnedByUserRequest(c.Server, username, packageType, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesdeletePackageVersionForUser(ctx context.Context, username Username, packageType PackagesdeletePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesdeletePackageVersionForUserRequest(c.Server, username, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesgetPackageVersionForUser(ctx context.Context, username Username, packageType PackagesgetPackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesgetPackageVersionForUserRequest(c.Server, username, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PackagesrestorePackageVersionForUser(ctx context.Context, username Username, packageType PackagesrestorePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPackagesrestorePackageVersionForUserRequest(c.Server, username, packageType, packageName, packageVersionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProjectslistForUser(ctx context.Context, username Username, params *ProjectslistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectslistForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistReceivedEventsForUser(ctx context.Context, username Username, params *ActivitylistReceivedEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistReceivedEventsForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistReceivedPublicEventsForUser(ctx context.Context, username Username, params *ActivitylistReceivedPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistReceivedPublicEventsForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReposlistForUser(ctx context.Context, username Username, params *ReposlistForUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReposlistForUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubActionsBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubActionsBillingUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetGithubPackagesBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetGithubPackagesBillingUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BillinggetSharedStorageBillingUser(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBillinggetSharedStorageBillingUserRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistReposStarredByUser(ctx context.Context, username Username, params *ActivitylistReposStarredByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistReposStarredByUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ActivitylistReposWatchedByUser(ctx context.Context, username Username, params *ActivitylistReposWatchedByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewActivitylistReposWatchedByUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MetagetZen(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMetagetZenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewMetarootRequest generates requests for Metaroot
func NewMetarootRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetAuthenticatedRequest generates requests for AppsgetAuthenticated
func NewAppsgetAuthenticatedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppscreateFromManifestRequest generates requests for AppscreateFromManifest
func NewAppscreateFromManifestRequest(server string, code string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-manifests/%s/conversions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetWebhookConfigForAppRequest generates requests for AppsgetWebhookConfigForApp
func NewAppsgetWebhookConfigForAppRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/hook/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsupdateWebhookConfigForAppRequest calls the generic AppsupdateWebhookConfigForApp builder with application/json body
func NewAppsupdateWebhookConfigForAppRequest(server string, body AppsupdateWebhookConfigForAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsupdateWebhookConfigForAppRequestWithBody(server, "application/json", bodyReader)
}

// NewAppsupdateWebhookConfigForAppRequestWithBody generates requests for AppsupdateWebhookConfigForApp with any type of body
func NewAppsupdateWebhookConfigForAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/hook/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppslistWebhookDeliveriesRequest generates requests for AppslistWebhookDeliveries
func NewAppslistWebhookDeliveriesRequest(server string, params *AppslistWebhookDeliveriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/hook/deliveries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetWebhookDeliveryRequest generates requests for AppsgetWebhookDelivery
func NewAppsgetWebhookDeliveryRequest(server string, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/hook/deliveries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsredeliverWebhookDeliveryRequest generates requests for AppsredeliverWebhookDelivery
func NewAppsredeliverWebhookDeliveryRequest(server string, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/hook/deliveries/%s/attempts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistInstallationsRequest generates requests for AppslistInstallations
func NewAppslistInstallationsRequest(server string, params *AppslistInstallationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Outdated != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "outdated", runtime.ParamLocationQuery, *params.Outdated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsdeleteInstallationRequest generates requests for AppsdeleteInstallation
func NewAppsdeleteInstallationRequest(server string, installationId InstallationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetInstallationRequest generates requests for AppsgetInstallation
func NewAppsgetInstallationRequest(server string, installationId InstallationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppscreateInstallationAccessTokenRequest calls the generic AppscreateInstallationAccessToken builder with application/json body
func NewAppscreateInstallationAccessTokenRequest(server string, installationId InstallationId, body AppscreateInstallationAccessTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppscreateInstallationAccessTokenRequestWithBody(server, installationId, "application/json", bodyReader)
}

// NewAppscreateInstallationAccessTokenRequestWithBody generates requests for AppscreateInstallationAccessToken with any type of body
func NewAppscreateInstallationAccessTokenRequestWithBody(server string, installationId InstallationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations/%s/access_tokens", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsunsuspendInstallationRequest generates requests for AppsunsuspendInstallation
func NewAppsunsuspendInstallationRequest(server string, installationId InstallationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations/%s/suspended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppssuspendInstallationRequest generates requests for AppssuspendInstallation
func NewAppssuspendInstallationRequest(server string, installationId InstallationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/installations/%s/suspended", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationslistGrantsRequest generates requests for OauthAuthorizationslistGrants
func NewOauthAuthorizationslistGrantsRequest(server string, params *OauthAuthorizationslistGrantsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/grants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ClientId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationsdeleteGrantRequest generates requests for OauthAuthorizationsdeleteGrant
func NewOauthAuthorizationsdeleteGrantRequest(server string, grantId GrantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grant_id", runtime.ParamLocationPath, grantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationsgetGrantRequest generates requests for OauthAuthorizationsgetGrant
func NewOauthAuthorizationsgetGrantRequest(server string, grantId GrantId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "grant_id", runtime.ParamLocationPath, grantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/grants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsdeleteAuthorizationRequest calls the generic AppsdeleteAuthorization builder with application/json body
func NewAppsdeleteAuthorizationRequest(server string, clientId ClientId, body AppsdeleteAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsdeleteAuthorizationRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewAppsdeleteAuthorizationRequestWithBody generates requests for AppsdeleteAuthorization with any type of body
func NewAppsdeleteAuthorizationRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/grant", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsdeleteTokenRequest calls the generic AppsdeleteToken builder with application/json body
func NewAppsdeleteTokenRequest(server string, clientId ClientId, body AppsdeleteTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsdeleteTokenRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewAppsdeleteTokenRequestWithBody generates requests for AppsdeleteToken with any type of body
func NewAppsdeleteTokenRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsresetTokenRequest calls the generic AppsresetToken builder with application/json body
func NewAppsresetTokenRequest(server string, clientId ClientId, body AppsresetTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsresetTokenRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewAppsresetTokenRequestWithBody generates requests for AppsresetToken with any type of body
func NewAppsresetTokenRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppscheckTokenRequest calls the generic AppscheckToken builder with application/json body
func NewAppscheckTokenRequest(server string, clientId ClientId, body AppscheckTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppscheckTokenRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewAppscheckTokenRequestWithBody generates requests for AppscheckToken with any type of body
func NewAppscheckTokenRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsscopeTokenRequest calls the generic AppsscopeToken builder with application/json body
func NewAppsscopeTokenRequest(server string, clientId ClientId, body AppsscopeTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAppsscopeTokenRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewAppsscopeTokenRequestWithBody generates requests for AppsscopeToken with any type of body
func NewAppsscopeTokenRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/applications/%s/token/scoped", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsgetBySlugRequest generates requests for AppsgetBySlug
func NewAppsgetBySlugRequest(server string, appSlug AppSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_slug", runtime.ParamLocationPath, appSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationslistAuthorizationsRequest generates requests for OauthAuthorizationslistAuthorizations
func NewOauthAuthorizationslistAuthorizationsRequest(server string, params *OauthAuthorizationslistAuthorizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ClientId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, *params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationscreateAuthorizationRequest calls the generic OauthAuthorizationscreateAuthorization builder with application/json body
func NewOauthAuthorizationscreateAuthorizationRequest(server string, body OauthAuthorizationscreateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthAuthorizationscreateAuthorizationRequestWithBody(server, "application/json", bodyReader)
}

// NewOauthAuthorizationscreateAuthorizationRequestWithBody generates requests for OauthAuthorizationscreateAuthorization with any type of body
func NewOauthAuthorizationscreateAuthorizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequest calls the generic OauthAuthorizationsgetOrCreateAuthorizationForApp builder with application/json body
func NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequest(server string, clientId ClientId, body OauthAuthorizationsgetOrCreateAuthorizationForAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequestWithBody(server, clientId, "application/json", bodyReader)
}

// NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequestWithBody generates requests for OauthAuthorizationsgetOrCreateAuthorizationForApp with any type of body
func NewOauthAuthorizationsgetOrCreateAuthorizationForAppRequestWithBody(server string, clientId ClientId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/clients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequest calls the generic OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint builder with application/json body
func NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequest(server string, clientId ClientId, fingerprint string, body OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequestWithBody(server, clientId, fingerprint, "application/json", bodyReader)
}

// NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequestWithBody generates requests for OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint with any type of body
func NewOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintRequestWithBody(server string, clientId ClientId, fingerprint string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client_id", runtime.ParamLocationPath, clientId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "fingerprint", runtime.ParamLocationPath, fingerprint)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/clients/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOauthAuthorizationsdeleteAuthorizationRequest generates requests for OauthAuthorizationsdeleteAuthorization
func NewOauthAuthorizationsdeleteAuthorizationRequest(server string, authorizationId AuthorizationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization_id", runtime.ParamLocationPath, authorizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationsgetAuthorizationRequest generates requests for OauthAuthorizationsgetAuthorization
func NewOauthAuthorizationsgetAuthorizationRequest(server string, authorizationId AuthorizationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization_id", runtime.ParamLocationPath, authorizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOauthAuthorizationsupdateAuthorizationRequest calls the generic OauthAuthorizationsupdateAuthorization builder with application/json body
func NewOauthAuthorizationsupdateAuthorizationRequest(server string, authorizationId AuthorizationId, body OauthAuthorizationsupdateAuthorizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOauthAuthorizationsupdateAuthorizationRequestWithBody(server, authorizationId, "application/json", bodyReader)
}

// NewOauthAuthorizationsupdateAuthorizationRequestWithBody generates requests for OauthAuthorizationsupdateAuthorization with any type of body
func NewOauthAuthorizationsupdateAuthorizationRequestWithBody(server string, authorizationId AuthorizationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "authorization_id", runtime.ParamLocationPath, authorizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/authorizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodesOfConductgetAllCodesOfConductRequest generates requests for CodesOfConductgetAllCodesOfConduct
func NewCodesOfConductgetAllCodesOfConductRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/codes_of_conduct")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodesOfConductgetConductCodeRequest generates requests for CodesOfConductgetConductCode
func NewCodesOfConductgetConductCodeRequest(server string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/codes_of_conduct/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEmojisgetRequest generates requests for Emojisget
func NewEmojisgetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/emojis")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetServerStatisticsRequest generates requests for EnterpriseAdmingetServerStatistics
func NewEnterpriseAdmingetServerStatisticsRequest(server string, enterpriseOrOrg EnterpriseOrOrg, params *EnterpriseAdmingetServerStatisticsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise_or_org", runtime.ParamLocationPath, enterpriseOrOrg)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprise-installation/%s/server-statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.DateStart != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_start", runtime.ParamLocationQuery, *params.DateStart); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DateEnd != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "date_end", runtime.ParamLocationQuery, *params.DateEnd); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetActionsCacheUsageForEnterpriseRequest generates requests for ActionsgetActionsCacheUsageForEnterprise
func NewActionsgetActionsCacheUsageForEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/cache/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetGithubActionsPermissionsEnterpriseRequest generates requests for EnterpriseAdmingetGithubActionsPermissionsEnterprise
func NewEnterpriseAdmingetGithubActionsPermissionsEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequest calls the generic EnterpriseAdminsetGithubActionsPermissionsEnterprise builder with application/json body
func NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequest(server string, enterprise Enterprise, body EnterpriseAdminsetGithubActionsPermissionsEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequestWithBody generates requests for EnterpriseAdminsetGithubActionsPermissionsEnterprise with any type of body
func NewEnterpriseAdminsetGithubActionsPermissionsEnterpriseRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseRequest generates requests for EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise
func NewEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(server string, enterprise Enterprise, params *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/organizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest calls the generic EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise builder with application/json body
func NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest(server string, enterprise Enterprise, body EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestWithBody generates requests for EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise with any type of body
func NewEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/organizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseRequest generates requests for EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise
func NewEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseRequest(server string, enterprise Enterprise, orgId OrgId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/organizations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseRequest generates requests for EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise
func NewEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseRequest(server string, enterprise Enterprise, orgId OrgId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/organizations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetAllowedActionsEnterpriseRequest generates requests for EnterpriseAdmingetAllowedActionsEnterprise
func NewEnterpriseAdmingetAllowedActionsEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/selected-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminsetAllowedActionsEnterpriseRequest calls the generic EnterpriseAdminsetAllowedActionsEnterprise builder with application/json body
func NewEnterpriseAdminsetAllowedActionsEnterpriseRequest(server string, enterprise Enterprise, body EnterpriseAdminsetAllowedActionsEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetAllowedActionsEnterpriseRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdminsetAllowedActionsEnterpriseRequestWithBody generates requests for EnterpriseAdminsetAllowedActionsEnterprise with any type of body
func NewEnterpriseAdminsetAllowedActionsEnterpriseRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/selected-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest generates requests for ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise
func NewActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/workflow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest calls the generic ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise builder with application/json body
func NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest(server string, enterprise Enterprise, body ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestWithBody generates requests for ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise with any type of body
func NewActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/permissions/workflow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseRequest generates requests for EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise
func NewEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseRequest(server string, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleToOrganization != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visible_to_organization", runtime.ParamLocationQuery, *params.VisibleToOrganization); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequest calls the generic EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise builder with application/json body
func NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequest(server string, enterprise Enterprise, body EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequestWithBody generates requests for EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise with any type of body
func NewEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseRequest generates requests for EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise
func NewEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseRequest generates requests for EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise
func NewEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequest calls the generic EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise builder with application/json body
func NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequestWithBody(server, enterprise, runnerGroupId, "application/json", bodyReader)
}

// NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequestWithBody generates requests for EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise with any type of body
func NewEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseRequestWithBody(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest generates requests for EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise
func NewEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/organizations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest calls the generic EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise builder with application/json body
func NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestWithBody(server, enterprise, runnerGroupId, "application/json", bodyReader)
}

// NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestWithBody generates requests for EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise with any type of body
func NewEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestWithBody(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/organizations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest generates requests for EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise
func NewEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/organizations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest generates requests for EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise
func NewEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/organizations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseRequest generates requests for EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise
func NewEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/runners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequest calls the generic EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise builder with application/json body
func NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequestWithBody(server, enterprise, runnerGroupId, "application/json", bodyReader)
}

// NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequestWithBody generates requests for EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise with any type of body
func NewEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseRequestWithBody(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/runners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseRequest generates requests for EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise
func NewEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseRequest generates requests for EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise
func NewEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseRequest(server string, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runner-groups/%s/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminlistSelfHostedRunnersForEnterpriseRequest generates requests for EnterpriseAdminlistSelfHostedRunnersForEnterprise
func NewEnterpriseAdminlistSelfHostedRunnersForEnterpriseRequest(server string, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnersForEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminlistRunnerApplicationsForEnterpriseRequest generates requests for EnterpriseAdminlistRunnerApplicationsForEnterprise
func NewEnterpriseAdminlistRunnerApplicationsForEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/downloads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmincreateRegistrationTokenForEnterpriseRequest generates requests for EnterpriseAdmincreateRegistrationTokenForEnterprise
func NewEnterpriseAdmincreateRegistrationTokenForEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/registration-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmincreateRemoveTokenForEnterpriseRequest generates requests for EnterpriseAdmincreateRemoveTokenForEnterprise
func NewEnterpriseAdmincreateRemoveTokenForEnterpriseRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/remove-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseRequest generates requests for EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise
func NewEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetSelfHostedRunnerForEnterpriseRequest generates requests for EnterpriseAdmingetSelfHostedRunnerForEnterprise
func NewEnterpriseAdmingetSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest generates requests for EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise
func NewEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseRequest generates requests for EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise
func NewEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequest calls the generic EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise builder with application/json body
func NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequestWithBody(server, enterprise, runnerId, "application/json", bodyReader)
}

// NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequestWithBody generates requests for EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise with any type of body
func NewEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseRequestWithBody(server string, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequest calls the generic EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise builder with application/json body
func NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequestWithBody(server, enterprise, runnerId, "application/json", bodyReader)
}

// NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequestWithBody generates requests for EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise with any type of body
func NewEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseRequestWithBody(server string, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest generates requests for EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise
func NewEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest(server string, enterprise Enterprise, runnerId RunnerId, name RunnerLabelName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/actions/runners/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetAuditLogRequest generates requests for EnterpriseAdmingetAuditLog
func NewEnterpriseAdmingetAuditLogRequest(server string, enterprise Enterprise, params *EnterpriseAdmingetAuditLogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/audit-log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Phrase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phrase", runtime.ParamLocationQuery, *params.Phrase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretScanninglistAlertsForEnterpriseRequest generates requests for SecretScanninglistAlertsForEnterprise
func NewSecretScanninglistAlertsForEnterpriseRequest(server string, enterprise Enterprise, params *SecretScanninglistAlertsForEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/secret-scanning/alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SecretType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_type", runtime.ParamLocationQuery, *params.SecretType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resolution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubActionsBillingGheRequest generates requests for BillinggetGithubActionsBillingGhe
func NewBillinggetGithubActionsBillingGheRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/settings/billing/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubAdvancedSecurityBillingGheRequest generates requests for BillinggetGithubAdvancedSecurityBillingGhe
func NewBillinggetGithubAdvancedSecurityBillingGheRequest(server string, enterprise Enterprise, params *BillinggetGithubAdvancedSecurityBillingGheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/settings/billing/advanced-security", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubPackagesBillingGheRequest generates requests for BillinggetGithubPackagesBillingGhe
func NewBillinggetGithubPackagesBillingGheRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/settings/billing/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetSharedStorageBillingGheRequest generates requests for BillinggetSharedStorageBillingGhe
func NewBillinggetSharedStorageBillingGheRequest(server string, enterprise Enterprise) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/enterprises/%s/settings/billing/shared-storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistPublicEventsRequest generates requests for ActivitylistPublicEvents
func NewActivitylistPublicEventsRequest(server string, params *ActivitylistPublicEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitygetFeedsRequest generates requests for ActivitygetFeeds
func NewActivitygetFeedsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feeds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistslistRequest generates requests for Gistslist
func NewGistslistRequest(server string, params *GistslistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistscreateRequest calls the generic Gistscreate builder with application/json body
func NewGistscreateRequest(server string, body GistscreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGistscreateRequestWithBody(server, "application/json", bodyReader)
}

// NewGistscreateRequestWithBody generates requests for Gistscreate with any type of body
func NewGistscreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGistslistPublicRequest generates requests for GistslistPublic
func NewGistslistPublicRequest(server string, params *GistslistPublicParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistslistStarredRequest generates requests for GistslistStarred
func NewGistslistStarredRequest(server string, params *GistslistStarredParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/starred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsdeleteRequest generates requests for Gistsdelete
func NewGistsdeleteRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsgetRequest generates requests for Gistsget
func NewGistsgetRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsupdateRequest calls the generic Gistsupdate builder with application/json body
func NewGistsupdateRequest(server string, gistId GistId, body GistsupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGistsupdateRequestWithBody(server, gistId, "application/json", bodyReader)
}

// NewGistsupdateRequestWithBody generates requests for Gistsupdate with any type of body
func NewGistsupdateRequestWithBody(server string, gistId GistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGistslistCommentsRequest generates requests for GistslistComments
func NewGistslistCommentsRequest(server string, gistId GistId, params *GistslistCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistscreateCommentRequest calls the generic GistscreateComment builder with application/json body
func NewGistscreateCommentRequest(server string, gistId GistId, body GistscreateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGistscreateCommentRequestWithBody(server, gistId, "application/json", bodyReader)
}

// NewGistscreateCommentRequestWithBody generates requests for GistscreateComment with any type of body
func NewGistscreateCommentRequestWithBody(server string, gistId GistId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGistsdeleteCommentRequest generates requests for GistsdeleteComment
func NewGistsdeleteCommentRequest(server string, gistId GistId, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsgetCommentRequest generates requests for GistsgetComment
func NewGistsgetCommentRequest(server string, gistId GistId, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsupdateCommentRequest calls the generic GistsupdateComment builder with application/json body
func NewGistsupdateCommentRequest(server string, gistId GistId, commentId CommentId, body GistsupdateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGistsupdateCommentRequestWithBody(server, gistId, commentId, "application/json", bodyReader)
}

// NewGistsupdateCommentRequestWithBody generates requests for GistsupdateComment with any type of body
func NewGistsupdateCommentRequestWithBody(server string, gistId GistId, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/comments/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGistslistCommitsRequest generates requests for GistslistCommits
func NewGistslistCommitsRequest(server string, gistId GistId, params *GistslistCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistslistForksRequest generates requests for GistslistForks
func NewGistslistForksRequest(server string, gistId GistId, params *GistslistForksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/forks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsforkRequest generates requests for Gistsfork
func NewGistsforkRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/forks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsunstarRequest generates requests for Gistsunstar
func NewGistsunstarRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistscheckIsStarredRequest generates requests for GistscheckIsStarred
func NewGistscheckIsStarredRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsstarRequest generates requests for Gistsstar
func NewGistsstarRequest(server string, gistId GistId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/star", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistsgetRevisionRequest generates requests for GistsgetRevision
func NewGistsgetRevisionRequest(server string, gistId GistId, sha string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gist_id", runtime.ParamLocationPath, gistId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "sha", runtime.ParamLocationPath, sha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gists/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitignoregetAllTemplatesRequest generates requests for GitignoregetAllTemplates
func NewGitignoregetAllTemplatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gitignore/templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitignoregetTemplateRequest generates requests for GitignoregetTemplate
func NewGitignoregetTemplateRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gitignore/templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistReposAccessibleToInstallationRequest generates requests for AppslistReposAccessibleToInstallation
func NewAppslistReposAccessibleToInstallationRequest(server string, params *AppslistReposAccessibleToInstallationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsrevokeInstallationAccessTokenRequest generates requests for AppsrevokeInstallationAccessToken
func NewAppsrevokeInstallationAccessTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistRequest generates requests for Issueslist
func NewIssueslistRequest(server string, params *IssueslistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Labels != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Collab != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "collab", runtime.ParamLocationQuery, *params.Collab); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Orgs != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgs", runtime.ParamLocationQuery, *params.Orgs); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Owned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "owned", runtime.ParamLocationQuery, *params.Owned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pulls != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pulls", runtime.ParamLocationQuery, *params.Pulls); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLicensesgetAllCommonlyUsedRequest generates requests for LicensesgetAllCommonlyUsed
func NewLicensesgetAllCommonlyUsedRequest(server string, params *LicensesgetAllCommonlyUsedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/licenses")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Featured != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featured", runtime.ParamLocationQuery, *params.Featured); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLicensesgetRequest generates requests for Licensesget
func NewLicensesgetRequest(server string, license string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "license", runtime.ParamLocationPath, license)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/licenses/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMarkdownrenderRequest calls the generic Markdownrender builder with application/json body
func NewMarkdownrenderRequest(server string, body MarkdownrenderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMarkdownrenderRequestWithBody(server, "application/json", bodyReader)
}

// NewMarkdownrenderRequestWithBody generates requests for Markdownrender with any type of body
func NewMarkdownrenderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMarkdownrenderRawRequestWithBody generates requests for MarkdownrenderRaw with any type of body
func NewMarkdownrenderRawRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/markdown/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsgetSubscriptionPlanForAccountRequest generates requests for AppsgetSubscriptionPlanForAccount
func NewAppsgetSubscriptionPlanForAccountRequest(server string, accountId AccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistPlansRequest generates requests for AppslistPlans
func NewAppslistPlansRequest(server string, params *AppslistPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistAccountsForPlanRequest generates requests for AppslistAccountsForPlan
func NewAppslistAccountsForPlanRequest(server string, planId PlanId, params *AppslistAccountsForPlanParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plan_id", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/plans/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetSubscriptionPlanForAccountStubbedRequest generates requests for AppsgetSubscriptionPlanForAccountStubbed
func NewAppsgetSubscriptionPlanForAccountStubbedRequest(server string, accountId AccountId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/stubbed/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistPlansStubbedRequest generates requests for AppslistPlansStubbed
func NewAppslistPlansStubbedRequest(server string, params *AppslistPlansStubbedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/stubbed/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistAccountsForPlanStubbedRequest generates requests for AppslistAccountsForPlanStubbed
func NewAppslistAccountsForPlanStubbedRequest(server string, planId PlanId, params *AppslistAccountsForPlanStubbedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plan_id", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/marketplace_listing/stubbed/plans/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetagetRequest generates requests for Metaget
func NewMetagetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistPublicEventsForRepoNetworkRequest generates requests for ActivitylistPublicEventsForRepoNetwork
func NewActivitylistPublicEventsForRepoNetworkRequest(server string, owner Owner, repo Repo, params *ActivitylistPublicEventsForRepoNetworkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/networks/%s/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistNotificationsForAuthenticatedUserRequest generates requests for ActivitylistNotificationsForAuthenticatedUser
func NewActivitylistNotificationsForAuthenticatedUserRequest(server string, params *ActivitylistNotificationsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Participating != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participating", runtime.ParamLocationQuery, *params.Participating); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitymarkNotificationsAsReadRequest calls the generic ActivitymarkNotificationsAsRead builder with application/json body
func NewActivitymarkNotificationsAsReadRequest(server string, body ActivitymarkNotificationsAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivitymarkNotificationsAsReadRequestWithBody(server, "application/json", bodyReader)
}

// NewActivitymarkNotificationsAsReadRequestWithBody generates requests for ActivitymarkNotificationsAsRead with any type of body
func NewActivitymarkNotificationsAsReadRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivitygetThreadRequest generates requests for ActivitygetThread
func NewActivitygetThreadRequest(server string, threadId ThreadId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitymarkThreadAsReadRequest generates requests for ActivitymarkThreadAsRead
func NewActivitymarkThreadAsReadRequest(server string, threadId ThreadId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/threads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitydeleteThreadSubscriptionRequest generates requests for ActivitydeleteThreadSubscription
func NewActivitydeleteThreadSubscriptionRequest(server string, threadId ThreadId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/threads/%s/subscription", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitygetThreadSubscriptionForAuthenticatedUserRequest generates requests for ActivitygetThreadSubscriptionForAuthenticatedUser
func NewActivitygetThreadSubscriptionForAuthenticatedUserRequest(server string, threadId ThreadId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/threads/%s/subscription", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitysetThreadSubscriptionRequest calls the generic ActivitysetThreadSubscription builder with application/json body
func NewActivitysetThreadSubscriptionRequest(server string, threadId ThreadId, body ActivitysetThreadSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivitysetThreadSubscriptionRequestWithBody(server, threadId, "application/json", bodyReader)
}

// NewActivitysetThreadSubscriptionRequestWithBody generates requests for ActivitysetThreadSubscription with any type of body
func NewActivitysetThreadSubscriptionRequestWithBody(server string, threadId ThreadId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "thread_id", runtime.ParamLocationPath, threadId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/notifications/threads/%s/subscription", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMetagetOctocatRequest generates requests for MetagetOctocat
func NewMetagetOctocatRequest(server string, params *MetagetOctocatParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/octocat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.S != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "s", runtime.ParamLocationQuery, *params.S); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistRequest generates requests for Orgslist
func NewOrgslistRequest(server string, params *OrgslistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistCustomRolesRequest generates requests for OrgslistCustomRoles
func NewOrgslistCustomRolesRequest(server string, organizationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s/custom_roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetRequest generates requests for Orgsget
func NewOrgsgetRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsupdateRequest calls the generic Orgsupdate builder with application/json body
func NewOrgsupdateRequest(server string, org Org, body OrgsupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgsupdateRequestWithBody(server, org, "application/json", bodyReader)
}

// NewOrgsupdateRequestWithBody generates requests for Orgsupdate with any type of body
func NewOrgsupdateRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetActionsCacheUsageForOrgRequest generates requests for ActionsgetActionsCacheUsageForOrg
func NewActionsgetActionsCacheUsageForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/cache/usage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetActionsCacheUsageByRepoForOrgRequest generates requests for ActionsgetActionsCacheUsageByRepoForOrg
func NewActionsgetActionsCacheUsageByRepoForOrgRequest(server string, org Org, params *ActionsgetActionsCacheUsageByRepoForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/cache/usage-by-repository", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetGithubActionsPermissionsOrganizationRequest generates requests for ActionsgetGithubActionsPermissionsOrganization
func NewActionsgetGithubActionsPermissionsOrganizationRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetGithubActionsPermissionsOrganizationRequest calls the generic ActionssetGithubActionsPermissionsOrganization builder with application/json body
func NewActionssetGithubActionsPermissionsOrganizationRequest(server string, org Org, body ActionssetGithubActionsPermissionsOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetGithubActionsPermissionsOrganizationRequestWithBody(server, org, "application/json", bodyReader)
}

// NewActionssetGithubActionsPermissionsOrganizationRequestWithBody generates requests for ActionssetGithubActionsPermissionsOrganization with any type of body
func NewActionssetGithubActionsPermissionsOrganizationRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistSelectedRepositoriesEnabledGithubActionsOrganizationRequest generates requests for ActionslistSelectedRepositoriesEnabledGithubActionsOrganization
func NewActionslistSelectedRepositoriesEnabledGithubActionsOrganizationRequest(server string, org Org, params *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequest calls the generic ActionssetSelectedRepositoriesEnabledGithubActionsOrganization builder with application/json body
func NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequest(server string, org Org, body ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequestWithBody(server, org, "application/json", bodyReader)
}

// NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequestWithBody generates requests for ActionssetSelectedRepositoriesEnabledGithubActionsOrganization with any type of body
func NewActionssetSelectedRepositoriesEnabledGithubActionsOrganizationRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsdisableSelectedRepositoryGithubActionsOrganizationRequest generates requests for ActionsdisableSelectedRepositoryGithubActionsOrganization
func NewActionsdisableSelectedRepositoryGithubActionsOrganizationRequest(server string, org Org, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsenableSelectedRepositoryGithubActionsOrganizationRequest generates requests for ActionsenableSelectedRepositoryGithubActionsOrganization
func NewActionsenableSelectedRepositoryGithubActionsOrganizationRequest(server string, org Org, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetAllowedActionsOrganizationRequest generates requests for ActionsgetAllowedActionsOrganization
func NewActionsgetAllowedActionsOrganizationRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/selected-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetAllowedActionsOrganizationRequest calls the generic ActionssetAllowedActionsOrganization builder with application/json body
func NewActionssetAllowedActionsOrganizationRequest(server string, org Org, body ActionssetAllowedActionsOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetAllowedActionsOrganizationRequestWithBody(server, org, "application/json", bodyReader)
}

// NewActionssetAllowedActionsOrganizationRequestWithBody generates requests for ActionssetAllowedActionsOrganization with any type of body
func NewActionssetAllowedActionsOrganizationRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/selected-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationRequest generates requests for ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization
func NewActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/workflow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequest calls the generic ActionssetGithubActionsDefaultWorkflowPermissionsOrganization builder with application/json body
func NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequest(server string, org Org, body ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequestWithBody(server, org, "application/json", bodyReader)
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequestWithBody generates requests for ActionssetGithubActionsDefaultWorkflowPermissionsOrganization with any type of body
func NewActionssetGithubActionsDefaultWorkflowPermissionsOrganizationRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/permissions/workflow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistSelfHostedRunnerGroupsForOrgRequest generates requests for ActionslistSelfHostedRunnerGroupsForOrg
func NewActionslistSelfHostedRunnerGroupsForOrgRequest(server string, org Org, params *ActionslistSelfHostedRunnerGroupsForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.VisibleToRepository != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visible_to_repository", runtime.ParamLocationQuery, *params.VisibleToRepository); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateSelfHostedRunnerGroupForOrgRequest calls the generic ActionscreateSelfHostedRunnerGroupForOrg builder with application/json body
func NewActionscreateSelfHostedRunnerGroupForOrgRequest(server string, org Org, body ActionscreateSelfHostedRunnerGroupForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionscreateSelfHostedRunnerGroupForOrgRequestWithBody(server, org, "application/json", bodyReader)
}

// NewActionscreateSelfHostedRunnerGroupForOrgRequestWithBody generates requests for ActionscreateSelfHostedRunnerGroupForOrg with any type of body
func NewActionscreateSelfHostedRunnerGroupForOrgRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsdeleteSelfHostedRunnerGroupFromOrgRequest generates requests for ActionsdeleteSelfHostedRunnerGroupFromOrg
func NewActionsdeleteSelfHostedRunnerGroupFromOrgRequest(server string, org Org, runnerGroupId RunnerGroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetSelfHostedRunnerGroupForOrgRequest generates requests for ActionsgetSelfHostedRunnerGroupForOrg
func NewActionsgetSelfHostedRunnerGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsupdateSelfHostedRunnerGroupForOrgRequest calls the generic ActionsupdateSelfHostedRunnerGroupForOrg builder with application/json body
func NewActionsupdateSelfHostedRunnerGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, body ActionsupdateSelfHostedRunnerGroupForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsupdateSelfHostedRunnerGroupForOrgRequestWithBody(server, org, runnerGroupId, "application/json", bodyReader)
}

// NewActionsupdateSelfHostedRunnerGroupForOrgRequestWithBody generates requests for ActionsupdateSelfHostedRunnerGroupForOrg with any type of body
func NewActionsupdateSelfHostedRunnerGroupForOrgRequestWithBody(server string, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistRepoAccessToSelfHostedRunnerGroupInOrgRequest generates requests for ActionslistRepoAccessToSelfHostedRunnerGroupInOrg
func NewActionslistRepoAccessToSelfHostedRunnerGroupInOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, params *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequest calls the generic ActionssetRepoAccessToSelfHostedRunnerGroupInOrg builder with application/json body
func NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, body ActionssetRepoAccessToSelfHostedRunnerGroupInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequestWithBody(server, org, runnerGroupId, "application/json", bodyReader)
}

// NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequestWithBody generates requests for ActionssetRepoAccessToSelfHostedRunnerGroupInOrg with any type of body
func NewActionssetRepoAccessToSelfHostedRunnerGroupInOrgRequestWithBody(server string, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgRequest generates requests for ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg
func NewActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsaddRepoAccessToSelfHostedRunnerGroupInOrgRequest generates requests for ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg
func NewActionsaddRepoAccessToSelfHostedRunnerGroupInOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistSelfHostedRunnersInGroupForOrgRequest generates requests for ActionslistSelfHostedRunnersInGroupForOrg
func NewActionslistSelfHostedRunnersInGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, params *ActionslistSelfHostedRunnersInGroupForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/runners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetSelfHostedRunnersInGroupForOrgRequest calls the generic ActionssetSelfHostedRunnersInGroupForOrg builder with application/json body
func NewActionssetSelfHostedRunnersInGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, body ActionssetSelfHostedRunnersInGroupForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetSelfHostedRunnersInGroupForOrgRequestWithBody(server, org, runnerGroupId, "application/json", bodyReader)
}

// NewActionssetSelfHostedRunnersInGroupForOrgRequestWithBody generates requests for ActionssetSelfHostedRunnersInGroupForOrg with any type of body
func NewActionssetSelfHostedRunnersInGroupForOrgRequestWithBody(server string, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/runners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsremoveSelfHostedRunnerFromGroupForOrgRequest generates requests for ActionsremoveSelfHostedRunnerFromGroupForOrg
func NewActionsremoveSelfHostedRunnerFromGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsaddSelfHostedRunnerToGroupForOrgRequest generates requests for ActionsaddSelfHostedRunnerToGroupForOrg
func NewActionsaddSelfHostedRunnerToGroupForOrgRequest(server string, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_group_id", runtime.ParamLocationPath, runnerGroupId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runner-groups/%s/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistSelfHostedRunnersForOrgRequest generates requests for ActionslistSelfHostedRunnersForOrg
func NewActionslistSelfHostedRunnersForOrgRequest(server string, org Org, params *ActionslistSelfHostedRunnersForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistRunnerApplicationsForOrgRequest generates requests for ActionslistRunnerApplicationsForOrg
func NewActionslistRunnerApplicationsForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/downloads", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateRegistrationTokenForOrgRequest generates requests for ActionscreateRegistrationTokenForOrg
func NewActionscreateRegistrationTokenForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/registration-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateRemoveTokenForOrgRequest generates requests for ActionscreateRemoveTokenForOrg
func NewActionscreateRemoveTokenForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/remove-token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteSelfHostedRunnerFromOrgRequest generates requests for ActionsdeleteSelfHostedRunnerFromOrg
func NewActionsdeleteSelfHostedRunnerFromOrgRequest(server string, org Org, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetSelfHostedRunnerForOrgRequest generates requests for ActionsgetSelfHostedRunnerForOrg
func NewActionsgetSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest generates requests for ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg
func NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistLabelsForSelfHostedRunnerForOrgRequest generates requests for ActionslistLabelsForSelfHostedRunnerForOrg
func NewActionslistLabelsForSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequest calls the generic ActionsaddCustomLabelsToSelfHostedRunnerForOrg builder with application/json body
func NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequestWithBody(server, org, runnerId, "application/json", bodyReader)
}

// NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequestWithBody generates requests for ActionsaddCustomLabelsToSelfHostedRunnerForOrg with any type of body
func NewActionsaddCustomLabelsToSelfHostedRunnerForOrgRequestWithBody(server string, org Org, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequest calls the generic ActionssetCustomLabelsForSelfHostedRunnerForOrg builder with application/json body
func NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequestWithBody(server, org, runnerId, "application/json", bodyReader)
}

// NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequestWithBody generates requests for ActionssetCustomLabelsForSelfHostedRunnerForOrg with any type of body
func NewActionssetCustomLabelsForSelfHostedRunnerForOrgRequestWithBody(server string, org Org, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsremoveCustomLabelFromSelfHostedRunnerForOrgRequest generates requests for ActionsremoveCustomLabelFromSelfHostedRunnerForOrg
func NewActionsremoveCustomLabelFromSelfHostedRunnerForOrgRequest(server string, org Org, runnerId RunnerId, name RunnerLabelName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/runners/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistOrgSecretsRequest generates requests for ActionslistOrgSecrets
func NewActionslistOrgSecretsRequest(server string, org Org, params *ActionslistOrgSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetOrgPublicKeyRequest generates requests for ActionsgetOrgPublicKey
func NewActionsgetOrgPublicKeyRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/public-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteOrgSecretRequest generates requests for ActionsdeleteOrgSecret
func NewActionsdeleteOrgSecretRequest(server string, org Org, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetOrgSecretRequest generates requests for ActionsgetOrgSecret
func NewActionsgetOrgSecretRequest(server string, org Org, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateOrUpdateOrgSecretRequest calls the generic ActionscreateOrUpdateOrgSecret builder with application/json body
func NewActionscreateOrUpdateOrgSecretRequest(server string, org Org, secretName SecretName, body ActionscreateOrUpdateOrgSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionscreateOrUpdateOrgSecretRequestWithBody(server, org, secretName, "application/json", bodyReader)
}

// NewActionscreateOrUpdateOrgSecretRequestWithBody generates requests for ActionscreateOrUpdateOrgSecret with any type of body
func NewActionscreateOrUpdateOrgSecretRequestWithBody(server string, org Org, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistSelectedReposForOrgSecretRequest generates requests for ActionslistSelectedReposForOrgSecret
func NewActionslistSelectedReposForOrgSecretRequest(server string, org Org, secretName SecretName, params *ActionslistSelectedReposForOrgSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetSelectedReposForOrgSecretRequest calls the generic ActionssetSelectedReposForOrgSecret builder with application/json body
func NewActionssetSelectedReposForOrgSecretRequest(server string, org Org, secretName SecretName, body ActionssetSelectedReposForOrgSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetSelectedReposForOrgSecretRequestWithBody(server, org, secretName, "application/json", bodyReader)
}

// NewActionssetSelectedReposForOrgSecretRequestWithBody generates requests for ActionssetSelectedReposForOrgSecret with any type of body
func NewActionssetSelectedReposForOrgSecretRequestWithBody(server string, org Org, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsremoveSelectedRepoFromOrgSecretRequest generates requests for ActionsremoveSelectedRepoFromOrgSecret
func NewActionsremoveSelectedRepoFromOrgSecretRequest(server string, org Org, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsaddSelectedRepoToOrgSecretRequest generates requests for ActionsaddSelectedRepoToOrgSecret
func NewActionsaddSelectedRepoToOrgSecretRequest(server string, org Org, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/actions/secrets/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetAuditLogRequest generates requests for OrgsgetAuditLog
func NewOrgsgetAuditLogRequest(server string, org Org, params *OrgsgetAuditLogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/audit-log", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Phrase != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "phrase", runtime.ParamLocationQuery, *params.Phrase); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Include != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistBlockedUsersRequest generates requests for OrgslistBlockedUsers
func NewOrgslistBlockedUsersRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/blocks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsunblockUserRequest generates requests for OrgsunblockUser
func NewOrgsunblockUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/blocks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgscheckBlockedUserRequest generates requests for OrgscheckBlockedUser
func NewOrgscheckBlockedUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/blocks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsblockUserRequest generates requests for OrgsblockUser
func NewOrgsblockUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/blocks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninglistAlertsForOrgRequest generates requests for CodeScanninglistAlertsForOrg
func NewCodeScanninglistAlertsForOrgRequest(server string, org Org, params *CodeScanninglistAlertsForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/code-scanning/alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ToolName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_name", runtime.ParamLocationQuery, *params.ToolName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolGuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_guid", runtime.ParamLocationQuery, *params.ToolGuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.After != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistSamlSsoAuthorizationsRequest generates requests for OrgslistSamlSsoAuthorizations
func NewOrgslistSamlSsoAuthorizationsRequest(server string, org Org, params *OrgslistSamlSsoAuthorizationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/credential-authorizations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Login != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login", runtime.ParamLocationQuery, *params.Login); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsremoveSamlSsoAuthorizationRequest generates requests for OrgsremoveSamlSsoAuthorization
func NewOrgsremoveSamlSsoAuthorizationRequest(server string, org Org, credentialId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "credential_id", runtime.ParamLocationPath, credentialId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/credential-authorizations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotlistOrgSecretsRequest generates requests for DependabotlistOrgSecrets
func NewDependabotlistOrgSecretsRequest(server string, org Org, params *DependabotlistOrgSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotgetOrgPublicKeyRequest generates requests for DependabotgetOrgPublicKey
func NewDependabotgetOrgPublicKeyRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/public-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotdeleteOrgSecretRequest generates requests for DependabotdeleteOrgSecret
func NewDependabotdeleteOrgSecretRequest(server string, org Org, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotgetOrgSecretRequest generates requests for DependabotgetOrgSecret
func NewDependabotgetOrgSecretRequest(server string, org Org, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotcreateOrUpdateOrgSecretRequest calls the generic DependabotcreateOrUpdateOrgSecret builder with application/json body
func NewDependabotcreateOrUpdateOrgSecretRequest(server string, org Org, secretName SecretName, body DependabotcreateOrUpdateOrgSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDependabotcreateOrUpdateOrgSecretRequestWithBody(server, org, secretName, "application/json", bodyReader)
}

// NewDependabotcreateOrUpdateOrgSecretRequestWithBody generates requests for DependabotcreateOrUpdateOrgSecret with any type of body
func NewDependabotcreateOrUpdateOrgSecretRequestWithBody(server string, org Org, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDependabotlistSelectedReposForOrgSecretRequest generates requests for DependabotlistSelectedReposForOrgSecret
func NewDependabotlistSelectedReposForOrgSecretRequest(server string, org Org, secretName SecretName, params *DependabotlistSelectedReposForOrgSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotsetSelectedReposForOrgSecretRequest calls the generic DependabotsetSelectedReposForOrgSecret builder with application/json body
func NewDependabotsetSelectedReposForOrgSecretRequest(server string, org Org, secretName SecretName, body DependabotsetSelectedReposForOrgSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDependabotsetSelectedReposForOrgSecretRequestWithBody(server, org, secretName, "application/json", bodyReader)
}

// NewDependabotsetSelectedReposForOrgSecretRequestWithBody generates requests for DependabotsetSelectedReposForOrgSecret with any type of body
func NewDependabotsetSelectedReposForOrgSecretRequestWithBody(server string, org Org, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDependabotremoveSelectedRepoFromOrgSecretRequest generates requests for DependabotremoveSelectedRepoFromOrgSecret
func NewDependabotremoveSelectedRepoFromOrgSecretRequest(server string, org Org, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotaddSelectedRepoToOrgSecretRequest generates requests for DependabotaddSelectedRepoToOrgSecret
func NewDependabotaddSelectedRepoToOrgSecretRequest(server string, org Org, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/dependabot/secrets/%s/repositories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistPublicOrgEventsRequest generates requests for ActivitylistPublicOrgEvents
func NewActivitylistPublicOrgEventsRequest(server string, org Org, params *ActivitylistPublicOrgEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsexternalIdpGroupInfoForOrgRequest generates requests for TeamsexternalIdpGroupInfoForOrg
func NewTeamsexternalIdpGroupInfoForOrgRequest(server string, org Org, groupId GroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/external-group/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistExternalIdpGroupsForOrgRequest generates requests for TeamslistExternalIdpGroupsForOrg
func NewTeamslistExternalIdpGroupsForOrgRequest(server string, org Org, params *TeamslistExternalIdpGroupsForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/external-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.DisplayName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "display_name", runtime.ParamLocationQuery, *params.DisplayName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistFailedInvitationsRequest generates requests for OrgslistFailedInvitations
func NewOrgslistFailedInvitationsRequest(server string, org Org, params *OrgslistFailedInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/failed_invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistWebhooksRequest generates requests for OrgslistWebhooks
func NewOrgslistWebhooksRequest(server string, org Org, params *OrgslistWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgscreateWebhookRequest calls the generic OrgscreateWebhook builder with application/json body
func NewOrgscreateWebhookRequest(server string, org Org, body OrgscreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgscreateWebhookRequestWithBody(server, org, "application/json", bodyReader)
}

// NewOrgscreateWebhookRequestWithBody generates requests for OrgscreateWebhook with any type of body
func NewOrgscreateWebhookRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgsdeleteWebhookRequest generates requests for OrgsdeleteWebhook
func NewOrgsdeleteWebhookRequest(server string, org Org, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetWebhookRequest generates requests for OrgsgetWebhook
func NewOrgsgetWebhookRequest(server string, org Org, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsupdateWebhookRequest calls the generic OrgsupdateWebhook builder with application/json body
func NewOrgsupdateWebhookRequest(server string, org Org, hookId HookId, body OrgsupdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgsupdateWebhookRequestWithBody(server, org, hookId, "application/json", bodyReader)
}

// NewOrgsupdateWebhookRequestWithBody generates requests for OrgsupdateWebhook with any type of body
func NewOrgsupdateWebhookRequestWithBody(server string, org Org, hookId HookId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgsgetWebhookConfigForOrgRequest generates requests for OrgsgetWebhookConfigForOrg
func NewOrgsgetWebhookConfigForOrgRequest(server string, org Org, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/config", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsupdateWebhookConfigForOrgRequest calls the generic OrgsupdateWebhookConfigForOrg builder with application/json body
func NewOrgsupdateWebhookConfigForOrgRequest(server string, org Org, hookId HookId, body OrgsupdateWebhookConfigForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgsupdateWebhookConfigForOrgRequestWithBody(server, org, hookId, "application/json", bodyReader)
}

// NewOrgsupdateWebhookConfigForOrgRequestWithBody generates requests for OrgsupdateWebhookConfigForOrg with any type of body
func NewOrgsupdateWebhookConfigForOrgRequestWithBody(server string, org Org, hookId HookId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/config", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgslistWebhookDeliveriesRequest generates requests for OrgslistWebhookDeliveries
func NewOrgslistWebhookDeliveriesRequest(server string, org Org, hookId HookId, params *OrgslistWebhookDeliveriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/deliveries", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetWebhookDeliveryRequest generates requests for OrgsgetWebhookDelivery
func NewOrgsgetWebhookDeliveryRequest(server string, org Org, hookId HookId, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/deliveries/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsredeliverWebhookDeliveryRequest generates requests for OrgsredeliverWebhookDelivery
func NewOrgsredeliverWebhookDeliveryRequest(server string, org Org, hookId HookId, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/deliveries/%s/attempts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgspingWebhookRequest generates requests for OrgspingWebhook
func NewOrgspingWebhookRequest(server string, org Org, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/hooks/%s/pings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetOrgInstallationRequest generates requests for AppsgetOrgInstallation
func NewAppsgetOrgInstallationRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/installation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistAppInstallationsRequest generates requests for OrgslistAppInstallations
func NewOrgslistAppInstallationsRequest(server string, org Org, params *OrgslistAppInstallationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/installations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsremoveRestrictionsForOrgRequest generates requests for InteractionsremoveRestrictionsForOrg
func NewInteractionsremoveRestrictionsForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/interaction-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsgetRestrictionsForOrgRequest generates requests for InteractionsgetRestrictionsForOrg
func NewInteractionsgetRestrictionsForOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/interaction-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionssetRestrictionsForOrgRequest calls the generic InteractionssetRestrictionsForOrg builder with application/json body
func NewInteractionssetRestrictionsForOrgRequest(server string, org Org, body InteractionssetRestrictionsForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInteractionssetRestrictionsForOrgRequestWithBody(server, org, "application/json", bodyReader)
}

// NewInteractionssetRestrictionsForOrgRequestWithBody generates requests for InteractionssetRestrictionsForOrg with any type of body
func NewInteractionssetRestrictionsForOrgRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/interaction-limits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgslistPendingInvitationsRequest generates requests for OrgslistPendingInvitations
func NewOrgslistPendingInvitationsRequest(server string, org Org, params *OrgslistPendingInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgscreateInvitationRequest calls the generic OrgscreateInvitation builder with application/json body
func NewOrgscreateInvitationRequest(server string, org Org, body OrgscreateInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgscreateInvitationRequestWithBody(server, org, "application/json", bodyReader)
}

// NewOrgscreateInvitationRequestWithBody generates requests for OrgscreateInvitation with any type of body
func NewOrgscreateInvitationRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgscancelInvitationRequest generates requests for OrgscancelInvitation
func NewOrgscancelInvitationRequest(server string, org Org, invitationId InvitationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/invitations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistInvitationTeamsRequest generates requests for OrgslistInvitationTeams
func NewOrgslistInvitationTeamsRequest(server string, org Org, invitationId InvitationId, params *OrgslistInvitationTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/invitations/%s/teams", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistForOrgRequest generates requests for IssueslistForOrg
func NewIssueslistForOrgRequest(server string, org Org, params *IssueslistForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Labels != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistMembersRequest generates requests for OrgslistMembers
func NewOrgslistMembersRequest(server string, org Org, params *OrgslistMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Role != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsremoveMemberRequest generates requests for OrgsremoveMember
func NewOrgsremoveMemberRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgscheckMembershipForUserRequest generates requests for OrgscheckMembershipForUser
func NewOrgscheckMembershipForUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsremoveMembershipForUserRequest generates requests for OrgsremoveMembershipForUser
func NewOrgsremoveMembershipForUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetMembershipForUserRequest generates requests for OrgsgetMembershipForUser
func NewOrgsgetMembershipForUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgssetMembershipForUserRequest calls the generic OrgssetMembershipForUser builder with application/json body
func NewOrgssetMembershipForUserRequest(server string, org Org, username Username, body OrgssetMembershipForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgssetMembershipForUserRequestWithBody(server, org, username, "application/json", bodyReader)
}

// NewOrgssetMembershipForUserRequestWithBody generates requests for OrgssetMembershipForUser with any type of body
func NewOrgssetMembershipForUserRequestWithBody(server string, org Org, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationslistForOrgRequest generates requests for MigrationslistForOrg
func NewMigrationslistForOrgRequest(server string, org Org, params *MigrationslistForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsstartForOrgRequest calls the generic MigrationsstartForOrg builder with application/json body
func NewMigrationsstartForOrgRequest(server string, org Org, body MigrationsstartForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationsstartForOrgRequestWithBody(server, org, "application/json", bodyReader)
}

// NewMigrationsstartForOrgRequestWithBody generates requests for MigrationsstartForOrg with any type of body
func NewMigrationsstartForOrgRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationsgetStatusForOrgRequest generates requests for MigrationsgetStatusForOrg
func NewMigrationsgetStatusForOrgRequest(server string, org Org, migrationId MigrationId, params *MigrationsgetStatusForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsdeleteArchiveForOrgRequest generates requests for MigrationsdeleteArchiveForOrg
func NewMigrationsdeleteArchiveForOrgRequest(server string, org Org, migrationId MigrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations/%s/archive", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsdownloadArchiveForOrgRequest generates requests for MigrationsdownloadArchiveForOrg
func NewMigrationsdownloadArchiveForOrgRequest(server string, org Org, migrationId MigrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations/%s/archive", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsunlockRepoForOrgRequest generates requests for MigrationsunlockRepoForOrg
func NewMigrationsunlockRepoForOrgRequest(server string, org Org, migrationId MigrationId, repoName RepoName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repo_name", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations/%s/repos/%s/lock", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationslistReposForOrgRequest generates requests for MigrationslistReposForOrg
func NewMigrationslistReposForOrgRequest(server string, org Org, migrationId MigrationId, params *MigrationslistReposForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/migrations/%s/repositories", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistOutsideCollaboratorsRequest generates requests for OrgslistOutsideCollaborators
func NewOrgslistOutsideCollaboratorsRequest(server string, org Org, params *OrgslistOutsideCollaboratorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/outside_collaborators", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsremoveOutsideCollaboratorRequest generates requests for OrgsremoveOutsideCollaborator
func NewOrgsremoveOutsideCollaboratorRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/outside_collaborators/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsconvertMemberToOutsideCollaboratorRequest generates requests for OrgsconvertMemberToOutsideCollaborator
func NewOrgsconvertMemberToOutsideCollaboratorRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/outside_collaborators/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackageslistPackagesForOrganizationRequest generates requests for PackageslistPackagesForOrganization
func NewPackageslistPackagesForOrganizationRequest(server string, org Org, params *PackageslistPackagesForOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package_type", runtime.ParamLocationQuery, params.PackageType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Visibility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageForOrgRequest generates requests for PackagesdeletePackageForOrg
func NewPackagesdeletePackageForOrgRequest(server string, org Org, packageType PackagesdeletePackageForOrgParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageForOrganizationRequest generates requests for PackagesgetPackageForOrganization
func NewPackagesgetPackageForOrganizationRequest(server string, org Org, packageType PackagesgetPackageForOrganizationParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageForOrgRequest generates requests for PackagesrestorePackageForOrg
func NewPackagesrestorePackageForOrgRequest(server string, org Org, packageType PackagesrestorePackageForOrgParamsPackageType, packageName PackageName, params *PackagesrestorePackageForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s/restore", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Token != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetAllPackageVersionsForPackageOwnedByOrgRequest generates requests for PackagesgetAllPackageVersionsForPackageOwnedByOrg
func NewPackagesgetAllPackageVersionsForPackageOwnedByOrgRequest(server string, org Org, packageType PackagesgetAllPackageVersionsForPackageOwnedByOrgParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s/versions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageVersionForOrgRequest generates requests for PackagesdeletePackageVersionForOrg
func NewPackagesdeletePackageVersionForOrgRequest(server string, org Org, packageType PackagesdeletePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageVersionForOrganizationRequest generates requests for PackagesgetPackageVersionForOrganization
func NewPackagesgetPackageVersionForOrganizationRequest(server string, org Org, packageType PackagesgetPackageVersionForOrganizationParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageVersionForOrgRequest generates requests for PackagesrestorePackageVersionForOrg
func NewPackagesrestorePackageVersionForOrgRequest(server string, org Org, packageType PackagesrestorePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/%s/versions/%s/restore", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectslistForOrgRequest generates requests for ProjectslistForOrg
func NewProjectslistForOrgRequest(server string, org Org, params *ProjectslistForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectscreateForOrgRequest calls the generic ProjectscreateForOrg builder with application/json body
func NewProjectscreateForOrgRequest(server string, org Org, body ProjectscreateForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectscreateForOrgRequestWithBody(server, org, "application/json", bodyReader)
}

// NewProjectscreateForOrgRequestWithBody generates requests for ProjectscreateForOrg with any type of body
func NewProjectscreateForOrgRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewOrgslistPublicMembersRequest generates requests for OrgslistPublicMembers
func NewOrgslistPublicMembersRequest(server string, org Org, params *OrgslistPublicMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/public_members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsremovePublicMembershipForAuthenticatedUserRequest generates requests for OrgsremovePublicMembershipForAuthenticatedUser
func NewOrgsremovePublicMembershipForAuthenticatedUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/public_members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgscheckPublicMembershipForUserRequest generates requests for OrgscheckPublicMembershipForUser
func NewOrgscheckPublicMembershipForUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/public_members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgssetPublicMembershipForAuthenticatedUserRequest generates requests for OrgssetPublicMembershipForAuthenticatedUser
func NewOrgssetPublicMembershipForAuthenticatedUserRequest(server string, org Org, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/public_members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistForOrgRequest generates requests for ReposlistForOrg
func NewReposlistForOrgRequest(server string, org Org, params *ReposlistForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateInOrgRequest calls the generic ReposcreateInOrg builder with application/json body
func NewReposcreateInOrgRequest(server string, org Org, body ReposcreateInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateInOrgRequestWithBody(server, org, "application/json", bodyReader)
}

// NewReposcreateInOrgRequestWithBody generates requests for ReposcreateInOrg with any type of body
func NewReposcreateInOrgRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSecretScanninglistAlertsForOrgRequest generates requests for SecretScanninglistAlertsForOrg
func NewSecretScanninglistAlertsForOrgRequest(server string, org Org, params *SecretScanninglistAlertsForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/secret-scanning/alerts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SecretType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_type", runtime.ParamLocationQuery, *params.SecretType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resolution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubActionsBillingOrgRequest generates requests for BillinggetGithubActionsBillingOrg
func NewBillinggetGithubActionsBillingOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/settings/billing/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubAdvancedSecurityBillingOrgRequest generates requests for BillinggetGithubAdvancedSecurityBillingOrg
func NewBillinggetGithubAdvancedSecurityBillingOrgRequest(server string, org Org, params *BillinggetGithubAdvancedSecurityBillingOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/settings/billing/advanced-security", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubPackagesBillingOrgRequest generates requests for BillinggetGithubPackagesBillingOrg
func NewBillinggetGithubPackagesBillingOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/settings/billing/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetSharedStorageBillingOrgRequest generates requests for BillinggetSharedStorageBillingOrg
func NewBillinggetSharedStorageBillingOrgRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/settings/billing/shared-storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistIdpGroupsForOrgRequest generates requests for TeamslistIdpGroupsForOrg
func NewTeamslistIdpGroupsForOrgRequest(server string, org Org, params *TeamslistIdpGroupsForOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/team-sync/groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistRequest generates requests for Teamslist
func NewTeamslistRequest(server string, org Org, params *TeamslistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateRequest calls the generic Teamscreate builder with application/json body
func NewTeamscreateRequest(server string, org Org, body TeamscreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateRequestWithBody(server, org, "application/json", bodyReader)
}

// NewTeamscreateRequestWithBody generates requests for Teamscreate with any type of body
func NewTeamscreateRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamsdeleteInOrgRequest generates requests for TeamsdeleteInOrg
func NewTeamsdeleteInOrgRequest(server string, org Org, teamSlug TeamSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetByNameRequest generates requests for TeamsgetByName
func NewTeamsgetByNameRequest(server string, org Org, teamSlug TeamSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateInOrgRequest calls the generic TeamsupdateInOrg builder with application/json body
func NewTeamsupdateInOrgRequest(server string, org Org, teamSlug TeamSlug, body TeamsupdateInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateInOrgRequestWithBody(server, org, teamSlug, "application/json", bodyReader)
}

// NewTeamsupdateInOrgRequestWithBody generates requests for TeamsupdateInOrg with any type of body
func NewTeamsupdateInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistDiscussionsInOrgRequest generates requests for TeamslistDiscussionsInOrg
func NewTeamslistDiscussionsInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistDiscussionsInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Pinned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pinned", runtime.ParamLocationQuery, *params.Pinned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateDiscussionInOrgRequest calls the generic TeamscreateDiscussionInOrg builder with application/json body
func NewTeamscreateDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, body TeamscreateDiscussionInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateDiscussionInOrgRequestWithBody(server, org, teamSlug, "application/json", bodyReader)
}

// NewTeamscreateDiscussionInOrgRequestWithBody generates requests for TeamscreateDiscussionInOrg with any type of body
func NewTeamscreateDiscussionInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamsdeleteDiscussionInOrgRequest generates requests for TeamsdeleteDiscussionInOrg
func NewTeamsdeleteDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetDiscussionInOrgRequest generates requests for TeamsgetDiscussionInOrg
func NewTeamsgetDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateDiscussionInOrgRequest calls the generic TeamsupdateDiscussionInOrg builder with application/json body
func NewTeamsupdateDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamsupdateDiscussionInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateDiscussionInOrgRequestWithBody(server, org, teamSlug, discussionNumber, "application/json", bodyReader)
}

// NewTeamsupdateDiscussionInOrgRequestWithBody generates requests for TeamsupdateDiscussionInOrg with any type of body
func NewTeamsupdateDiscussionInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistDiscussionCommentsInOrgRequest generates requests for TeamslistDiscussionCommentsInOrg
func NewTeamslistDiscussionCommentsInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateDiscussionCommentInOrgRequest calls the generic TeamscreateDiscussionCommentInOrg builder with application/json body
func NewTeamscreateDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateDiscussionCommentInOrgRequestWithBody(server, org, teamSlug, discussionNumber, "application/json", bodyReader)
}

// NewTeamscreateDiscussionCommentInOrgRequestWithBody generates requests for TeamscreateDiscussionCommentInOrg with any type of body
func NewTeamscreateDiscussionCommentInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamsdeleteDiscussionCommentInOrgRequest generates requests for TeamsdeleteDiscussionCommentInOrg
func NewTeamsdeleteDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetDiscussionCommentInOrgRequest generates requests for TeamsgetDiscussionCommentInOrg
func NewTeamsgetDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateDiscussionCommentInOrgRequest calls the generic TeamsupdateDiscussionCommentInOrg builder with application/json body
func NewTeamsupdateDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateDiscussionCommentInOrgRequestWithBody(server, org, teamSlug, discussionNumber, commentNumber, "application/json", bodyReader)
}

// NewTeamsupdateDiscussionCommentInOrgRequestWithBody generates requests for TeamsupdateDiscussionCommentInOrg with any type of body
func NewTeamsupdateDiscussionCommentInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForTeamDiscussionCommentInOrgRequest generates requests for ReactionslistForTeamDiscussionCommentInOrg
func NewReactionslistForTeamDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForTeamDiscussionCommentInOrgRequest calls the generic ReactionscreateForTeamDiscussionCommentInOrg builder with application/json body
func NewReactionscreateForTeamDiscussionCommentInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForTeamDiscussionCommentInOrgRequestWithBody(server, org, teamSlug, discussionNumber, commentNumber, "application/json", bodyReader)
}

// NewReactionscreateForTeamDiscussionCommentInOrgRequestWithBody generates requests for ReactionscreateForTeamDiscussionCommentInOrg with any type of body
func NewReactionscreateForTeamDiscussionCommentInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForTeamDiscussionCommentRequest generates requests for ReactionsdeleteForTeamDiscussionComment
func NewReactionsdeleteForTeamDiscussionCommentRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionslistForTeamDiscussionInOrgRequest generates requests for ReactionslistForTeamDiscussionInOrg
func NewReactionslistForTeamDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForTeamDiscussionInOrgRequest calls the generic ReactionscreateForTeamDiscussionInOrg builder with application/json body
func NewReactionscreateForTeamDiscussionInOrgRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForTeamDiscussionInOrgRequestWithBody(server, org, teamSlug, discussionNumber, "application/json", bodyReader)
}

// NewReactionscreateForTeamDiscussionInOrgRequestWithBody generates requests for ReactionscreateForTeamDiscussionInOrg with any type of body
func NewReactionscreateForTeamDiscussionInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForTeamDiscussionRequest generates requests for ReactionsdeleteForTeamDiscussion
func NewReactionsdeleteForTeamDiscussionRequest(server string, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/discussions/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsunlinkExternalIdpGroupFromTeamForOrgRequest generates requests for TeamsunlinkExternalIdpGroupFromTeamForOrg
func NewTeamsunlinkExternalIdpGroupFromTeamForOrgRequest(server string, org Org, teamSlug TeamSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/external-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistLinkedExternalIdpGroupsToTeamForOrgRequest generates requests for TeamslistLinkedExternalIdpGroupsToTeamForOrg
func NewTeamslistLinkedExternalIdpGroupsToTeamForOrgRequest(server string, org Org, teamSlug TeamSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/external-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslinkExternalIdpGroupToTeamForOrgRequest calls the generic TeamslinkExternalIdpGroupToTeamForOrg builder with application/json body
func NewTeamslinkExternalIdpGroupToTeamForOrgRequest(server string, org Org, teamSlug TeamSlug, body TeamslinkExternalIdpGroupToTeamForOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamslinkExternalIdpGroupToTeamForOrgRequestWithBody(server, org, teamSlug, "application/json", bodyReader)
}

// NewTeamslinkExternalIdpGroupToTeamForOrgRequestWithBody generates requests for TeamslinkExternalIdpGroupToTeamForOrg with any type of body
func NewTeamslinkExternalIdpGroupToTeamForOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/external-groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistPendingInvitationsInOrgRequest generates requests for TeamslistPendingInvitationsInOrg
func NewTeamslistPendingInvitationsInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistPendingInvitationsInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/invitations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistMembersInOrgRequest generates requests for TeamslistMembersInOrg
func NewTeamslistMembersInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistMembersInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/members", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Role != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveMembershipForUserInOrgRequest generates requests for TeamsremoveMembershipForUserInOrg
func NewTeamsremoveMembershipForUserInOrgRequest(server string, org Org, teamSlug TeamSlug, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/memberships/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetMembershipForUserInOrgRequest generates requests for TeamsgetMembershipForUserInOrg
func NewTeamsgetMembershipForUserInOrgRequest(server string, org Org, teamSlug TeamSlug, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/memberships/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateMembershipForUserInOrgRequest calls the generic TeamsaddOrUpdateMembershipForUserInOrg builder with application/json body
func NewTeamsaddOrUpdateMembershipForUserInOrgRequest(server string, org Org, teamSlug TeamSlug, username Username, body TeamsaddOrUpdateMembershipForUserInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateMembershipForUserInOrgRequestWithBody(server, org, teamSlug, username, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateMembershipForUserInOrgRequestWithBody generates requests for TeamsaddOrUpdateMembershipForUserInOrg with any type of body
func NewTeamsaddOrUpdateMembershipForUserInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/memberships/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistProjectsInOrgRequest generates requests for TeamslistProjectsInOrg
func NewTeamslistProjectsInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistProjectsInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/projects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveProjectInOrgRequest generates requests for TeamsremoveProjectInOrg
func NewTeamsremoveProjectInOrgRequest(server string, org Org, teamSlug TeamSlug, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/projects/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscheckPermissionsForProjectInOrgRequest generates requests for TeamscheckPermissionsForProjectInOrg
func NewTeamscheckPermissionsForProjectInOrgRequest(server string, org Org, teamSlug TeamSlug, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/projects/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateProjectPermissionsInOrgRequest calls the generic TeamsaddOrUpdateProjectPermissionsInOrg builder with application/json body
func NewTeamsaddOrUpdateProjectPermissionsInOrgRequest(server string, org Org, teamSlug TeamSlug, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateProjectPermissionsInOrgRequestWithBody(server, org, teamSlug, projectId, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateProjectPermissionsInOrgRequestWithBody generates requests for TeamsaddOrUpdateProjectPermissionsInOrg with any type of body
func NewTeamsaddOrUpdateProjectPermissionsInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/projects/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistReposInOrgRequest generates requests for TeamslistReposInOrg
func NewTeamslistReposInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistReposInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/repos", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveRepoInOrgRequest generates requests for TeamsremoveRepoInOrg
func NewTeamsremoveRepoInOrgRequest(server string, org Org, teamSlug TeamSlug, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscheckPermissionsForRepoInOrgRequest generates requests for TeamscheckPermissionsForRepoInOrg
func NewTeamscheckPermissionsForRepoInOrgRequest(server string, org Org, teamSlug TeamSlug, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateRepoPermissionsInOrgRequest calls the generic TeamsaddOrUpdateRepoPermissionsInOrg builder with application/json body
func NewTeamsaddOrUpdateRepoPermissionsInOrgRequest(server string, org Org, teamSlug TeamSlug, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateRepoPermissionsInOrgRequestWithBody(server, org, teamSlug, owner, repo, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateRepoPermissionsInOrgRequestWithBody generates requests for TeamsaddOrUpdateRepoPermissionsInOrg with any type of body
func NewTeamsaddOrUpdateRepoPermissionsInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistIdpGroupsInOrgRequest generates requests for TeamslistIdpGroupsInOrg
func NewTeamslistIdpGroupsInOrgRequest(server string, org Org, teamSlug TeamSlug) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/team-sync/group-mappings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequest calls the generic TeamscreateOrUpdateIdpGroupConnectionsInOrg builder with application/json body
func NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequest(server string, org Org, teamSlug TeamSlug, body TeamscreateOrUpdateIdpGroupConnectionsInOrgJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequestWithBody(server, org, teamSlug, "application/json", bodyReader)
}

// NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequestWithBody generates requests for TeamscreateOrUpdateIdpGroupConnectionsInOrg with any type of body
func NewTeamscreateOrUpdateIdpGroupConnectionsInOrgRequestWithBody(server string, org Org, teamSlug TeamSlug, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/team-sync/group-mappings", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistChildInOrgRequest generates requests for TeamslistChildInOrg
func NewTeamslistChildInOrgRequest(server string, org Org, teamSlug TeamSlug, params *TeamslistChildInOrgParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "team_slug", runtime.ParamLocationPath, teamSlug)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/teams/%s/teams", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsdeleteCardRequest generates requests for ProjectsdeleteCard
func NewProjectsdeleteCardRequest(server string, cardId CardId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_id", runtime.ParamLocationPath, cardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsgetCardRequest generates requests for ProjectsgetCard
func NewProjectsgetCardRequest(server string, cardId CardId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_id", runtime.ParamLocationPath, cardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsupdateCardRequest calls the generic ProjectsupdateCard builder with application/json body
func NewProjectsupdateCardRequest(server string, cardId CardId, body ProjectsupdateCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsupdateCardRequestWithBody(server, cardId, "application/json", bodyReader)
}

// NewProjectsupdateCardRequestWithBody generates requests for ProjectsupdateCard with any type of body
func NewProjectsupdateCardRequestWithBody(server string, cardId CardId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_id", runtime.ParamLocationPath, cardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/cards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsmoveCardRequest calls the generic ProjectsmoveCard builder with application/json body
func NewProjectsmoveCardRequest(server string, cardId CardId, body ProjectsmoveCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsmoveCardRequestWithBody(server, cardId, "application/json", bodyReader)
}

// NewProjectsmoveCardRequestWithBody generates requests for ProjectsmoveCard with any type of body
func NewProjectsmoveCardRequestWithBody(server string, cardId CardId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "card_id", runtime.ParamLocationPath, cardId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/cards/%s/moves", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsdeleteColumnRequest generates requests for ProjectsdeleteColumn
func NewProjectsdeleteColumnRequest(server string, columnId ColumnId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsgetColumnRequest generates requests for ProjectsgetColumn
func NewProjectsgetColumnRequest(server string, columnId ColumnId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsupdateColumnRequest calls the generic ProjectsupdateColumn builder with application/json body
func NewProjectsupdateColumnRequest(server string, columnId ColumnId, body ProjectsupdateColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsupdateColumnRequestWithBody(server, columnId, "application/json", bodyReader)
}

// NewProjectsupdateColumnRequestWithBody generates requests for ProjectsupdateColumn with any type of body
func NewProjectsupdateColumnRequestWithBody(server string, columnId ColumnId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectslistCardsRequest generates requests for ProjectslistCards
func NewProjectslistCardsRequest(server string, columnId ColumnId, params *ProjectslistCardsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s/cards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ArchivedState != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archived_state", runtime.ParamLocationQuery, *params.ArchivedState); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectscreateCardRequest calls the generic ProjectscreateCard builder with application/json body
func NewProjectscreateCardRequest(server string, columnId ColumnId, body ProjectscreateCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectscreateCardRequestWithBody(server, columnId, "application/json", bodyReader)
}

// NewProjectscreateCardRequestWithBody generates requests for ProjectscreateCard with any type of body
func NewProjectscreateCardRequestWithBody(server string, columnId ColumnId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s/cards", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsmoveColumnRequest calls the generic ProjectsmoveColumn builder with application/json body
func NewProjectsmoveColumnRequest(server string, columnId ColumnId, body ProjectsmoveColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsmoveColumnRequestWithBody(server, columnId, "application/json", bodyReader)
}

// NewProjectsmoveColumnRequestWithBody generates requests for ProjectsmoveColumn with any type of body
func NewProjectsmoveColumnRequestWithBody(server string, columnId ColumnId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "column_id", runtime.ParamLocationPath, columnId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/columns/%s/moves", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsdeleteRequest generates requests for Projectsdelete
func NewProjectsdeleteRequest(server string, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsgetRequest generates requests for Projectsget
func NewProjectsgetRequest(server string, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsupdateRequest calls the generic Projectsupdate builder with application/json body
func NewProjectsupdateRequest(server string, projectId ProjectId, body ProjectsupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsupdateRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewProjectsupdateRequestWithBody generates requests for Projectsupdate with any type of body
func NewProjectsupdateRequestWithBody(server string, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectslistCollaboratorsRequest generates requests for ProjectslistCollaborators
func NewProjectslistCollaboratorsRequest(server string, projectId ProjectId, params *ProjectslistCollaboratorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Affiliation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "affiliation", runtime.ParamLocationQuery, *params.Affiliation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsremoveCollaboratorRequest generates requests for ProjectsremoveCollaborator
func NewProjectsremoveCollaboratorRequest(server string, projectId ProjectId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectsaddCollaboratorRequest calls the generic ProjectsaddCollaborator builder with application/json body
func NewProjectsaddCollaboratorRequest(server string, projectId ProjectId, username Username, body ProjectsaddCollaboratorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectsaddCollaboratorRequestWithBody(server, projectId, username, "application/json", bodyReader)
}

// NewProjectsaddCollaboratorRequestWithBody generates requests for ProjectsaddCollaborator with any type of body
func NewProjectsaddCollaboratorRequestWithBody(server string, projectId ProjectId, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsgetPermissionForUserRequest generates requests for ProjectsgetPermissionForUser
func NewProjectsgetPermissionForUserRequest(server string, projectId ProjectId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/collaborators/%s/permission", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectslistColumnsRequest generates requests for ProjectslistColumns
func NewProjectslistColumnsRequest(server string, projectId ProjectId, params *ProjectslistColumnsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectscreateColumnRequest calls the generic ProjectscreateColumn builder with application/json body
func NewProjectscreateColumnRequest(server string, projectId ProjectId, body ProjectscreateColumnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectscreateColumnRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewProjectscreateColumnRequestWithBody generates requests for ProjectscreateColumn with any type of body
func NewProjectscreateColumnRequestWithBody(server string, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/columns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRateLimitgetRequest generates requests for RateLimitget
func NewRateLimitgetRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rate_limit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteRequest generates requests for Reposdelete
func NewReposdeleteRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetRequest generates requests for Reposget
func NewReposgetRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateRequest calls the generic Reposupdate builder with application/json body
func NewReposupdateRequest(server string, owner Owner, repo Repo, body ReposupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposupdateRequestWithBody generates requests for Reposupdate with any type of body
func NewReposupdateRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistArtifactsForRepoRequest generates requests for ActionslistArtifactsForRepo
func NewActionslistArtifactsForRepoRequest(server string, owner Owner, repo Repo, params *ActionslistArtifactsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/artifacts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteArtifactRequest generates requests for ActionsdeleteArtifact
func NewActionsdeleteArtifactRequest(server string, owner Owner, repo Repo, artifactId ArtifactId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact_id", runtime.ParamLocationPath, artifactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/artifacts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetArtifactRequest generates requests for ActionsgetArtifact
func NewActionsgetArtifactRequest(server string, owner Owner, repo Repo, artifactId ArtifactId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact_id", runtime.ParamLocationPath, artifactId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/artifacts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdownloadArtifactRequest generates requests for ActionsdownloadArtifact
func NewActionsdownloadArtifactRequest(server string, owner Owner, repo Repo, artifactId ArtifactId, archiveFormat string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "artifact_id", runtime.ParamLocationPath, artifactId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "archive_format", runtime.ParamLocationPath, archiveFormat)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/artifacts/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetActionsCacheUsageRequest generates requests for ActionsgetActionsCacheUsage
func NewActionsgetActionsCacheUsageRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/cache/usage", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetJobForWorkflowRunRequest generates requests for ActionsgetJobForWorkflowRun
func NewActionsgetJobForWorkflowRunRequest(server string, owner Owner, repo Repo, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/jobs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdownloadJobLogsForWorkflowRunRequest generates requests for ActionsdownloadJobLogsForWorkflowRun
func NewActionsdownloadJobLogsForWorkflowRunRequest(server string, owner Owner, repo Repo, jobId JobId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/jobs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsreRunJobForWorkflowRunRequest calls the generic ActionsreRunJobForWorkflowRun builder with application/json body
func NewActionsreRunJobForWorkflowRunRequest(server string, owner Owner, repo Repo, jobId JobId, body ActionsreRunJobForWorkflowRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsreRunJobForWorkflowRunRequestWithBody(server, owner, repo, jobId, "application/json", bodyReader)
}

// NewActionsreRunJobForWorkflowRunRequestWithBody generates requests for ActionsreRunJobForWorkflowRun with any type of body
func NewActionsreRunJobForWorkflowRunRequestWithBody(server string, owner Owner, repo Repo, jobId JobId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/jobs/%s/rerun", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetGithubActionsPermissionsRepositoryRequest generates requests for ActionsgetGithubActionsPermissionsRepository
func NewActionsgetGithubActionsPermissionsRepositoryRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetGithubActionsPermissionsRepositoryRequest calls the generic ActionssetGithubActionsPermissionsRepository builder with application/json body
func NewActionssetGithubActionsPermissionsRepositoryRequest(server string, owner Owner, repo Repo, body ActionssetGithubActionsPermissionsRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetGithubActionsPermissionsRepositoryRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActionssetGithubActionsPermissionsRepositoryRequestWithBody generates requests for ActionssetGithubActionsPermissionsRepository with any type of body
func NewActionssetGithubActionsPermissionsRepositoryRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetWorkflowAccessToRepositoryRequest generates requests for ActionsgetWorkflowAccessToRepository
func NewActionsgetWorkflowAccessToRepositoryRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/access", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetWorkflowAccessToRepositoryRequest calls the generic ActionssetWorkflowAccessToRepository builder with application/json body
func NewActionssetWorkflowAccessToRepositoryRequest(server string, owner Owner, repo Repo, body ActionssetWorkflowAccessToRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetWorkflowAccessToRepositoryRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActionssetWorkflowAccessToRepositoryRequestWithBody generates requests for ActionssetWorkflowAccessToRepository with any type of body
func NewActionssetWorkflowAccessToRepositoryRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/access", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetAllowedActionsRepositoryRequest generates requests for ActionsgetAllowedActionsRepository
func NewActionsgetAllowedActionsRepositoryRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/selected-actions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetAllowedActionsRepositoryRequest calls the generic ActionssetAllowedActionsRepository builder with application/json body
func NewActionssetAllowedActionsRepositoryRequest(server string, owner Owner, repo Repo, body ActionssetAllowedActionsRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetAllowedActionsRepositoryRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActionssetAllowedActionsRepositoryRequestWithBody generates requests for ActionssetAllowedActionsRepository with any type of body
func NewActionssetAllowedActionsRepositoryRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/selected-actions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryRequest generates requests for ActionsgetGithubActionsDefaultWorkflowPermissionsRepository
func NewActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/workflow", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequest calls the generic ActionssetGithubActionsDefaultWorkflowPermissionsRepository builder with application/json body
func NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequest(server string, owner Owner, repo Repo, body ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequestWithBody generates requests for ActionssetGithubActionsDefaultWorkflowPermissionsRepository with any type of body
func NewActionssetGithubActionsDefaultWorkflowPermissionsRepositoryRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/permissions/workflow", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistSelfHostedRunnersForRepoRequest generates requests for ActionslistSelfHostedRunnersForRepo
func NewActionslistSelfHostedRunnersForRepoRequest(server string, owner Owner, repo Repo, params *ActionslistSelfHostedRunnersForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistRunnerApplicationsForRepoRequest generates requests for ActionslistRunnerApplicationsForRepo
func NewActionslistRunnerApplicationsForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/downloads", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateRegistrationTokenForRepoRequest generates requests for ActionscreateRegistrationTokenForRepo
func NewActionscreateRegistrationTokenForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/registration-token", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateRemoveTokenForRepoRequest generates requests for ActionscreateRemoveTokenForRepo
func NewActionscreateRemoveTokenForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/remove-token", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteSelfHostedRunnerFromRepoRequest generates requests for ActionsdeleteSelfHostedRunnerFromRepo
func NewActionsdeleteSelfHostedRunnerFromRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetSelfHostedRunnerForRepoRequest generates requests for ActionsgetSelfHostedRunnerForRepo
func NewActionsgetSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest generates requests for ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo
func NewActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistLabelsForSelfHostedRunnerForRepoRequest generates requests for ActionslistLabelsForSelfHostedRunnerForRepo
func NewActionslistLabelsForSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequest calls the generic ActionsaddCustomLabelsToSelfHostedRunnerForRepo builder with application/json body
func NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForRepoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequestWithBody(server, owner, repo, runnerId, "application/json", bodyReader)
}

// NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequestWithBody generates requests for ActionsaddCustomLabelsToSelfHostedRunnerForRepo with any type of body
func NewActionsaddCustomLabelsToSelfHostedRunnerForRepoRequestWithBody(server string, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequest calls the generic ActionssetCustomLabelsForSelfHostedRunnerForRepo builder with application/json body
func NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForRepoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequestWithBody(server, owner, repo, runnerId, "application/json", bodyReader)
}

// NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequestWithBody generates requests for ActionssetCustomLabelsForSelfHostedRunnerForRepo with any type of body
func NewActionssetCustomLabelsForSelfHostedRunnerForRepoRequestWithBody(server string, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsremoveCustomLabelFromSelfHostedRunnerForRepoRequest generates requests for ActionsremoveCustomLabelFromSelfHostedRunnerForRepo
func NewActionsremoveCustomLabelFromSelfHostedRunnerForRepoRequest(server string, owner Owner, repo Repo, runnerId RunnerId, name RunnerLabelName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "runner_id", runtime.ParamLocationPath, runnerId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runners/%s/labels/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistWorkflowRunsForRepoRequest generates requests for ActionslistWorkflowRunsForRepo
func NewActionslistWorkflowRunsForRepoRequest(server string, owner Owner, repo Repo, params *ActionslistWorkflowRunsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Actor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor", runtime.ParamLocationQuery, *params.Actor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Event != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExcludePullRequests != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_pull_requests", runtime.ParamLocationQuery, *params.ExcludePullRequests); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckSuiteId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "check_suite_id", runtime.ParamLocationQuery, *params.CheckSuiteId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteWorkflowRunRequest generates requests for ActionsdeleteWorkflowRun
func NewActionsdeleteWorkflowRunRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetWorkflowRunRequest generates requests for ActionsgetWorkflowRun
func NewActionsgetWorkflowRunRequest(server string, owner Owner, repo Repo, runId RunId, params *ActionsgetWorkflowRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExcludePullRequests != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_pull_requests", runtime.ParamLocationQuery, *params.ExcludePullRequests); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetReviewsForRunRequest generates requests for ActionsgetReviewsForRun
func NewActionsgetReviewsForRunRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/approvals", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsapproveWorkflowRunRequest generates requests for ActionsapproveWorkflowRun
func NewActionsapproveWorkflowRunRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/approve", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistWorkflowRunArtifactsRequest generates requests for ActionslistWorkflowRunArtifacts
func NewActionslistWorkflowRunArtifactsRequest(server string, owner Owner, repo Repo, runId RunId, params *ActionslistWorkflowRunArtifactsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/artifacts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetWorkflowRunAttemptRequest generates requests for ActionsgetWorkflowRunAttempt
func NewActionsgetWorkflowRunAttemptRequest(server string, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionsgetWorkflowRunAttemptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "attempt_number", runtime.ParamLocationPath, attemptNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/attempts/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExcludePullRequests != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_pull_requests", runtime.ParamLocationQuery, *params.ExcludePullRequests); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistJobsForWorkflowRunAttemptRequest generates requests for ActionslistJobsForWorkflowRunAttempt
func NewActionslistJobsForWorkflowRunAttemptRequest(server string, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionslistJobsForWorkflowRunAttemptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "attempt_number", runtime.ParamLocationPath, attemptNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/attempts/%s/jobs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdownloadWorkflowRunAttemptLogsRequest generates requests for ActionsdownloadWorkflowRunAttemptLogs
func NewActionsdownloadWorkflowRunAttemptLogsRequest(server string, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "attempt_number", runtime.ParamLocationPath, attemptNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/attempts/%s/logs", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscancelWorkflowRunRequest generates requests for ActionscancelWorkflowRun
func NewActionscancelWorkflowRunRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/cancel", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistJobsForWorkflowRunRequest generates requests for ActionslistJobsForWorkflowRun
func NewActionslistJobsForWorkflowRunRequest(server string, owner Owner, repo Repo, runId RunId, params *ActionslistJobsForWorkflowRunParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/jobs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteWorkflowRunLogsRequest generates requests for ActionsdeleteWorkflowRunLogs
func NewActionsdeleteWorkflowRunLogsRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdownloadWorkflowRunLogsRequest generates requests for ActionsdownloadWorkflowRunLogs
func NewActionsdownloadWorkflowRunLogsRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/logs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetPendingDeploymentsForRunRequest generates requests for ActionsgetPendingDeploymentsForRun
func NewActionsgetPendingDeploymentsForRunRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/pending_deployments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsreviewPendingDeploymentsForRunRequest calls the generic ActionsreviewPendingDeploymentsForRun builder with application/json body
func NewActionsreviewPendingDeploymentsForRunRequest(server string, owner Owner, repo Repo, runId RunId, body ActionsreviewPendingDeploymentsForRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsreviewPendingDeploymentsForRunRequestWithBody(server, owner, repo, runId, "application/json", bodyReader)
}

// NewActionsreviewPendingDeploymentsForRunRequestWithBody generates requests for ActionsreviewPendingDeploymentsForRun with any type of body
func NewActionsreviewPendingDeploymentsForRunRequestWithBody(server string, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/pending_deployments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsreRunWorkflowRequest calls the generic ActionsreRunWorkflow builder with application/json body
func NewActionsreRunWorkflowRequest(server string, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsreRunWorkflowRequestWithBody(server, owner, repo, runId, "application/json", bodyReader)
}

// NewActionsreRunWorkflowRequestWithBody generates requests for ActionsreRunWorkflow with any type of body
func NewActionsreRunWorkflowRequestWithBody(server string, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/rerun", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsreRunWorkflowFailedJobsRequest calls the generic ActionsreRunWorkflowFailedJobs builder with application/json body
func NewActionsreRunWorkflowFailedJobsRequest(server string, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowFailedJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionsreRunWorkflowFailedJobsRequestWithBody(server, owner, repo, runId, "application/json", bodyReader)
}

// NewActionsreRunWorkflowFailedJobsRequestWithBody generates requests for ActionsreRunWorkflowFailedJobs with any type of body
func NewActionsreRunWorkflowFailedJobsRequestWithBody(server string, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/rerun-failed-jobs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsgetWorkflowRunUsageRequest generates requests for ActionsgetWorkflowRunUsage
func NewActionsgetWorkflowRunUsageRequest(server string, owner Owner, repo Repo, runId RunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "run_id", runtime.ParamLocationPath, runId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/runs/%s/timing", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistRepoSecretsRequest generates requests for ActionslistRepoSecrets
func NewActionslistRepoSecretsRequest(server string, owner Owner, repo Repo, params *ActionslistRepoSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/secrets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetRepoPublicKeyRequest generates requests for ActionsgetRepoPublicKey
func NewActionsgetRepoPublicKeyRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/secrets/public-key", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteRepoSecretRequest generates requests for ActionsdeleteRepoSecret
func NewActionsdeleteRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetRepoSecretRequest generates requests for ActionsgetRepoSecret
func NewActionsgetRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateOrUpdateRepoSecretRequest calls the generic ActionscreateOrUpdateRepoSecret builder with application/json body
func NewActionscreateOrUpdateRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName, body ActionscreateOrUpdateRepoSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionscreateOrUpdateRepoSecretRequestWithBody(server, owner, repo, secretName, "application/json", bodyReader)
}

// NewActionscreateOrUpdateRepoSecretRequestWithBody generates requests for ActionscreateOrUpdateRepoSecret with any type of body
func NewActionscreateOrUpdateRepoSecretRequestWithBody(server string, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionslistRepoWorkflowsRequest generates requests for ActionslistRepoWorkflows
func NewActionslistRepoWorkflowsRequest(server string, owner Owner, repo Repo, params *ActionslistRepoWorkflowsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetWorkflowRequest generates requests for ActionsgetWorkflow
func NewActionsgetWorkflowRequest(server string, owner Owner, repo Repo, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdisableWorkflowRequest generates requests for ActionsdisableWorkflow
func NewActionsdisableWorkflowRequest(server string, owner Owner, repo Repo, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s/disable", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateWorkflowDispatchRequest calls the generic ActionscreateWorkflowDispatch builder with application/json body
func NewActionscreateWorkflowDispatchRequest(server string, owner Owner, repo Repo, workflowId WorkflowId, body ActionscreateWorkflowDispatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionscreateWorkflowDispatchRequestWithBody(server, owner, repo, workflowId, "application/json", bodyReader)
}

// NewActionscreateWorkflowDispatchRequestWithBody generates requests for ActionscreateWorkflowDispatch with any type of body
func NewActionscreateWorkflowDispatchRequestWithBody(server string, owner Owner, repo Repo, workflowId WorkflowId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s/dispatches", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActionsenableWorkflowRequest generates requests for ActionsenableWorkflow
func NewActionsenableWorkflowRequest(server string, owner Owner, repo Repo, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s/enable", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistWorkflowRunsRequest generates requests for ActionslistWorkflowRuns
func NewActionslistWorkflowRunsRequest(server string, owner Owner, repo Repo, workflowId WorkflowId, params *ActionslistWorkflowRunsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s/runs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Actor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "actor", runtime.ParamLocationQuery, *params.Actor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Branch != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "branch", runtime.ParamLocationQuery, *params.Branch); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Event != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event", runtime.ParamLocationQuery, *params.Event); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Created != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created", runtime.ParamLocationQuery, *params.Created); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExcludePullRequests != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude_pull_requests", runtime.ParamLocationQuery, *params.ExcludePullRequests); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckSuiteId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "check_suite_id", runtime.ParamLocationQuery, *params.CheckSuiteId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetWorkflowUsageRequest generates requests for ActionsgetWorkflowUsage
func NewActionsgetWorkflowUsageRequest(server string, owner Owner, repo Repo, workflowId WorkflowId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/actions/workflows/%s/timing", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistAssigneesRequest generates requests for IssueslistAssignees
func NewIssueslistAssigneesRequest(server string, owner Owner, repo Repo, params *IssueslistAssigneesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/assignees", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuescheckUserCanBeAssignedRequest generates requests for IssuescheckUserCanBeAssigned
func NewIssuescheckUserCanBeAssignedRequest(server string, owner Owner, repo Repo, assignee string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "assignee", runtime.ParamLocationPath, assignee)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/assignees/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistAutolinksRequest generates requests for ReposlistAutolinks
func NewReposlistAutolinksRequest(server string, owner Owner, repo Repo, params *ReposlistAutolinksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/autolinks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateAutolinkRequest calls the generic ReposcreateAutolink builder with application/json body
func NewReposcreateAutolinkRequest(server string, owner Owner, repo Repo, body ReposcreateAutolinkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateAutolinkRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateAutolinkRequestWithBody generates requests for ReposcreateAutolink with any type of body
func NewReposcreateAutolinkRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/autolinks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteAutolinkRequest generates requests for ReposdeleteAutolink
func NewReposdeleteAutolinkRequest(server string, owner Owner, repo Repo, autolinkId AutolinkId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "autolink_id", runtime.ParamLocationPath, autolinkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/autolinks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetAutolinkRequest generates requests for ReposgetAutolink
func NewReposgetAutolinkRequest(server string, owner Owner, repo Repo, autolinkId AutolinkId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "autolink_id", runtime.ParamLocationPath, autolinkId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/autolinks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdisableAutomatedSecurityFixesRequest generates requests for ReposdisableAutomatedSecurityFixes
func NewReposdisableAutomatedSecurityFixesRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/automated-security-fixes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposenableAutomatedSecurityFixesRequest generates requests for ReposenableAutomatedSecurityFixes
func NewReposenableAutomatedSecurityFixesRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/automated-security-fixes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistBranchesRequest generates requests for ReposlistBranches
func NewReposlistBranchesRequest(server string, owner Owner, repo Repo, params *ReposlistBranchesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Protected != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "protected", runtime.ParamLocationQuery, *params.Protected); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetBranchRequest generates requests for ReposgetBranch
func NewReposgetBranchRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteBranchProtectionRequest generates requests for ReposdeleteBranchProtection
func NewReposdeleteBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetBranchProtectionRequest generates requests for ReposgetBranchProtection
func NewReposgetBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateBranchProtectionRequest calls the generic ReposupdateBranchProtection builder with application/json body
func NewReposupdateBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch, body ReposupdateBranchProtectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateBranchProtectionRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposupdateBranchProtectionRequestWithBody generates requests for ReposupdateBranchProtection with any type of body
func NewReposupdateBranchProtectionRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteAdminBranchProtectionRequest generates requests for ReposdeleteAdminBranchProtection
func NewReposdeleteAdminBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/enforce_admins", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetAdminBranchProtectionRequest generates requests for ReposgetAdminBranchProtection
func NewReposgetAdminBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/enforce_admins", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepossetAdminBranchProtectionRequest generates requests for RepossetAdminBranchProtection
func NewRepossetAdminBranchProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/enforce_admins", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeletePullRequestReviewProtectionRequest generates requests for ReposdeletePullRequestReviewProtection
func NewReposdeletePullRequestReviewProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_pull_request_reviews", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetPullRequestReviewProtectionRequest generates requests for ReposgetPullRequestReviewProtection
func NewReposgetPullRequestReviewProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_pull_request_reviews", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdatePullRequestReviewProtectionRequest calls the generic ReposupdatePullRequestReviewProtection builder with application/json body
func NewReposupdatePullRequestReviewProtectionRequest(server string, owner Owner, repo Repo, branch Branch, body ReposupdatePullRequestReviewProtectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdatePullRequestReviewProtectionRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposupdatePullRequestReviewProtectionRequestWithBody generates requests for ReposupdatePullRequestReviewProtection with any type of body
func NewReposupdatePullRequestReviewProtectionRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_pull_request_reviews", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteCommitSignatureProtectionRequest generates requests for ReposdeleteCommitSignatureProtection
func NewReposdeleteCommitSignatureProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_signatures", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCommitSignatureProtectionRequest generates requests for ReposgetCommitSignatureProtection
func NewReposgetCommitSignatureProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_signatures", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateCommitSignatureProtectionRequest generates requests for ReposcreateCommitSignatureProtection
func NewReposcreateCommitSignatureProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_signatures", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposremoveStatusCheckProtectionRequest generates requests for ReposremoveStatusCheckProtection
func NewReposremoveStatusCheckProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetStatusChecksProtectionRequest generates requests for ReposgetStatusChecksProtection
func NewReposgetStatusChecksProtectionRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateStatusCheckProtectionRequest calls the generic ReposupdateStatusCheckProtection builder with application/json body
func NewReposupdateStatusCheckProtectionRequest(server string, owner Owner, repo Repo, branch Branch, body ReposupdateStatusCheckProtectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateStatusCheckProtectionRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposupdateStatusCheckProtectionRequestWithBody generates requests for ReposupdateStatusCheckProtection with any type of body
func NewReposupdateStatusCheckProtectionRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposremoveStatusCheckContextsRequest calls the generic ReposremoveStatusCheckContexts builder with application/json body
func NewReposremoveStatusCheckContextsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposremoveStatusCheckContextsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposremoveStatusCheckContextsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposremoveStatusCheckContextsRequestWithBody generates requests for ReposremoveStatusCheckContexts with any type of body
func NewReposremoveStatusCheckContextsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks/contexts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetAllStatusCheckContextsRequest generates requests for ReposgetAllStatusCheckContexts
func NewReposgetAllStatusCheckContextsRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks/contexts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposaddStatusCheckContextsRequest calls the generic ReposaddStatusCheckContexts builder with application/json body
func NewReposaddStatusCheckContextsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposaddStatusCheckContextsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposaddStatusCheckContextsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposaddStatusCheckContextsRequestWithBody generates requests for ReposaddStatusCheckContexts with any type of body
func NewReposaddStatusCheckContextsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks/contexts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepossetStatusCheckContextsRequest calls the generic RepossetStatusCheckContexts builder with application/json body
func NewRepossetStatusCheckContextsRequest(server string, owner Owner, repo Repo, branch Branch, body RepossetStatusCheckContextsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepossetStatusCheckContextsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewRepossetStatusCheckContextsRequestWithBody generates requests for RepossetStatusCheckContexts with any type of body
func NewRepossetStatusCheckContextsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/required_status_checks/contexts", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteAccessRestrictionsRequest generates requests for ReposdeleteAccessRestrictions
func NewReposdeleteAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetAccessRestrictionsRequest generates requests for ReposgetAccessRestrictions
func NewReposgetAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposremoveAppAccessRestrictionsRequest calls the generic ReposremoveAppAccessRestrictions builder with application/json body
func NewReposremoveAppAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposremoveAppAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposremoveAppAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposremoveAppAccessRestrictionsRequestWithBody generates requests for ReposremoveAppAccessRestrictions with any type of body
func NewReposremoveAppAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/apps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetAppsWithAccessToProtectedBranchRequest generates requests for ReposgetAppsWithAccessToProtectedBranch
func NewReposgetAppsWithAccessToProtectedBranchRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/apps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposaddAppAccessRestrictionsRequest calls the generic ReposaddAppAccessRestrictions builder with application/json body
func NewReposaddAppAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposaddAppAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposaddAppAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposaddAppAccessRestrictionsRequestWithBody generates requests for ReposaddAppAccessRestrictions with any type of body
func NewReposaddAppAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/apps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepossetAppAccessRestrictionsRequest calls the generic RepossetAppAccessRestrictions builder with application/json body
func NewRepossetAppAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body RepossetAppAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepossetAppAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewRepossetAppAccessRestrictionsRequestWithBody generates requests for RepossetAppAccessRestrictions with any type of body
func NewRepossetAppAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/apps", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposremoveTeamAccessRestrictionsRequest calls the generic ReposremoveTeamAccessRestrictions builder with application/json body
func NewReposremoveTeamAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposremoveTeamAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposremoveTeamAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposremoveTeamAccessRestrictionsRequestWithBody generates requests for ReposremoveTeamAccessRestrictions with any type of body
func NewReposremoveTeamAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/teams", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetTeamsWithAccessToProtectedBranchRequest generates requests for ReposgetTeamsWithAccessToProtectedBranch
func NewReposgetTeamsWithAccessToProtectedBranchRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/teams", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposaddTeamAccessRestrictionsRequest calls the generic ReposaddTeamAccessRestrictions builder with application/json body
func NewReposaddTeamAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposaddTeamAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposaddTeamAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposaddTeamAccessRestrictionsRequestWithBody generates requests for ReposaddTeamAccessRestrictions with any type of body
func NewReposaddTeamAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/teams", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepossetTeamAccessRestrictionsRequest calls the generic RepossetTeamAccessRestrictions builder with application/json body
func NewRepossetTeamAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body RepossetTeamAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepossetTeamAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewRepossetTeamAccessRestrictionsRequestWithBody generates requests for RepossetTeamAccessRestrictions with any type of body
func NewRepossetTeamAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/teams", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposremoveUserAccessRestrictionsRequest calls the generic ReposremoveUserAccessRestrictions builder with application/json body
func NewReposremoveUserAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposremoveUserAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposremoveUserAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposremoveUserAccessRestrictionsRequestWithBody generates requests for ReposremoveUserAccessRestrictions with any type of body
func NewReposremoveUserAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetUsersWithAccessToProtectedBranchRequest generates requests for ReposgetUsersWithAccessToProtectedBranch
func NewReposgetUsersWithAccessToProtectedBranchRequest(server string, owner Owner, repo Repo, branch Branch) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposaddUserAccessRestrictionsRequest calls the generic ReposaddUserAccessRestrictions builder with application/json body
func NewReposaddUserAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body ReposaddUserAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposaddUserAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposaddUserAccessRestrictionsRequestWithBody generates requests for ReposaddUserAccessRestrictions with any type of body
func NewReposaddUserAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRepossetUserAccessRestrictionsRequest calls the generic RepossetUserAccessRestrictions builder with application/json body
func NewRepossetUserAccessRestrictionsRequest(server string, owner Owner, repo Repo, branch Branch, body RepossetUserAccessRestrictionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepossetUserAccessRestrictionsRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewRepossetUserAccessRestrictionsRequestWithBody generates requests for RepossetUserAccessRestrictions with any type of body
func NewRepossetUserAccessRestrictionsRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/protection/restrictions/users", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposrenameBranchRequest calls the generic ReposrenameBranch builder with application/json body
func NewReposrenameBranchRequest(server string, owner Owner, repo Repo, branch Branch, body ReposrenameBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposrenameBranchRequestWithBody(server, owner, repo, branch, "application/json", bodyReader)
}

// NewReposrenameBranchRequestWithBody generates requests for ReposrenameBranch with any type of body
func NewReposrenameBranchRequestWithBody(server string, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "branch", runtime.ParamLocationPath, branch)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/branches/%s/rename", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckscreateRequest calls the generic Checkscreate builder with application/json body
func NewCheckscreateRequest(server string, owner Owner, repo Repo, body CheckscreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckscreateRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewCheckscreateRequestWithBody generates requests for Checkscreate with any type of body
func NewCheckscreateRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-runs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChecksgetRequest generates requests for Checksget
func NewChecksgetRequest(server string, owner Owner, repo Repo, checkRunId CheckRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_run_id", runtime.ParamLocationPath, checkRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChecksupdateRequest calls the generic Checksupdate builder with application/json body
func NewChecksupdateRequest(server string, owner Owner, repo Repo, checkRunId CheckRunId, body ChecksupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChecksupdateRequestWithBody(server, owner, repo, checkRunId, "application/json", bodyReader)
}

// NewChecksupdateRequestWithBody generates requests for Checksupdate with any type of body
func NewChecksupdateRequestWithBody(server string, owner Owner, repo Repo, checkRunId CheckRunId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_run_id", runtime.ParamLocationPath, checkRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-runs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckslistAnnotationsRequest generates requests for CheckslistAnnotations
func NewCheckslistAnnotationsRequest(server string, owner Owner, repo Repo, checkRunId CheckRunId, params *CheckslistAnnotationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_run_id", runtime.ParamLocationPath, checkRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-runs/%s/annotations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChecksrerequestRunRequest generates requests for ChecksrerequestRun
func NewChecksrerequestRunRequest(server string, owner Owner, repo Repo, checkRunId CheckRunId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_run_id", runtime.ParamLocationPath, checkRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-runs/%s/rerequest", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckscreateSuiteRequest calls the generic CheckscreateSuite builder with application/json body
func NewCheckscreateSuiteRequest(server string, owner Owner, repo Repo, body CheckscreateSuiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckscreateSuiteRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewCheckscreateSuiteRequestWithBody generates requests for CheckscreateSuite with any type of body
func NewCheckscreateSuiteRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-suites", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckssetSuitesPreferencesRequest calls the generic CheckssetSuitesPreferences builder with application/json body
func NewCheckssetSuitesPreferencesRequest(server string, owner Owner, repo Repo, body CheckssetSuitesPreferencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckssetSuitesPreferencesRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewCheckssetSuitesPreferencesRequestWithBody generates requests for CheckssetSuitesPreferences with any type of body
func NewCheckssetSuitesPreferencesRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-suites/preferences", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewChecksgetSuiteRequest generates requests for ChecksgetSuite
func NewChecksgetSuiteRequest(server string, owner Owner, repo Repo, checkSuiteId CheckSuiteId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_suite_id", runtime.ParamLocationPath, checkSuiteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-suites/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckslistForSuiteRequest generates requests for CheckslistForSuite
func NewCheckslistForSuiteRequest(server string, owner Owner, repo Repo, checkSuiteId CheckSuiteId, params *CheckslistForSuiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_suite_id", runtime.ParamLocationPath, checkSuiteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-suites/%s/check-runs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CheckName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "check_name", runtime.ParamLocationQuery, *params.CheckName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChecksrerequestSuiteRequest generates requests for ChecksrerequestSuite
func NewChecksrerequestSuiteRequest(server string, owner Owner, repo Repo, checkSuiteId CheckSuiteId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "check_suite_id", runtime.ParamLocationPath, checkSuiteId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/check-suites/%s/rerequest", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninglistAlertsForRepoRequest generates requests for CodeScanninglistAlertsForRepo
func NewCodeScanninglistAlertsForRepoRequest(server string, owner Owner, repo Repo, params *CodeScanninglistAlertsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/alerts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ToolName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_name", runtime.ParamLocationQuery, *params.ToolName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolGuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_guid", runtime.ParamLocationQuery, *params.ToolGuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninggetAlertRequest generates requests for CodeScanninggetAlert
func NewCodeScanninggetAlertRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/alerts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanningupdateAlertRequest calls the generic CodeScanningupdateAlert builder with application/json body
func NewCodeScanningupdateAlertRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber, body CodeScanningupdateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeScanningupdateAlertRequestWithBody(server, owner, repo, alertNumber, "application/json", bodyReader)
}

// NewCodeScanningupdateAlertRequestWithBody generates requests for CodeScanningupdateAlert with any type of body
func NewCodeScanningupdateAlertRequestWithBody(server string, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/alerts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeScanninglistAlertInstancesRequest generates requests for CodeScanninglistAlertInstances
func NewCodeScanninglistAlertInstancesRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber, params *CodeScanninglistAlertInstancesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/alerts/%s/instances", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninglistRecentAnalysesRequest generates requests for CodeScanninglistRecentAnalyses
func NewCodeScanninglistRecentAnalysesRequest(server string, owner Owner, repo Repo, params *CodeScanninglistRecentAnalysesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/analyses", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ToolName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_name", runtime.ParamLocationQuery, *params.ToolName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ToolGuid != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tool_guid", runtime.ParamLocationQuery, *params.ToolGuid); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SarifId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sarif_id", runtime.ParamLocationQuery, *params.SarifId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanningdeleteAnalysisRequest generates requests for CodeScanningdeleteAnalysis
func NewCodeScanningdeleteAnalysisRequest(server string, owner Owner, repo Repo, analysisId int, params *CodeScanningdeleteAnalysisParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analysis_id", runtime.ParamLocationPath, analysisId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/analyses/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ConfirmDelete != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "confirm_delete", runtime.ParamLocationQuery, *params.ConfirmDelete); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninggetAnalysisRequest generates requests for CodeScanninggetAnalysis
func NewCodeScanninggetAnalysisRequest(server string, owner Owner, repo Repo, analysisId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "analysis_id", runtime.ParamLocationPath, analysisId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/analyses/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodeScanninguploadSarifRequest calls the generic CodeScanninguploadSarif builder with application/json body
func NewCodeScanninguploadSarifRequest(server string, owner Owner, repo Repo, body CodeScanninguploadSarifJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodeScanninguploadSarifRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewCodeScanninguploadSarifRequestWithBody generates requests for CodeScanninguploadSarif with any type of body
func NewCodeScanninguploadSarifRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/sarifs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodeScanninggetSarifRequest generates requests for CodeScanninggetSarif
func NewCodeScanninggetSarifRequest(server string, owner Owner, repo Repo, sarifId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sarif_id", runtime.ParamLocationPath, sarifId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/code-scanning/sarifs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcodeownersErrorsRequest generates requests for ReposcodeownersErrors
func NewReposcodeownersErrorsRequest(server string, owner Owner, repo Repo, params *ReposcodeownersErrorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codeowners/errors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespaceslistInRepositoryForAuthenticatedUserRequest generates requests for CodespaceslistInRepositoryForAuthenticatedUser
func NewCodespaceslistInRepositoryForAuthenticatedUserRequest(server string, owner Owner, repo Repo, params *CodespaceslistInRepositoryForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacescreateWithRepoForAuthenticatedUserRequest calls the generic CodespacescreateWithRepoForAuthenticatedUser builder with application/json body
func NewCodespacescreateWithRepoForAuthenticatedUserRequest(server string, owner Owner, repo Repo, body CodespacescreateWithRepoForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacescreateWithRepoForAuthenticatedUserRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewCodespacescreateWithRepoForAuthenticatedUserRequestWithBody generates requests for CodespacescreateWithRepoForAuthenticatedUser with any type of body
func NewCodespacescreateWithRepoForAuthenticatedUserRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespaceslistDevcontainersInRepositoryForAuthenticatedUserRequest generates requests for CodespaceslistDevcontainersInRepositoryForAuthenticatedUser
func NewCodespaceslistDevcontainersInRepositoryForAuthenticatedUserRequest(server string, owner Owner, repo Repo, params *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/devcontainers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesrepoMachinesForAuthenticatedUserRequest generates requests for CodespacesrepoMachinesForAuthenticatedUser
func NewCodespacesrepoMachinesForAuthenticatedUserRequest(server string, owner Owner, repo Repo, params *CodespacesrepoMachinesForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/machines", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Location != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ClientIp != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_ip", runtime.ParamLocationQuery, *params.ClientIp); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespaceslistRepoSecretsRequest generates requests for CodespaceslistRepoSecrets
func NewCodespaceslistRepoSecretsRequest(server string, owner Owner, repo Repo, params *CodespaceslistRepoSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/secrets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetRepoPublicKeyRequest generates requests for CodespacesgetRepoPublicKey
func NewCodespacesgetRepoPublicKeyRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/secrets/public-key", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesdeleteRepoSecretRequest generates requests for CodespacesdeleteRepoSecret
func NewCodespacesdeleteRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetRepoSecretRequest generates requests for CodespacesgetRepoSecret
func NewCodespacesgetRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacescreateOrUpdateRepoSecretRequest calls the generic CodespacescreateOrUpdateRepoSecret builder with application/json body
func NewCodespacescreateOrUpdateRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName, body CodespacescreateOrUpdateRepoSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacescreateOrUpdateRepoSecretRequestWithBody(server, owner, repo, secretName, "application/json", bodyReader)
}

// NewCodespacescreateOrUpdateRepoSecretRequestWithBody generates requests for CodespacescreateOrUpdateRepoSecret with any type of body
func NewCodespacescreateOrUpdateRepoSecretRequestWithBody(server string, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/codespaces/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistCollaboratorsRequest generates requests for ReposlistCollaborators
func NewReposlistCollaboratorsRequest(server string, owner Owner, repo Repo, params *ReposlistCollaboratorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/collaborators", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Affiliation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "affiliation", runtime.ParamLocationQuery, *params.Affiliation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposremoveCollaboratorRequest generates requests for ReposremoveCollaborator
func NewReposremoveCollaboratorRequest(server string, owner Owner, repo Repo, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/collaborators/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcheckCollaboratorRequest generates requests for ReposcheckCollaborator
func NewReposcheckCollaboratorRequest(server string, owner Owner, repo Repo, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/collaborators/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposaddCollaboratorRequest calls the generic ReposaddCollaborator builder with application/json body
func NewReposaddCollaboratorRequest(server string, owner Owner, repo Repo, username Username, body ReposaddCollaboratorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposaddCollaboratorRequestWithBody(server, owner, repo, username, "application/json", bodyReader)
}

// NewReposaddCollaboratorRequestWithBody generates requests for ReposaddCollaborator with any type of body
func NewReposaddCollaboratorRequestWithBody(server string, owner Owner, repo Repo, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/collaborators/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetCollaboratorPermissionLevelRequest generates requests for ReposgetCollaboratorPermissionLevel
func NewReposgetCollaboratorPermissionLevelRequest(server string, owner Owner, repo Repo, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/collaborators/%s/permission", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistCommitCommentsForRepoRequest generates requests for ReposlistCommitCommentsForRepo
func NewReposlistCommitCommentsForRepoRequest(server string, owner Owner, repo Repo, params *ReposlistCommitCommentsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteCommitCommentRequest generates requests for ReposdeleteCommitComment
func NewReposdeleteCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCommitCommentRequest generates requests for ReposgetCommitComment
func NewReposgetCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateCommitCommentRequest calls the generic ReposupdateCommitComment builder with application/json body
func NewReposupdateCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body ReposupdateCommitCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateCommitCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewReposupdateCommitCommentRequestWithBody generates requests for ReposupdateCommitComment with any type of body
func NewReposupdateCommitCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForCommitCommentRequest generates requests for ReactionslistForCommitComment
func NewReactionslistForCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForCommitCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForCommitCommentRequest calls the generic ReactionscreateForCommitComment builder with application/json body
func NewReactionscreateForCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForCommitCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForCommitCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewReactionscreateForCommitCommentRequestWithBody generates requests for ReactionscreateForCommitComment with any type of body
func NewReactionscreateForCommitCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForCommitCommentRequest generates requests for ReactionsdeleteForCommitComment
func NewReactionsdeleteForCommitCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistCommitsRequest generates requests for ReposlistCommits
func NewReposlistCommitsRequest(server string, owner Owner, repo Repo, params *ReposlistCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Path != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, *params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Author != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "author", runtime.ParamLocationQuery, *params.Author); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Until != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "until", runtime.ParamLocationQuery, *params.Until); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistBranchesForHeadCommitRequest generates requests for ReposlistBranchesForHeadCommit
func NewReposlistBranchesForHeadCommitRequest(server string, owner Owner, repo Repo, commitSha CommitSha) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commit_sha", runtime.ParamLocationPath, commitSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/branches-where-head", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistCommentsForCommitRequest generates requests for ReposlistCommentsForCommit
func NewReposlistCommentsForCommitRequest(server string, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistCommentsForCommitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commit_sha", runtime.ParamLocationPath, commitSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateCommitCommentRequest calls the generic ReposcreateCommitComment builder with application/json body
func NewReposcreateCommitCommentRequest(server string, owner Owner, repo Repo, commitSha CommitSha, body ReposcreateCommitCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateCommitCommentRequestWithBody(server, owner, repo, commitSha, "application/json", bodyReader)
}

// NewReposcreateCommitCommentRequestWithBody generates requests for ReposcreateCommitComment with any type of body
func NewReposcreateCommitCommentRequestWithBody(server string, owner Owner, repo Repo, commitSha CommitSha, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commit_sha", runtime.ParamLocationPath, commitSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistPullRequestsAssociatedWithCommitRequest generates requests for ReposlistPullRequestsAssociatedWithCommit
func NewReposlistPullRequestsAssociatedWithCommitRequest(server string, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistPullRequestsAssociatedWithCommitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commit_sha", runtime.ParamLocationPath, commitSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/pulls", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCommitRequest generates requests for ReposgetCommit
func NewReposgetCommitRequest(server string, owner Owner, repo Repo, ref string, params *ReposgetCommitParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckslistForRefRequest generates requests for CheckslistForRef
func NewCheckslistForRefRequest(server string, owner Owner, repo Repo, ref string, params *CheckslistForRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/check-runs", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.CheckName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "check_name", runtime.ParamLocationQuery, *params.CheckName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Status != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.AppId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckslistSuitesForRefRequest generates requests for CheckslistSuitesForRef
func NewCheckslistSuitesForRefRequest(server string, owner Owner, repo Repo, ref string, params *CheckslistSuitesForRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/check-suites", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.AppId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "app_id", runtime.ParamLocationQuery, *params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CheckName != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "check_name", runtime.ParamLocationQuery, *params.CheckName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCombinedStatusForRefRequest generates requests for ReposgetCombinedStatusForRef
func NewReposgetCombinedStatusForRefRequest(server string, owner Owner, repo Repo, ref string, params *ReposgetCombinedStatusForRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/status", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistCommitStatusesForRefRequest generates requests for ReposlistCommitStatusesForRef
func NewReposlistCommitStatusesForRefRequest(server string, owner Owner, repo Repo, ref string, params *ReposlistCommitStatusesForRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/commits/%s/statuses", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCommunityProfileMetricsRequest generates requests for ReposgetCommunityProfileMetrics
func NewReposgetCommunityProfileMetricsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/community/profile", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcompareCommitsRequest generates requests for ReposcompareCommits
func NewReposcompareCommitsRequest(server string, owner Owner, repo Repo, basehead string, params *ReposcompareCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "basehead", runtime.ParamLocationPath, basehead)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/compare/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteFileRequest calls the generic ReposdeleteFile builder with application/json body
func NewReposdeleteFileRequest(server string, owner Owner, repo Repo, path string, body ReposdeleteFileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposdeleteFileRequestWithBody(server, owner, repo, path, "application/json", bodyReader)
}

// NewReposdeleteFileRequestWithBody generates requests for ReposdeleteFile with any type of body
func NewReposdeleteFileRequestWithBody(server string, owner Owner, repo Repo, path string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetContentRequest generates requests for ReposgetContent
func NewReposgetContentRequest(server string, owner Owner, repo Repo, path string, params *ReposgetContentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateOrUpdateFileContentsRequest calls the generic ReposcreateOrUpdateFileContents builder with application/json body
func NewReposcreateOrUpdateFileContentsRequest(server string, owner Owner, repo Repo, path string, body ReposcreateOrUpdateFileContentsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateOrUpdateFileContentsRequestWithBody(server, owner, repo, path, "application/json", bodyReader)
}

// NewReposcreateOrUpdateFileContentsRequestWithBody generates requests for ReposcreateOrUpdateFileContents with any type of body
func NewReposcreateOrUpdateFileContentsRequestWithBody(server string, owner Owner, repo Repo, path string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "path", runtime.ParamLocationPath, path)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistContributorsRequest generates requests for ReposlistContributors
func NewReposlistContributorsRequest(server string, owner Owner, repo Repo, params *ReposlistContributorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/contributors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Anon != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anon", runtime.ParamLocationQuery, *params.Anon); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotlistRepoSecretsRequest generates requests for DependabotlistRepoSecrets
func NewDependabotlistRepoSecretsRequest(server string, owner Owner, repo Repo, params *DependabotlistRepoSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependabot/secrets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotgetRepoPublicKeyRequest generates requests for DependabotgetRepoPublicKey
func NewDependabotgetRepoPublicKeyRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependabot/secrets/public-key", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotdeleteRepoSecretRequest generates requests for DependabotdeleteRepoSecret
func NewDependabotdeleteRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependabot/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotgetRepoSecretRequest generates requests for DependabotgetRepoSecret
func NewDependabotgetRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependabot/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDependabotcreateOrUpdateRepoSecretRequest calls the generic DependabotcreateOrUpdateRepoSecret builder with application/json body
func NewDependabotcreateOrUpdateRepoSecretRequest(server string, owner Owner, repo Repo, secretName SecretName, body DependabotcreateOrUpdateRepoSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDependabotcreateOrUpdateRepoSecretRequestWithBody(server, owner, repo, secretName, "application/json", bodyReader)
}

// NewDependabotcreateOrUpdateRepoSecretRequestWithBody generates requests for DependabotcreateOrUpdateRepoSecret with any type of body
func NewDependabotcreateOrUpdateRepoSecretRequestWithBody(server string, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependabot/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDependencyGraphdiffRangeRequest generates requests for DependencyGraphdiffRange
func NewDependencyGraphdiffRangeRequest(server string, owner Owner, repo Repo, basehead string, params *DependencyGraphdiffRangeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "basehead", runtime.ParamLocationPath, basehead)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dependency-graph/compare/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Name != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistDeploymentsRequest generates requests for ReposlistDeployments
func NewReposlistDeploymentsRequest(server string, owner Owner, repo Repo, params *ReposlistDeploymentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sha != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sha", runtime.ParamLocationQuery, *params.Sha); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Task != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "task", runtime.ParamLocationQuery, *params.Task); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Environment != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "environment", runtime.ParamLocationQuery, *params.Environment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateDeploymentRequest calls the generic ReposcreateDeployment builder with application/json body
func NewReposcreateDeploymentRequest(server string, owner Owner, repo Repo, body ReposcreateDeploymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateDeploymentRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateDeploymentRequestWithBody generates requests for ReposcreateDeployment with any type of body
func NewReposcreateDeploymentRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteDeploymentRequest generates requests for ReposdeleteDeployment
func NewReposdeleteDeploymentRequest(server string, owner Owner, repo Repo, deploymentId DeploymentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deployment_id", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetDeploymentRequest generates requests for ReposgetDeployment
func NewReposgetDeploymentRequest(server string, owner Owner, repo Repo, deploymentId DeploymentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deployment_id", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistDeploymentStatusesRequest generates requests for ReposlistDeploymentStatuses
func NewReposlistDeploymentStatusesRequest(server string, owner Owner, repo Repo, deploymentId DeploymentId, params *ReposlistDeploymentStatusesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deployment_id", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments/%s/statuses", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateDeploymentStatusRequest calls the generic ReposcreateDeploymentStatus builder with application/json body
func NewReposcreateDeploymentStatusRequest(server string, owner Owner, repo Repo, deploymentId DeploymentId, body ReposcreateDeploymentStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateDeploymentStatusRequestWithBody(server, owner, repo, deploymentId, "application/json", bodyReader)
}

// NewReposcreateDeploymentStatusRequestWithBody generates requests for ReposcreateDeploymentStatus with any type of body
func NewReposcreateDeploymentStatusRequestWithBody(server string, owner Owner, repo Repo, deploymentId DeploymentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deployment_id", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments/%s/statuses", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetDeploymentStatusRequest generates requests for ReposgetDeploymentStatus
func NewReposgetDeploymentStatusRequest(server string, owner Owner, repo Repo, deploymentId DeploymentId, statusId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "deployment_id", runtime.ParamLocationPath, deploymentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "status_id", runtime.ParamLocationPath, statusId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/deployments/%s/statuses/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateDispatchEventRequest calls the generic ReposcreateDispatchEvent builder with application/json body
func NewReposcreateDispatchEventRequest(server string, owner Owner, repo Repo, body ReposcreateDispatchEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateDispatchEventRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateDispatchEventRequestWithBody generates requests for ReposcreateDispatchEvent with any type of body
func NewReposcreateDispatchEventRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/dispatches", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetAllEnvironmentsRequest generates requests for ReposgetAllEnvironments
func NewReposgetAllEnvironmentsRequest(server string, owner Owner, repo Repo, params *ReposgetAllEnvironmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/environments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteAnEnvironmentRequest generates requests for ReposdeleteAnEnvironment
func NewReposdeleteAnEnvironmentRequest(server string, owner Owner, repo Repo, environmentName EnvironmentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/environments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetEnvironmentRequest generates requests for ReposgetEnvironment
func NewReposgetEnvironmentRequest(server string, owner Owner, repo Repo, environmentName EnvironmentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/environments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateOrUpdateEnvironmentRequest calls the generic ReposcreateOrUpdateEnvironment builder with application/json body
func NewReposcreateOrUpdateEnvironmentRequest(server string, owner Owner, repo Repo, environmentName EnvironmentName, body ReposcreateOrUpdateEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateOrUpdateEnvironmentRequestWithBody(server, owner, repo, environmentName, "application/json", bodyReader)
}

// NewReposcreateOrUpdateEnvironmentRequestWithBody generates requests for ReposcreateOrUpdateEnvironment with any type of body
func NewReposcreateOrUpdateEnvironmentRequestWithBody(server string, owner Owner, repo Repo, environmentName EnvironmentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/environments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivitylistRepoEventsRequest generates requests for ActivitylistRepoEvents
func NewActivitylistRepoEventsRequest(server string, owner Owner, repo Repo, params *ActivitylistRepoEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistForksRequest generates requests for ReposlistForks
func NewReposlistForksRequest(server string, owner Owner, repo Repo, params *ReposlistForksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/forks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateForkRequest calls the generic ReposcreateFork builder with application/json body
func NewReposcreateForkRequest(server string, owner Owner, repo Repo, body ReposcreateForkJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateForkRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateForkRequestWithBody generates requests for ReposcreateFork with any type of body
func NewReposcreateForkRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/forks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitcreateBlobRequest calls the generic GitcreateBlob builder with application/json body
func NewGitcreateBlobRequest(server string, owner Owner, repo Repo, body GitcreateBlobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitcreateBlobRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewGitcreateBlobRequestWithBody generates requests for GitcreateBlob with any type of body
func NewGitcreateBlobRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/blobs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitgetBlobRequest generates requests for GitgetBlob
func NewGitgetBlobRequest(server string, owner Owner, repo Repo, fileSha string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "file_sha", runtime.ParamLocationPath, fileSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/blobs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitcreateCommitRequest calls the generic GitcreateCommit builder with application/json body
func NewGitcreateCommitRequest(server string, owner Owner, repo Repo, body GitcreateCommitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitcreateCommitRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewGitcreateCommitRequestWithBody generates requests for GitcreateCommit with any type of body
func NewGitcreateCommitRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/commits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitgetCommitRequest generates requests for GitgetCommit
func NewGitgetCommitRequest(server string, owner Owner, repo Repo, commitSha CommitSha) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "commit_sha", runtime.ParamLocationPath, commitSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/commits/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitlistMatchingRefsRequest generates requests for GitlistMatchingRefs
func NewGitlistMatchingRefsRequest(server string, owner Owner, repo Repo, ref string, params *GitlistMatchingRefsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/matching-refs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitgetRefRequest generates requests for GitgetRef
func NewGitgetRefRequest(server string, owner Owner, repo Repo, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/ref/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitcreateRefRequest calls the generic GitcreateRef builder with application/json body
func NewGitcreateRefRequest(server string, owner Owner, repo Repo, body GitcreateRefJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitcreateRefRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewGitcreateRefRequestWithBody generates requests for GitcreateRef with any type of body
func NewGitcreateRefRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/refs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitdeleteRefRequest generates requests for GitdeleteRef
func NewGitdeleteRefRequest(server string, owner Owner, repo Repo, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/refs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitupdateRefRequest calls the generic GitupdateRef builder with application/json body
func NewGitupdateRefRequest(server string, owner Owner, repo Repo, ref string, body GitupdateRefJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitupdateRefRequestWithBody(server, owner, repo, ref, "application/json", bodyReader)
}

// NewGitupdateRefRequestWithBody generates requests for GitupdateRef with any type of body
func NewGitupdateRefRequestWithBody(server string, owner Owner, repo Repo, ref string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/refs/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitcreateTagRequest calls the generic GitcreateTag builder with application/json body
func NewGitcreateTagRequest(server string, owner Owner, repo Repo, body GitcreateTagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitcreateTagRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewGitcreateTagRequestWithBody generates requests for GitcreateTag with any type of body
func NewGitcreateTagRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitgetTagRequest generates requests for GitgetTag
func NewGitgetTagRequest(server string, owner Owner, repo Repo, tagSha string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tag_sha", runtime.ParamLocationPath, tagSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGitcreateTreeRequest calls the generic GitcreateTree builder with application/json body
func NewGitcreateTreeRequest(server string, owner Owner, repo Repo, body GitcreateTreeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGitcreateTreeRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewGitcreateTreeRequestWithBody generates requests for GitcreateTree with any type of body
func NewGitcreateTreeRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/trees", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGitgetTreeRequest generates requests for GitgetTree
func NewGitgetTreeRequest(server string, owner Owner, repo Repo, treeSha string, params *GitgetTreeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tree_sha", runtime.ParamLocationPath, treeSha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/git/trees/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Recursive != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recursive", runtime.ParamLocationQuery, *params.Recursive); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistWebhooksRequest generates requests for ReposlistWebhooks
func NewReposlistWebhooksRequest(server string, owner Owner, repo Repo, params *ReposlistWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateWebhookRequest calls the generic ReposcreateWebhook builder with application/json body
func NewReposcreateWebhookRequest(server string, owner Owner, repo Repo, body ReposcreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateWebhookRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateWebhookRequestWithBody generates requests for ReposcreateWebhook with any type of body
func NewReposcreateWebhookRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteWebhookRequest generates requests for ReposdeleteWebhook
func NewReposdeleteWebhookRequest(server string, owner Owner, repo Repo, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetWebhookRequest generates requests for ReposgetWebhook
func NewReposgetWebhookRequest(server string, owner Owner, repo Repo, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateWebhookRequest calls the generic ReposupdateWebhook builder with application/json body
func NewReposupdateWebhookRequest(server string, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateWebhookRequestWithBody(server, owner, repo, hookId, "application/json", bodyReader)
}

// NewReposupdateWebhookRequestWithBody generates requests for ReposupdateWebhook with any type of body
func NewReposupdateWebhookRequestWithBody(server string, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetWebhookConfigForRepoRequest generates requests for ReposgetWebhookConfigForRepo
func NewReposgetWebhookConfigForRepoRequest(server string, owner Owner, repo Repo, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateWebhookConfigForRepoRequest calls the generic ReposupdateWebhookConfigForRepo builder with application/json body
func NewReposupdateWebhookConfigForRepoRequest(server string, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookConfigForRepoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateWebhookConfigForRepoRequestWithBody(server, owner, repo, hookId, "application/json", bodyReader)
}

// NewReposupdateWebhookConfigForRepoRequestWithBody generates requests for ReposupdateWebhookConfigForRepo with any type of body
func NewReposupdateWebhookConfigForRepoRequestWithBody(server string, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/config", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistWebhookDeliveriesRequest generates requests for ReposlistWebhookDeliveries
func NewReposlistWebhookDeliveriesRequest(server string, owner Owner, repo Repo, hookId HookId, params *ReposlistWebhookDeliveriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/deliveries", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Cursor != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetWebhookDeliveryRequest generates requests for ReposgetWebhookDelivery
func NewReposgetWebhookDeliveryRequest(server string, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/deliveries/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposredeliverWebhookDeliveryRequest generates requests for ReposredeliverWebhookDelivery
func NewReposredeliverWebhookDeliveryRequest(server string, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "delivery_id", runtime.ParamLocationPath, deliveryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/deliveries/%s/attempts", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepospingWebhookRequest generates requests for RepospingWebhook
func NewRepospingWebhookRequest(server string, owner Owner, repo Repo, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/pings", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepostestPushWebhookRequest generates requests for RepostestPushWebhook
func NewRepostestPushWebhookRequest(server string, owner Owner, repo Repo, hookId HookId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "hook_id", runtime.ParamLocationPath, hookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/hooks/%s/tests", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationscancelImportRequest generates requests for MigrationscancelImport
func NewMigrationscancelImportRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsgetImportStatusRequest generates requests for MigrationsgetImportStatus
func NewMigrationsgetImportStatusRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsupdateImportRequest calls the generic MigrationsupdateImport builder with application/json body
func NewMigrationsupdateImportRequest(server string, owner Owner, repo Repo, body MigrationsupdateImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationsupdateImportRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewMigrationsupdateImportRequestWithBody generates requests for MigrationsupdateImport with any type of body
func NewMigrationsupdateImportRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationsstartImportRequest calls the generic MigrationsstartImport builder with application/json body
func NewMigrationsstartImportRequest(server string, owner Owner, repo Repo, body MigrationsstartImportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationsstartImportRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewMigrationsstartImportRequestWithBody generates requests for MigrationsstartImport with any type of body
func NewMigrationsstartImportRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationsgetCommitAuthorsRequest generates requests for MigrationsgetCommitAuthors
func NewMigrationsgetCommitAuthorsRequest(server string, owner Owner, repo Repo, params *MigrationsgetCommitAuthorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import/authors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsmapCommitAuthorRequest calls the generic MigrationsmapCommitAuthor builder with application/json body
func NewMigrationsmapCommitAuthorRequest(server string, owner Owner, repo Repo, authorId int, body MigrationsmapCommitAuthorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationsmapCommitAuthorRequestWithBody(server, owner, repo, authorId, "application/json", bodyReader)
}

// NewMigrationsmapCommitAuthorRequestWithBody generates requests for MigrationsmapCommitAuthor with any type of body
func NewMigrationsmapCommitAuthorRequestWithBody(server string, owner Owner, repo Repo, authorId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "author_id", runtime.ParamLocationPath, authorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import/authors/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationsgetLargeFilesRequest generates requests for MigrationsgetLargeFiles
func NewMigrationsgetLargeFilesRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import/large_files", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationssetLfsPreferenceRequest calls the generic MigrationssetLfsPreference builder with application/json body
func NewMigrationssetLfsPreferenceRequest(server string, owner Owner, repo Repo, body MigrationssetLfsPreferenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationssetLfsPreferenceRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewMigrationssetLfsPreferenceRequestWithBody generates requests for MigrationssetLfsPreference with any type of body
func NewMigrationssetLfsPreferenceRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/import/lfs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAppsgetRepoInstallationRequest generates requests for AppsgetRepoInstallation
func NewAppsgetRepoInstallationRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/installation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsremoveRestrictionsForRepoRequest generates requests for InteractionsremoveRestrictionsForRepo
func NewInteractionsremoveRestrictionsForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/interaction-limits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsgetRestrictionsForRepoRequest generates requests for InteractionsgetRestrictionsForRepo
func NewInteractionsgetRestrictionsForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/interaction-limits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionssetRestrictionsForRepoRequest calls the generic InteractionssetRestrictionsForRepo builder with application/json body
func NewInteractionssetRestrictionsForRepoRequest(server string, owner Owner, repo Repo, body InteractionssetRestrictionsForRepoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInteractionssetRestrictionsForRepoRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewInteractionssetRestrictionsForRepoRequestWithBody generates requests for InteractionssetRestrictionsForRepo with any type of body
func NewInteractionssetRestrictionsForRepoRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/interaction-limits", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistInvitationsRequest generates requests for ReposlistInvitations
func NewReposlistInvitationsRequest(server string, owner Owner, repo Repo, params *ReposlistInvitationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/invitations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteInvitationRequest generates requests for ReposdeleteInvitation
func NewReposdeleteInvitationRequest(server string, owner Owner, repo Repo, invitationId InvitationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/invitations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateInvitationRequest calls the generic ReposupdateInvitation builder with application/json body
func NewReposupdateInvitationRequest(server string, owner Owner, repo Repo, invitationId InvitationId, body ReposupdateInvitationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateInvitationRequestWithBody(server, owner, repo, invitationId, "application/json", bodyReader)
}

// NewReposupdateInvitationRequestWithBody generates requests for ReposupdateInvitation with any type of body
func NewReposupdateInvitationRequestWithBody(server string, owner Owner, repo Repo, invitationId InvitationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/invitations/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistForRepoRequest generates requests for IssueslistForRepo
func NewIssueslistForRepoRequest(server string, owner Owner, repo Repo, params *IssueslistForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Milestone != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "milestone", runtime.ParamLocationQuery, *params.Milestone); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Assignee != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignee", runtime.ParamLocationQuery, *params.Assignee); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Creator != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creator", runtime.ParamLocationQuery, *params.Creator); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Mentioned != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentioned", runtime.ParamLocationQuery, *params.Mentioned); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Labels != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuescreateRequest calls the generic Issuescreate builder with application/json body
func NewIssuescreateRequest(server string, owner Owner, repo Repo, body IssuescreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuescreateRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewIssuescreateRequestWithBody generates requests for Issuescreate with any type of body
func NewIssuescreateRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistCommentsForRepoRequest generates requests for IssueslistCommentsForRepo
func NewIssueslistCommentsForRepoRequest(server string, owner Owner, repo Repo, params *IssueslistCommentsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesdeleteCommentRequest generates requests for IssuesdeleteComment
func NewIssuesdeleteCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesgetCommentRequest generates requests for IssuesgetComment
func NewIssuesgetCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesupdateCommentRequest calls the generic IssuesupdateComment builder with application/json body
func NewIssuesupdateCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body IssuesupdateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesupdateCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewIssuesupdateCommentRequestWithBody generates requests for IssuesupdateComment with any type of body
func NewIssuesupdateCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForIssueCommentRequest generates requests for ReactionslistForIssueComment
func NewReactionslistForIssueCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForIssueCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForIssueCommentRequest calls the generic ReactionscreateForIssueComment builder with application/json body
func NewReactionscreateForIssueCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForIssueCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForIssueCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewReactionscreateForIssueCommentRequestWithBody generates requests for ReactionscreateForIssueComment with any type of body
func NewReactionscreateForIssueCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForIssueCommentRequest generates requests for ReactionsdeleteForIssueComment
func NewReactionsdeleteForIssueCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistEventsForRepoRequest generates requests for IssueslistEventsForRepo
func NewIssueslistEventsForRepoRequest(server string, owner Owner, repo Repo, params *IssueslistEventsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/events", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesgetEventRequest generates requests for IssuesgetEvent
func NewIssuesgetEventRequest(server string, owner Owner, repo Repo, eventId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "event_id", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/events/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesgetRequest generates requests for Issuesget
func NewIssuesgetRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesupdateRequest calls the generic Issuesupdate builder with application/json body
func NewIssuesupdateRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesupdateRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuesupdateRequestWithBody generates requests for Issuesupdate with any type of body
func NewIssuesupdateRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesremoveAssigneesRequest calls the generic IssuesremoveAssignees builder with application/json body
func NewIssuesremoveAssigneesRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesremoveAssigneesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesremoveAssigneesRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuesremoveAssigneesRequestWithBody generates requests for IssuesremoveAssignees with any type of body
func NewIssuesremoveAssigneesRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/assignees", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesaddAssigneesRequest calls the generic IssuesaddAssignees builder with application/json body
func NewIssuesaddAssigneesRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddAssigneesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesaddAssigneesRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuesaddAssigneesRequestWithBody generates requests for IssuesaddAssignees with any type of body
func NewIssuesaddAssigneesRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/assignees", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistCommentsRequest generates requests for IssueslistComments
func NewIssueslistCommentsRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuescreateCommentRequest calls the generic IssuescreateComment builder with application/json body
func NewIssuescreateCommentRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuescreateCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuescreateCommentRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuescreateCommentRequestWithBody generates requests for IssuescreateComment with any type of body
func NewIssuescreateCommentRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistEventsRequest generates requests for IssueslistEvents
func NewIssueslistEventsRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/events", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesremoveAllLabelsRequest generates requests for IssuesremoveAllLabels
func NewIssuesremoveAllLabelsRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistLabelsOnIssueRequest generates requests for IssueslistLabelsOnIssue
func NewIssueslistLabelsOnIssueRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistLabelsOnIssueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesaddLabelsRequest calls the generic IssuesaddLabels builder with application/json body
func NewIssuesaddLabelsRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesaddLabelsRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuesaddLabelsRequestWithBody generates requests for IssuesaddLabels with any type of body
func NewIssuesaddLabelsRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuessetLabelsRequest calls the generic IssuessetLabels builder with application/json body
func NewIssuessetLabelsRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssuessetLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuessetLabelsRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssuessetLabelsRequestWithBody generates requests for IssuessetLabels with any type of body
func NewIssuessetLabelsRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesremoveLabelRequest generates requests for IssuesremoveLabel
func NewIssuesremoveLabelRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/labels/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesunlockRequest generates requests for Issuesunlock
func NewIssuesunlockRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/lock", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslockRequest calls the generic Issueslock builder with application/json body
func NewIssueslockRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body IssueslockJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssueslockRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewIssueslockRequestWithBody generates requests for Issueslock with any type of body
func NewIssueslockRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/lock", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForIssueRequest generates requests for ReactionslistForIssue
func NewReactionslistForIssueRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, params *ReactionslistForIssueParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForIssueRequest calls the generic ReactionscreateForIssue builder with application/json body
func NewReactionscreateForIssueRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, body ReactionscreateForIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForIssueRequestWithBody(server, owner, repo, issueNumber, "application/json", bodyReader)
}

// NewReactionscreateForIssueRequestWithBody generates requests for ReactionscreateForIssue with any type of body
func NewReactionscreateForIssueRequestWithBody(server string, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForIssueRequest generates requests for ReactionsdeleteForIssue
func NewReactionsdeleteForIssueRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistEventsForTimelineRequest generates requests for IssueslistEventsForTimeline
func NewIssueslistEventsForTimelineRequest(server string, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsForTimelineParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "issue_number", runtime.ParamLocationPath, issueNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/issues/%s/timeline", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistDeployKeysRequest generates requests for ReposlistDeployKeys
func NewReposlistDeployKeysRequest(server string, owner Owner, repo Repo, params *ReposlistDeployKeysParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateDeployKeyRequest calls the generic ReposcreateDeployKey builder with application/json body
func NewReposcreateDeployKeyRequest(server string, owner Owner, repo Repo, body ReposcreateDeployKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateDeployKeyRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateDeployKeyRequestWithBody generates requests for ReposcreateDeployKey with any type of body
func NewReposcreateDeployKeyRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/keys", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteDeployKeyRequest generates requests for ReposdeleteDeployKey
func NewReposdeleteDeployKeyRequest(server string, owner Owner, repo Repo, keyId KeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetDeployKeyRequest generates requests for ReposgetDeployKey
func NewReposgetDeployKeyRequest(server string, owner Owner, repo Repo, keyId KeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/keys/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssueslistLabelsForRepoRequest generates requests for IssueslistLabelsForRepo
func NewIssueslistLabelsForRepoRequest(server string, owner Owner, repo Repo, params *IssueslistLabelsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuescreateLabelRequest calls the generic IssuescreateLabel builder with application/json body
func NewIssuescreateLabelRequest(server string, owner Owner, repo Repo, body IssuescreateLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuescreateLabelRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewIssuescreateLabelRequestWithBody generates requests for IssuescreateLabel with any type of body
func NewIssuescreateLabelRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/labels", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesdeleteLabelRequest generates requests for IssuesdeleteLabel
func NewIssuesdeleteLabelRequest(server string, owner Owner, repo Repo, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesgetLabelRequest generates requests for IssuesgetLabel
func NewIssuesgetLabelRequest(server string, owner Owner, repo Repo, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesupdateLabelRequest calls the generic IssuesupdateLabel builder with application/json body
func NewIssuesupdateLabelRequest(server string, owner Owner, repo Repo, name string, body IssuesupdateLabelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesupdateLabelRequestWithBody(server, owner, repo, name, "application/json", bodyReader)
}

// NewIssuesupdateLabelRequestWithBody generates requests for IssuesupdateLabel with any type of body
func NewIssuesupdateLabelRequestWithBody(server string, owner Owner, repo Repo, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/labels/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistLanguagesRequest generates requests for ReposlistLanguages
func NewReposlistLanguagesRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/languages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdisableLfsForRepoRequest generates requests for ReposdisableLfsForRepo
func NewReposdisableLfsForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/lfs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposenableLfsForRepoRequest generates requests for ReposenableLfsForRepo
func NewReposenableLfsForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/lfs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLicensesgetForRepoRequest generates requests for LicensesgetForRepo
func NewLicensesgetForRepoRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/license", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposmergeUpstreamRequest calls the generic ReposmergeUpstream builder with application/json body
func NewReposmergeUpstreamRequest(server string, owner Owner, repo Repo, body ReposmergeUpstreamJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposmergeUpstreamRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposmergeUpstreamRequestWithBody generates requests for ReposmergeUpstream with any type of body
func NewReposmergeUpstreamRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/merge-upstream", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposmergeRequest calls the generic Reposmerge builder with application/json body
func NewReposmergeRequest(server string, owner Owner, repo Repo, body ReposmergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposmergeRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposmergeRequestWithBody generates requests for Reposmerge with any type of body
func NewReposmergeRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/merges", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistMilestonesRequest generates requests for IssueslistMilestones
func NewIssueslistMilestonesRequest(server string, owner Owner, repo Repo, params *IssueslistMilestonesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuescreateMilestoneRequest calls the generic IssuescreateMilestone builder with application/json body
func NewIssuescreateMilestoneRequest(server string, owner Owner, repo Repo, body IssuescreateMilestoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuescreateMilestoneRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewIssuescreateMilestoneRequestWithBody generates requests for IssuescreateMilestone with any type of body
func NewIssuescreateMilestoneRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesdeleteMilestoneRequest generates requests for IssuesdeleteMilestone
func NewIssuesdeleteMilestoneRequest(server string, owner Owner, repo Repo, milestoneNumber MilestoneNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "milestone_number", runtime.ParamLocationPath, milestoneNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesgetMilestoneRequest generates requests for IssuesgetMilestone
func NewIssuesgetMilestoneRequest(server string, owner Owner, repo Repo, milestoneNumber MilestoneNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "milestone_number", runtime.ParamLocationPath, milestoneNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIssuesupdateMilestoneRequest calls the generic IssuesupdateMilestone builder with application/json body
func NewIssuesupdateMilestoneRequest(server string, owner Owner, repo Repo, milestoneNumber MilestoneNumber, body IssuesupdateMilestoneJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIssuesupdateMilestoneRequestWithBody(server, owner, repo, milestoneNumber, "application/json", bodyReader)
}

// NewIssuesupdateMilestoneRequestWithBody generates requests for IssuesupdateMilestone with any type of body
func NewIssuesupdateMilestoneRequestWithBody(server string, owner Owner, repo Repo, milestoneNumber MilestoneNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "milestone_number", runtime.ParamLocationPath, milestoneNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistLabelsForMilestoneRequest generates requests for IssueslistLabelsForMilestone
func NewIssueslistLabelsForMilestoneRequest(server string, owner Owner, repo Repo, milestoneNumber MilestoneNumber, params *IssueslistLabelsForMilestoneParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "milestone_number", runtime.ParamLocationPath, milestoneNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/milestones/%s/labels", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistRepoNotificationsForAuthenticatedUserRequest generates requests for ActivitylistRepoNotificationsForAuthenticatedUser
func NewActivitylistRepoNotificationsForAuthenticatedUserRequest(server string, owner Owner, repo Repo, params *ActivitylistRepoNotificationsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/notifications", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.All != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "all", runtime.ParamLocationQuery, *params.All); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Participating != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "participating", runtime.ParamLocationQuery, *params.Participating); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitymarkRepoNotificationsAsReadRequest calls the generic ActivitymarkRepoNotificationsAsRead builder with application/json body
func NewActivitymarkRepoNotificationsAsReadRequest(server string, owner Owner, repo Repo, body ActivitymarkRepoNotificationsAsReadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivitymarkRepoNotificationsAsReadRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActivitymarkRepoNotificationsAsReadRequestWithBody generates requests for ActivitymarkRepoNotificationsAsRead with any type of body
func NewActivitymarkRepoNotificationsAsReadRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/notifications", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeletePagesSiteRequest generates requests for ReposdeletePagesSite
func NewReposdeletePagesSiteRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetPagesRequest generates requests for ReposgetPages
func NewReposgetPagesRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreatePagesSiteRequest calls the generic ReposcreatePagesSite builder with application/json body
func NewReposcreatePagesSiteRequest(server string, owner Owner, repo Repo, body ReposcreatePagesSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreatePagesSiteRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreatePagesSiteRequestWithBody generates requests for ReposcreatePagesSite with any type of body
func NewReposcreatePagesSiteRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposupdateInformationAboutPagesSiteRequest calls the generic ReposupdateInformationAboutPagesSite builder with application/json body
func NewReposupdateInformationAboutPagesSiteRequest(server string, owner Owner, repo Repo, body ReposupdateInformationAboutPagesSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateInformationAboutPagesSiteRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposupdateInformationAboutPagesSiteRequestWithBody generates requests for ReposupdateInformationAboutPagesSite with any type of body
func NewReposupdateInformationAboutPagesSiteRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistPagesBuildsRequest generates requests for ReposlistPagesBuilds
func NewReposlistPagesBuildsRequest(server string, owner Owner, repo Repo, params *ReposlistPagesBuildsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposrequestPagesBuildRequest generates requests for ReposrequestPagesBuild
func NewReposrequestPagesBuildRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages/builds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetLatestPagesBuildRequest generates requests for ReposgetLatestPagesBuild
func NewReposgetLatestPagesBuildRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages/builds/latest", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetPagesBuildRequest generates requests for ReposgetPagesBuild
func NewReposgetPagesBuildRequest(server string, owner Owner, repo Repo, buildId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "build_id", runtime.ParamLocationPath, buildId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages/builds/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetPagesHealthCheckRequest generates requests for ReposgetPagesHealthCheck
func NewReposgetPagesHealthCheckRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pages/health", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectslistForRepoRequest generates requests for ProjectslistForRepo
func NewProjectslistForRepoRequest(server string, owner Owner, repo Repo, params *ProjectslistForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/projects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectscreateForRepoRequest calls the generic ProjectscreateForRepo builder with application/json body
func NewProjectscreateForRepoRequest(server string, owner Owner, repo Repo, body ProjectscreateForRepoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectscreateForRepoRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewProjectscreateForRepoRequestWithBody generates requests for ProjectscreateForRepo with any type of body
func NewProjectscreateForRepoRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/projects", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistRequest generates requests for Pullslist
func NewPullslistRequest(server string, owner Owner, repo Repo, params *PullslistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Head != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "head", runtime.ParamLocationQuery, *params.Head); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Base != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "base", runtime.ParamLocationQuery, *params.Base); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullscreateRequest calls the generic Pullscreate builder with application/json body
func NewPullscreateRequest(server string, owner Owner, repo Repo, body PullscreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullscreateRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewPullscreateRequestWithBody generates requests for Pullscreate with any type of body
func NewPullscreateRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistReviewCommentsForRepoRequest generates requests for PullslistReviewCommentsForRepo
func NewPullslistReviewCommentsForRepoRequest(server string, owner Owner, repo Repo, params *PullslistReviewCommentsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsdeleteReviewCommentRequest generates requests for PullsdeleteReviewComment
func NewPullsdeleteReviewCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsgetReviewCommentRequest generates requests for PullsgetReviewComment
func NewPullsgetReviewCommentRequest(server string, owner Owner, repo Repo, commentId CommentId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsupdateReviewCommentRequest calls the generic PullsupdateReviewComment builder with application/json body
func NewPullsupdateReviewCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body PullsupdateReviewCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsupdateReviewCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewPullsupdateReviewCommentRequestWithBody generates requests for PullsupdateReviewComment with any type of body
func NewPullsupdateReviewCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForPullRequestReviewCommentRequest generates requests for ReactionslistForPullRequestReviewComment
func NewReactionslistForPullRequestReviewCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForPullRequestReviewCommentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForPullRequestReviewCommentRequest calls the generic ReactionscreateForPullRequestReviewComment builder with application/json body
func NewReactionscreateForPullRequestReviewCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForPullRequestReviewCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForPullRequestReviewCommentRequestWithBody(server, owner, repo, commentId, "application/json", bodyReader)
}

// NewReactionscreateForPullRequestReviewCommentRequestWithBody generates requests for ReactionscreateForPullRequestReviewComment with any type of body
func NewReactionscreateForPullRequestReviewCommentRequestWithBody(server string, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForPullRequestCommentRequest generates requests for ReactionsdeleteForPullRequestComment
func NewReactionsdeleteForPullRequestCommentRequest(server string, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/comments/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsgetRequest generates requests for Pullsget
func NewPullsgetRequest(server string, owner Owner, repo Repo, pullNumber PullNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsupdateRequest calls the generic Pullsupdate builder with application/json body
func NewPullsupdateRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsupdateRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullsupdateRequestWithBody generates requests for Pullsupdate with any type of body
func NewPullsupdateRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespacescreateWithPrForAuthenticatedUserRequest calls the generic CodespacescreateWithPrForAuthenticatedUser builder with application/json body
func NewCodespacescreateWithPrForAuthenticatedUserRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body CodespacescreateWithPrForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacescreateWithPrForAuthenticatedUserRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewCodespacescreateWithPrForAuthenticatedUserRequestWithBody generates requests for CodespacescreateWithPrForAuthenticatedUser with any type of body
func NewCodespacescreateWithPrForAuthenticatedUserRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/codespaces", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistReviewCommentsRequest generates requests for PullslistReviewComments
func NewPullslistReviewCommentsRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullscreateReviewCommentRequest calls the generic PullscreateReviewComment builder with application/json body
func NewPullscreateReviewCommentRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullscreateReviewCommentRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullscreateReviewCommentRequestWithBody generates requests for PullscreateReviewComment with any type of body
func NewPullscreateReviewCommentRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/comments", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullscreateReplyForReviewCommentRequest calls the generic PullscreateReplyForReviewComment builder with application/json body
func NewPullscreateReplyForReviewCommentRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, body PullscreateReplyForReviewCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullscreateReplyForReviewCommentRequestWithBody(server, owner, repo, pullNumber, commentId, "application/json", bodyReader)
}

// NewPullscreateReplyForReviewCommentRequestWithBody generates requests for PullscreateReplyForReviewComment with any type of body
func NewPullscreateReplyForReviewCommentRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "comment_id", runtime.ParamLocationPath, commentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/comments/%s/replies", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistCommitsRequest generates requests for PullslistCommits
func NewPullslistCommitsRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistCommitsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/commits", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullslistFilesRequest generates requests for PullslistFiles
func NewPullslistFilesRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/files", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullscheckIfMergedRequest generates requests for PullscheckIfMerged
func NewPullscheckIfMergedRequest(server string, owner Owner, repo Repo, pullNumber PullNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsmergeRequest calls the generic Pullsmerge builder with application/json body
func NewPullsmergeRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullsmergeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsmergeRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullsmergeRequestWithBody generates requests for Pullsmerge with any type of body
func NewPullsmergeRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/merge", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullsremoveRequestedReviewersRequest calls the generic PullsremoveRequestedReviewers builder with application/json body
func NewPullsremoveRequestedReviewersRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullsremoveRequestedReviewersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsremoveRequestedReviewersRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullsremoveRequestedReviewersRequestWithBody generates requests for PullsremoveRequestedReviewers with any type of body
func NewPullsremoveRequestedReviewersRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/requested_reviewers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistRequestedReviewersRequest generates requests for PullslistRequestedReviewers
func NewPullslistRequestedReviewersRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistRequestedReviewersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/requested_reviewers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsrequestReviewersRequest calls the generic PullsrequestReviewers builder with application/json body
func NewPullsrequestReviewersRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullsrequestReviewersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsrequestReviewersRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullsrequestReviewersRequestWithBody generates requests for PullsrequestReviewers with any type of body
func NewPullsrequestReviewersRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/requested_reviewers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistReviewsRequest generates requests for PullslistReviews
func NewPullslistReviewsRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullscreateReviewRequest calls the generic PullscreateReview builder with application/json body
func NewPullscreateReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullscreateReviewRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullscreateReviewRequestWithBody generates requests for PullscreateReview with any type of body
func NewPullscreateReviewRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullsdeletePendingReviewRequest generates requests for PullsdeletePendingReview
func NewPullsdeletePendingReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsgetReviewRequest generates requests for PullsgetReview
func NewPullsgetReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsupdateReviewRequest calls the generic PullsupdateReview builder with application/json body
func NewPullsupdateReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsupdateReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsupdateReviewRequestWithBody(server, owner, repo, pullNumber, reviewId, "application/json", bodyReader)
}

// NewPullsupdateReviewRequestWithBody generates requests for PullsupdateReview with any type of body
func NewPullsupdateReviewRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullslistCommentsForReviewRequest generates requests for PullslistCommentsForReview
func NewPullslistCommentsForReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, params *PullslistCommentsForReviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s/comments", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPullsdismissReviewRequest calls the generic PullsdismissReview builder with application/json body
func NewPullsdismissReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsdismissReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsdismissReviewRequestWithBody(server, owner, repo, pullNumber, reviewId, "application/json", bodyReader)
}

// NewPullsdismissReviewRequestWithBody generates requests for PullsdismissReview with any type of body
func NewPullsdismissReviewRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s/dismissals", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullssubmitReviewRequest calls the generic PullssubmitReview builder with application/json body
func NewPullssubmitReviewRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullssubmitReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullssubmitReviewRequestWithBody(server, owner, repo, pullNumber, reviewId, "application/json", bodyReader)
}

// NewPullssubmitReviewRequestWithBody generates requests for PullssubmitReview with any type of body
func NewPullssubmitReviewRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "review_id", runtime.ParamLocationPath, reviewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/reviews/%s/events", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPullsupdateBranchRequest calls the generic PullsupdateBranch builder with application/json body
func NewPullsupdateBranchRequest(server string, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateBranchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPullsupdateBranchRequestWithBody(server, owner, repo, pullNumber, "application/json", bodyReader)
}

// NewPullsupdateBranchRequestWithBody generates requests for PullsupdateBranch with any type of body
func NewPullsupdateBranchRequestWithBody(server string, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "pull_number", runtime.ParamLocationPath, pullNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/pulls/%s/update-branch", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetReadmeRequest generates requests for ReposgetReadme
func NewReposgetReadmeRequest(server string, owner Owner, repo Repo, params *ReposgetReadmeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/readme", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetReadmeInDirectoryRequest generates requests for ReposgetReadmeInDirectory
func NewReposgetReadmeInDirectoryRequest(server string, owner Owner, repo Repo, dir string, params *ReposgetReadmeInDirectoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "dir", runtime.ParamLocationPath, dir)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/readme/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Ref != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ref", runtime.ParamLocationQuery, *params.Ref); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistReleasesRequest generates requests for ReposlistReleases
func NewReposlistReleasesRequest(server string, owner Owner, repo Repo, params *ReposlistReleasesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateReleaseRequest calls the generic ReposcreateRelease builder with application/json body
func NewReposcreateReleaseRequest(server string, owner Owner, repo Repo, body ReposcreateReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateReleaseRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateReleaseRequestWithBody generates requests for ReposcreateRelease with any type of body
func NewReposcreateReleaseRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteReleaseAssetRequest generates requests for ReposdeleteReleaseAsset
func NewReposdeleteReleaseAssetRequest(server string, owner Owner, repo Repo, assetId AssetId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/assets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetReleaseAssetRequest generates requests for ReposgetReleaseAsset
func NewReposgetReleaseAssetRequest(server string, owner Owner, repo Repo, assetId AssetId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/assets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateReleaseAssetRequest calls the generic ReposupdateReleaseAsset builder with application/json body
func NewReposupdateReleaseAssetRequest(server string, owner Owner, repo Repo, assetId AssetId, body ReposupdateReleaseAssetJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateReleaseAssetRequestWithBody(server, owner, repo, assetId, "application/json", bodyReader)
}

// NewReposupdateReleaseAssetRequestWithBody generates requests for ReposupdateReleaseAsset with any type of body
func NewReposupdateReleaseAssetRequestWithBody(server string, owner Owner, repo Repo, assetId AssetId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "asset_id", runtime.ParamLocationPath, assetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/assets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgenerateReleaseNotesRequest calls the generic ReposgenerateReleaseNotes builder with application/json body
func NewReposgenerateReleaseNotesRequest(server string, owner Owner, repo Repo, body ReposgenerateReleaseNotesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposgenerateReleaseNotesRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposgenerateReleaseNotesRequestWithBody generates requests for ReposgenerateReleaseNotes with any type of body
func NewReposgenerateReleaseNotesRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/generate-notes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetLatestReleaseRequest generates requests for ReposgetLatestRelease
func NewReposgetLatestReleaseRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/latest", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetReleaseByTagRequest generates requests for ReposgetReleaseByTag
func NewReposgetReleaseByTagRequest(server string, owner Owner, repo Repo, tag string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tag", runtime.ParamLocationPath, tag)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/tags/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeleteReleaseRequest generates requests for ReposdeleteRelease
func NewReposdeleteReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetReleaseRequest generates requests for ReposgetRelease
func NewReposgetReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposupdateReleaseRequest calls the generic ReposupdateRelease builder with application/json body
func NewReposupdateReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId, body ReposupdateReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposupdateReleaseRequestWithBody(server, owner, repo, releaseId, "application/json", bodyReader)
}

// NewReposupdateReleaseRequestWithBody generates requests for ReposupdateRelease with any type of body
func NewReposupdateReleaseRequestWithBody(server string, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistReleaseAssetsRequest generates requests for ReposlistReleaseAssets
func NewReposlistReleaseAssetsRequest(server string, owner Owner, repo Repo, releaseId ReleaseId, params *ReposlistReleaseAssetsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s/assets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposuploadReleaseAssetRequestWithBody generates requests for ReposuploadReleaseAsset with any type of body
func NewReposuploadReleaseAssetRequestWithBody(server string, owner Owner, repo Repo, releaseId ReleaseId, params *ReposuploadReleaseAssetParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s/assets", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Label != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "label", runtime.ParamLocationQuery, *params.Label); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForReleaseRequest generates requests for ReactionslistForRelease
func NewReactionslistForReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId, params *ReactionslistForReleaseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForReleaseRequest calls the generic ReactionscreateForRelease builder with application/json body
func NewReactionscreateForReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId, body ReactionscreateForReleaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForReleaseRequestWithBody(server, owner, repo, releaseId, "application/json", bodyReader)
}

// NewReactionscreateForReleaseRequestWithBody generates requests for ReactionscreateForRelease with any type of body
func NewReactionscreateForReleaseRequestWithBody(server string, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionsdeleteForReleaseRequest generates requests for ReactionsdeleteForRelease
func NewReactionsdeleteForReleaseRequest(server string, owner Owner, repo Repo, releaseId ReleaseId, reactionId ReactionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "release_id", runtime.ParamLocationPath, releaseId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "reaction_id", runtime.ParamLocationPath, reactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/releases/%s/reactions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretScanninglistAlertsForRepoRequest generates requests for SecretScanninglistAlertsForRepo
func NewSecretScanninglistAlertsForRepoRequest(server string, owner Owner, repo Repo, params *SecretScanninglistAlertsForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/secret-scanning/alerts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SecretType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_type", runtime.ParamLocationQuery, *params.SecretType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Resolution != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution", runtime.ParamLocationQuery, *params.Resolution); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretScanninggetAlertRequest generates requests for SecretScanninggetAlert
func NewSecretScanninggetAlertRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/secret-scanning/alerts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSecretScanningupdateAlertRequest calls the generic SecretScanningupdateAlert builder with application/json body
func NewSecretScanningupdateAlertRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber, body SecretScanningupdateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSecretScanningupdateAlertRequestWithBody(server, owner, repo, alertNumber, "application/json", bodyReader)
}

// NewSecretScanningupdateAlertRequestWithBody generates requests for SecretScanningupdateAlert with any type of body
func NewSecretScanningupdateAlertRequestWithBody(server string, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/secret-scanning/alerts/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSecretScanninglistLocationsForAlertRequest generates requests for SecretScanninglistLocationsForAlert
func NewSecretScanninglistLocationsForAlertRequest(server string, owner Owner, repo Repo, alertNumber AlertNumber, params *SecretScanninglistLocationsForAlertParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "alert_number", runtime.ParamLocationPath, alertNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/secret-scanning/alerts/%s/locations", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistStargazersForRepoRequest generates requests for ActivitylistStargazersForRepo
func NewActivitylistStargazersForRepoRequest(server string, owner Owner, repo Repo, params *ActivitylistStargazersForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stargazers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCodeFrequencyStatsRequest generates requests for ReposgetCodeFrequencyStats
func NewReposgetCodeFrequencyStatsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stats/code_frequency", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetCommitActivityStatsRequest generates requests for ReposgetCommitActivityStats
func NewReposgetCommitActivityStatsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stats/commit_activity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetContributorsStatsRequest generates requests for ReposgetContributorsStats
func NewReposgetContributorsStatsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stats/contributors", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetParticipationStatsRequest generates requests for ReposgetParticipationStats
func NewReposgetParticipationStatsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stats/participation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetPunchCardStatsRequest generates requests for ReposgetPunchCardStats
func NewReposgetPunchCardStatsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/stats/punch_card", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateCommitStatusRequest calls the generic ReposcreateCommitStatus builder with application/json body
func NewReposcreateCommitStatusRequest(server string, owner Owner, repo Repo, sha string, body ReposcreateCommitStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateCommitStatusRequestWithBody(server, owner, repo, sha, "application/json", bodyReader)
}

// NewReposcreateCommitStatusRequestWithBody generates requests for ReposcreateCommitStatus with any type of body
func NewReposcreateCommitStatusRequestWithBody(server string, owner Owner, repo Repo, sha string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "sha", runtime.ParamLocationPath, sha)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/statuses/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewActivitylistWatchersForRepoRequest generates requests for ActivitylistWatchersForRepo
func NewActivitylistWatchersForRepoRequest(server string, owner Owner, repo Repo, params *ActivitylistWatchersForRepoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/subscribers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitydeleteRepoSubscriptionRequest generates requests for ActivitydeleteRepoSubscription
func NewActivitydeleteRepoSubscriptionRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitygetRepoSubscriptionRequest generates requests for ActivitygetRepoSubscription
func NewActivitygetRepoSubscriptionRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitysetRepoSubscriptionRequest calls the generic ActivitysetRepoSubscription builder with application/json body
func NewActivitysetRepoSubscriptionRequest(server string, owner Owner, repo Repo, body ActivitysetRepoSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActivitysetRepoSubscriptionRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewActivitysetRepoSubscriptionRequestWithBody generates requests for ActivitysetRepoSubscription with any type of body
func NewActivitysetRepoSubscriptionRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistTagsRequest generates requests for ReposlistTags
func NewReposlistTagsRequest(server string, owner Owner, repo Repo, params *ReposlistTagsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/tags", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistTagProtectionRequest generates requests for ReposlistTagProtection
func NewReposlistTagProtectionRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/tags/protection", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateTagProtectionRequest calls the generic ReposcreateTagProtection builder with application/json body
func NewReposcreateTagProtectionRequest(server string, owner Owner, repo Repo, body ReposcreateTagProtectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateTagProtectionRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposcreateTagProtectionRequestWithBody generates requests for ReposcreateTagProtection with any type of body
func NewReposcreateTagProtectionRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/tags/protection", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdeleteTagProtectionRequest generates requests for ReposdeleteTagProtection
func NewReposdeleteTagProtectionRequest(server string, owner Owner, repo Repo, tagProtectionId TagProtectionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "tag_protection_id", runtime.ParamLocationPath, tagProtectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/tags/protection/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdownloadTarballArchiveRequest generates requests for ReposdownloadTarballArchive
func NewReposdownloadTarballArchiveRequest(server string, owner Owner, repo Repo, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/tarball/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistTeamsRequest generates requests for ReposlistTeams
func NewReposlistTeamsRequest(server string, owner Owner, repo Repo, params *ReposlistTeamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/teams", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetAllTopicsRequest generates requests for ReposgetAllTopics
func NewReposgetAllTopicsRequest(server string, owner Owner, repo Repo, params *ReposgetAllTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/topics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposreplaceAllTopicsRequest calls the generic ReposreplaceAllTopics builder with application/json body
func NewReposreplaceAllTopicsRequest(server string, owner Owner, repo Repo, body ReposreplaceAllTopicsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposreplaceAllTopicsRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewReposreplaceAllTopicsRequestWithBody generates requests for ReposreplaceAllTopics with any type of body
func NewReposreplaceAllTopicsRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/topics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposgetClonesRequest generates requests for ReposgetClones
func NewReposgetClonesRequest(server string, owner Owner, repo Repo, params *ReposgetClonesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/traffic/clones", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Per != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per", runtime.ParamLocationQuery, *params.Per); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetTopPathsRequest generates requests for ReposgetTopPaths
func NewReposgetTopPathsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/traffic/popular/paths", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetTopReferrersRequest generates requests for ReposgetTopReferrers
func NewReposgetTopReferrersRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/traffic/popular/referrers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposgetViewsRequest generates requests for ReposgetViews
func NewReposgetViewsRequest(server string, owner Owner, repo Repo, params *ReposgetViewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/traffic/views", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Per != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per", runtime.ParamLocationQuery, *params.Per); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRepostransferRequest calls the generic Repostransfer builder with application/json body
func NewRepostransferRequest(server string, owner Owner, repo Repo, body RepostransferJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRepostransferRequestWithBody(server, owner, repo, "application/json", bodyReader)
}

// NewRepostransferRequestWithBody generates requests for Repostransfer with any type of body
func NewRepostransferRequestWithBody(server string, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/transfer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposdisableVulnerabilityAlertsRequest generates requests for ReposdisableVulnerabilityAlerts
func NewReposdisableVulnerabilityAlertsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/vulnerability-alerts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcheckVulnerabilityAlertsRequest generates requests for ReposcheckVulnerabilityAlerts
func NewReposcheckVulnerabilityAlertsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/vulnerability-alerts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposenableVulnerabilityAlertsRequest generates requests for ReposenableVulnerabilityAlerts
func NewReposenableVulnerabilityAlertsRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/vulnerability-alerts", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdownloadZipballArchiveRequest generates requests for ReposdownloadZipballArchive
func NewReposdownloadZipballArchiveRequest(server string, owner Owner, repo Repo, ref string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/zipball/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateUsingTemplateRequest calls the generic ReposcreateUsingTemplate builder with application/json body
func NewReposcreateUsingTemplateRequest(server string, templateOwner string, templateRepo string, body ReposcreateUsingTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateUsingTemplateRequestWithBody(server, templateOwner, templateRepo, "application/json", bodyReader)
}

// NewReposcreateUsingTemplateRequestWithBody generates requests for ReposcreateUsingTemplate with any type of body
func NewReposcreateUsingTemplateRequestWithBody(server string, templateOwner string, templateRepo string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "template_owner", runtime.ParamLocationPath, templateOwner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "template_repo", runtime.ParamLocationPath, templateRepo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repos/%s/%s/generate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistPublicRequest generates requests for ReposlistPublic
func NewReposlistPublicRequest(server string, params *ReposlistPublicParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionslistEnvironmentSecretsRequest generates requests for ActionslistEnvironmentSecrets
func NewActionslistEnvironmentSecretsRequest(server string, repositoryId RepositoryId, environmentName EnvironmentName, params *ActionslistEnvironmentSecretsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/environments/%s/secrets", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetEnvironmentPublicKeyRequest generates requests for ActionsgetEnvironmentPublicKey
func NewActionsgetEnvironmentPublicKeyRequest(server string, repositoryId RepositoryId, environmentName EnvironmentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/environments/%s/secrets/public-key", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsdeleteEnvironmentSecretRequest generates requests for ActionsdeleteEnvironmentSecret
func NewActionsdeleteEnvironmentSecretRequest(server string, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/environments/%s/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionsgetEnvironmentSecretRequest generates requests for ActionsgetEnvironmentSecret
func NewActionsgetEnvironmentSecretRequest(server string, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/environments/%s/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActionscreateOrUpdateEnvironmentSecretRequest calls the generic ActionscreateOrUpdateEnvironmentSecret builder with application/json body
func NewActionscreateOrUpdateEnvironmentSecretRequest(server string, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, body ActionscreateOrUpdateEnvironmentSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewActionscreateOrUpdateEnvironmentSecretRequestWithBody(server, repositoryId, environmentName, secretName, "application/json", bodyReader)
}

// NewActionscreateOrUpdateEnvironmentSecretRequestWithBody generates requests for ActionscreateOrUpdateEnvironmentSecret with any type of body
func NewActionscreateOrUpdateEnvironmentSecretRequestWithBody(server string, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "environment_name", runtime.ParamLocationPath, environmentName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/%s/environments/%s/secrets/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminlistProvisionedGroupsEnterpriseRequest generates requests for EnterpriseAdminlistProvisionedGroupsEnterprise
func NewEnterpriseAdminlistProvisionedGroupsEnterpriseRequest(server string, enterprise Enterprise, params *EnterpriseAdminlistProvisionedGroupsEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.StartIndex != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.ExcludedAttributes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedAttributes", runtime.ParamLocationQuery, *params.ExcludedAttributes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequest calls the generic EnterpriseAdminprovisionAndInviteEnterpriseGroup builder with application/json body
func NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequest(server string, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequestWithBody generates requests for EnterpriseAdminprovisionAndInviteEnterpriseGroup with any type of body
func NewEnterpriseAdminprovisionAndInviteEnterpriseGroupRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdmindeleteScimGroupFromEnterpriseRequest generates requests for EnterpriseAdmindeleteScimGroupFromEnterprise
func NewEnterpriseAdmindeleteScimGroupFromEnterpriseRequest(server string, enterprise Enterprise, scimGroupId ScimGroupId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_group_id", runtime.ParamLocationPath, scimGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetProvisioningInformationForEnterpriseGroupRequest generates requests for EnterpriseAdmingetProvisioningInformationForEnterpriseGroup
func NewEnterpriseAdmingetProvisioningInformationForEnterpriseGroupRequest(server string, enterprise Enterprise, scimGroupId ScimGroupId, params *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_group_id", runtime.ParamLocationPath, scimGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.ExcludedAttributes != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedAttributes", runtime.ParamLocationQuery, *params.ExcludedAttributes); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequest calls the generic EnterpriseAdminupdateAttributeForEnterpriseGroup builder with application/json body
func NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequest(server string, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminupdateAttributeForEnterpriseGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequestWithBody(server, enterprise, scimGroupId, "application/json", bodyReader)
}

// NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequestWithBody generates requests for EnterpriseAdminupdateAttributeForEnterpriseGroup with any type of body
func NewEnterpriseAdminupdateAttributeForEnterpriseGroupRequestWithBody(server string, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_group_id", runtime.ParamLocationPath, scimGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequest calls the generic EnterpriseAdminsetInformationForProvisionedEnterpriseGroup builder with application/json body
func NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequest(server string, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminsetInformationForProvisionedEnterpriseGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequestWithBody(server, enterprise, scimGroupId, "application/json", bodyReader)
}

// NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequestWithBody generates requests for EnterpriseAdminsetInformationForProvisionedEnterpriseGroup with any type of body
func NewEnterpriseAdminsetInformationForProvisionedEnterpriseGroupRequestWithBody(server string, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_group_id", runtime.ParamLocationPath, scimGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminlistProvisionedIdentitiesEnterpriseRequest generates requests for EnterpriseAdminlistProvisionedIdentitiesEnterprise
func NewEnterpriseAdminlistProvisionedIdentitiesEnterpriseRequest(server string, enterprise Enterprise, params *EnterpriseAdminlistProvisionedIdentitiesEnterpriseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.StartIndex != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequest calls the generic EnterpriseAdminprovisionAndInviteEnterpriseUser builder with application/json body
func NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequest(server string, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequestWithBody(server, enterprise, "application/json", bodyReader)
}

// NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequestWithBody generates requests for EnterpriseAdminprovisionAndInviteEnterpriseUser with any type of body
func NewEnterpriseAdminprovisionAndInviteEnterpriseUserRequestWithBody(server string, enterprise Enterprise, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdmindeleteUserFromEnterpriseRequest generates requests for EnterpriseAdmindeleteUserFromEnterprise
func NewEnterpriseAdmindeleteUserFromEnterpriseRequest(server string, enterprise Enterprise, scimUserId ScimUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdmingetProvisioningInformationForEnterpriseUserRequest generates requests for EnterpriseAdmingetProvisioningInformationForEnterpriseUser
func NewEnterpriseAdmingetProvisioningInformationForEnterpriseUserRequest(server string, enterprise Enterprise, scimUserId ScimUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEnterpriseAdminupdateAttributeForEnterpriseUserRequest calls the generic EnterpriseAdminupdateAttributeForEnterpriseUser builder with application/json body
func NewEnterpriseAdminupdateAttributeForEnterpriseUserRequest(server string, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminupdateAttributeForEnterpriseUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminupdateAttributeForEnterpriseUserRequestWithBody(server, enterprise, scimUserId, "application/json", bodyReader)
}

// NewEnterpriseAdminupdateAttributeForEnterpriseUserRequestWithBody generates requests for EnterpriseAdminupdateAttributeForEnterpriseUser with any type of body
func NewEnterpriseAdminupdateAttributeForEnterpriseUserRequestWithBody(server string, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequest calls the generic EnterpriseAdminsetInformationForProvisionedEnterpriseUser builder with application/json body
func NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequest(server string, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminsetInformationForProvisionedEnterpriseUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequestWithBody(server, enterprise, scimUserId, "application/json", bodyReader)
}

// NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequestWithBody generates requests for EnterpriseAdminsetInformationForProvisionedEnterpriseUser with any type of body
func NewEnterpriseAdminsetInformationForProvisionedEnterpriseUserRequestWithBody(server string, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "enterprise", runtime.ParamLocationPath, enterprise)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/enterprises/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScimlistProvisionedIdentitiesRequest generates requests for ScimlistProvisionedIdentities
func NewScimlistProvisionedIdentitiesRequest(server string, org Org, params *ScimlistProvisionedIdentitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.StartIndex != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startIndex", runtime.ParamLocationQuery, *params.StartIndex); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Count != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimprovisionAndInviteUserRequest calls the generic ScimprovisionAndInviteUser builder with application/json body
func NewScimprovisionAndInviteUserRequest(server string, org Org, body ScimprovisionAndInviteUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScimprovisionAndInviteUserRequestWithBody(server, org, "application/json", bodyReader)
}

// NewScimprovisionAndInviteUserRequestWithBody generates requests for ScimprovisionAndInviteUser with any type of body
func NewScimprovisionAndInviteUserRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScimdeleteUserFromOrgRequest generates requests for ScimdeleteUserFromOrg
func NewScimdeleteUserFromOrgRequest(server string, org Org, scimUserId ScimUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimgetProvisioningInformationForUserRequest generates requests for ScimgetProvisioningInformationForUser
func NewScimgetProvisioningInformationForUserRequest(server string, org Org, scimUserId ScimUserId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScimupdateAttributeForUserRequest calls the generic ScimupdateAttributeForUser builder with application/json body
func NewScimupdateAttributeForUserRequest(server string, org Org, scimUserId ScimUserId, body ScimupdateAttributeForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScimupdateAttributeForUserRequestWithBody(server, org, scimUserId, "application/json", bodyReader)
}

// NewScimupdateAttributeForUserRequestWithBody generates requests for ScimupdateAttributeForUser with any type of body
func NewScimupdateAttributeForUserRequestWithBody(server string, org Org, scimUserId ScimUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScimsetInformationForProvisionedUserRequest calls the generic ScimsetInformationForProvisionedUser builder with application/json body
func NewScimsetInformationForProvisionedUserRequest(server string, org Org, scimUserId ScimUserId, body ScimsetInformationForProvisionedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScimsetInformationForProvisionedUserRequestWithBody(server, org, scimUserId, "application/json", bodyReader)
}

// NewScimsetInformationForProvisionedUserRequestWithBody generates requests for ScimsetInformationForProvisionedUser with any type of body
func NewScimsetInformationForProvisionedUserRequestWithBody(server string, org Org, scimUserId ScimUserId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scim_user_id", runtime.ParamLocationPath, scimUserId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/scim/v2/organizations/%s/Users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchcodeRequest generates requests for Searchcode
func NewSearchcodeRequest(server string, params *SearchcodeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchcommitsRequest generates requests for Searchcommits
func NewSearchcommitsRequest(server string, params *SearchcommitsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/commits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchissuesAndPullRequestsRequest generates requests for SearchissuesAndPullRequests
func NewSearchissuesAndPullRequestsRequest(server string, params *SearchissuesAndPullRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchlabelsRequest generates requests for Searchlabels
func NewSearchlabelsRequest(server string, params *SearchlabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository_id", runtime.ParamLocationQuery, params.RepositoryId); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchreposRequest generates requests for Searchrepos
func NewSearchreposRequest(server string, params *SearchreposParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/repositories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchtopicsRequest generates requests for Searchtopics
func NewSearchtopicsRequest(server string, params *SearchtopicsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/topics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchusersRequest generates requests for Searchusers
func NewSearchusersRequest(server string, params *SearchusersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Order != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsdeleteLegacyRequest generates requests for TeamsdeleteLegacy
func NewTeamsdeleteLegacyRequest(server string, teamId TeamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetLegacyRequest generates requests for TeamsgetLegacy
func NewTeamsgetLegacyRequest(server string, teamId TeamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateLegacyRequest calls the generic TeamsupdateLegacy builder with application/json body
func NewTeamsupdateLegacyRequest(server string, teamId TeamId, body TeamsupdateLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateLegacyRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewTeamsupdateLegacyRequestWithBody generates requests for TeamsupdateLegacy with any type of body
func NewTeamsupdateLegacyRequestWithBody(server string, teamId TeamId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistDiscussionsLegacyRequest generates requests for TeamslistDiscussionsLegacy
func NewTeamslistDiscussionsLegacyRequest(server string, teamId TeamId, params *TeamslistDiscussionsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateDiscussionLegacyRequest calls the generic TeamscreateDiscussionLegacy builder with application/json body
func NewTeamscreateDiscussionLegacyRequest(server string, teamId TeamId, body TeamscreateDiscussionLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateDiscussionLegacyRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewTeamscreateDiscussionLegacyRequestWithBody generates requests for TeamscreateDiscussionLegacy with any type of body
func NewTeamscreateDiscussionLegacyRequestWithBody(server string, teamId TeamId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamsdeleteDiscussionLegacyRequest generates requests for TeamsdeleteDiscussionLegacy
func NewTeamsdeleteDiscussionLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetDiscussionLegacyRequest generates requests for TeamsgetDiscussionLegacy
func NewTeamsgetDiscussionLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateDiscussionLegacyRequest calls the generic TeamsupdateDiscussionLegacy builder with application/json body
func NewTeamsupdateDiscussionLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, body TeamsupdateDiscussionLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateDiscussionLegacyRequestWithBody(server, teamId, discussionNumber, "application/json", bodyReader)
}

// NewTeamsupdateDiscussionLegacyRequestWithBody generates requests for TeamsupdateDiscussionLegacy with any type of body
func NewTeamsupdateDiscussionLegacyRequestWithBody(server string, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistDiscussionCommentsLegacyRequest generates requests for TeamslistDiscussionCommentsLegacy
func NewTeamslistDiscussionCommentsLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateDiscussionCommentLegacyRequest calls the generic TeamscreateDiscussionCommentLegacy builder with application/json body
func NewTeamscreateDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateDiscussionCommentLegacyRequestWithBody(server, teamId, discussionNumber, "application/json", bodyReader)
}

// NewTeamscreateDiscussionCommentLegacyRequestWithBody generates requests for TeamscreateDiscussionCommentLegacy with any type of body
func NewTeamscreateDiscussionCommentLegacyRequestWithBody(server string, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamsdeleteDiscussionCommentLegacyRequest generates requests for TeamsdeleteDiscussionCommentLegacy
func NewTeamsdeleteDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetDiscussionCommentLegacyRequest generates requests for TeamsgetDiscussionCommentLegacy
func NewTeamsgetDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsupdateDiscussionCommentLegacyRequest calls the generic TeamsupdateDiscussionCommentLegacy builder with application/json body
func NewTeamsupdateDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsupdateDiscussionCommentLegacyRequestWithBody(server, teamId, discussionNumber, commentNumber, "application/json", bodyReader)
}

// NewTeamsupdateDiscussionCommentLegacyRequestWithBody generates requests for TeamsupdateDiscussionCommentLegacy with any type of body
func NewTeamsupdateDiscussionCommentLegacyRequestWithBody(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForTeamDiscussionCommentLegacyRequest generates requests for ReactionslistForTeamDiscussionCommentLegacy
func NewReactionslistForTeamDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForTeamDiscussionCommentLegacyRequest calls the generic ReactionscreateForTeamDiscussionCommentLegacy builder with application/json body
func NewReactionscreateForTeamDiscussionCommentLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForTeamDiscussionCommentLegacyRequestWithBody(server, teamId, discussionNumber, commentNumber, "application/json", bodyReader)
}

// NewReactionscreateForTeamDiscussionCommentLegacyRequestWithBody generates requests for ReactionscreateForTeamDiscussionCommentLegacy with any type of body
func NewReactionscreateForTeamDiscussionCommentLegacyRequestWithBody(server string, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "comment_number", runtime.ParamLocationPath, commentNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/comments/%s/reactions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReactionslistForTeamDiscussionLegacyRequest generates requests for ReactionslistForTeamDiscussionLegacy
func NewReactionslistForTeamDiscussionLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/reactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Content != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "content", runtime.ParamLocationQuery, *params.Content); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReactionscreateForTeamDiscussionLegacyRequest calls the generic ReactionscreateForTeamDiscussionLegacy builder with application/json body
func NewReactionscreateForTeamDiscussionLegacyRequest(server string, teamId TeamId, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReactionscreateForTeamDiscussionLegacyRequestWithBody(server, teamId, discussionNumber, "application/json", bodyReader)
}

// NewReactionscreateForTeamDiscussionLegacyRequestWithBody generates requests for ReactionscreateForTeamDiscussionLegacy with any type of body
func NewReactionscreateForTeamDiscussionLegacyRequestWithBody(server string, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "discussion_number", runtime.ParamLocationPath, discussionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/discussions/%s/reactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistPendingInvitationsLegacyRequest generates requests for TeamslistPendingInvitationsLegacy
func NewTeamslistPendingInvitationsLegacyRequest(server string, teamId TeamId, params *TeamslistPendingInvitationsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/invitations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistMembersLegacyRequest generates requests for TeamslistMembersLegacy
func NewTeamslistMembersLegacyRequest(server string, teamId TeamId, params *TeamslistMembersLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Role != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveMemberLegacyRequest generates requests for TeamsremoveMemberLegacy
func NewTeamsremoveMemberLegacyRequest(server string, teamId TeamId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetMemberLegacyRequest generates requests for TeamsgetMemberLegacy
func NewTeamsgetMemberLegacyRequest(server string, teamId TeamId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddMemberLegacyRequest generates requests for TeamsaddMemberLegacy
func NewTeamsaddMemberLegacyRequest(server string, teamId TeamId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/members/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveMembershipForUserLegacyRequest generates requests for TeamsremoveMembershipForUserLegacy
func NewTeamsremoveMembershipForUserLegacyRequest(server string, teamId TeamId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsgetMembershipForUserLegacyRequest generates requests for TeamsgetMembershipForUserLegacy
func NewTeamsgetMembershipForUserLegacyRequest(server string, teamId TeamId, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateMembershipForUserLegacyRequest calls the generic TeamsaddOrUpdateMembershipForUserLegacy builder with application/json body
func NewTeamsaddOrUpdateMembershipForUserLegacyRequest(server string, teamId TeamId, username Username, body TeamsaddOrUpdateMembershipForUserLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateMembershipForUserLegacyRequestWithBody(server, teamId, username, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateMembershipForUserLegacyRequestWithBody generates requests for TeamsaddOrUpdateMembershipForUserLegacy with any type of body
func NewTeamsaddOrUpdateMembershipForUserLegacyRequestWithBody(server string, teamId TeamId, username Username, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/memberships/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistProjectsLegacyRequest generates requests for TeamslistProjectsLegacy
func NewTeamslistProjectsLegacyRequest(server string, teamId TeamId, params *TeamslistProjectsLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveProjectLegacyRequest generates requests for TeamsremoveProjectLegacy
func NewTeamsremoveProjectLegacyRequest(server string, teamId TeamId, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscheckPermissionsForProjectLegacyRequest generates requests for TeamscheckPermissionsForProjectLegacy
func NewTeamscheckPermissionsForProjectLegacyRequest(server string, teamId TeamId, projectId ProjectId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateProjectPermissionsLegacyRequest calls the generic TeamsaddOrUpdateProjectPermissionsLegacy builder with application/json body
func NewTeamsaddOrUpdateProjectPermissionsLegacyRequest(server string, teamId TeamId, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateProjectPermissionsLegacyRequestWithBody(server, teamId, projectId, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateProjectPermissionsLegacyRequestWithBody generates requests for TeamsaddOrUpdateProjectPermissionsLegacy with any type of body
func NewTeamsaddOrUpdateProjectPermissionsLegacyRequestWithBody(server string, teamId TeamId, projectId ProjectId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/projects/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistReposLegacyRequest generates requests for TeamslistReposLegacy
func NewTeamslistReposLegacyRequest(server string, teamId TeamId, params *TeamslistReposLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsremoveRepoLegacyRequest generates requests for TeamsremoveRepoLegacy
func NewTeamsremoveRepoLegacyRequest(server string, teamId TeamId, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscheckPermissionsForRepoLegacyRequest generates requests for TeamscheckPermissionsForRepoLegacy
func NewTeamscheckPermissionsForRepoLegacyRequest(server string, teamId TeamId, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamsaddOrUpdateRepoPermissionsLegacyRequest calls the generic TeamsaddOrUpdateRepoPermissionsLegacy builder with application/json body
func NewTeamsaddOrUpdateRepoPermissionsLegacyRequest(server string, teamId TeamId, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamsaddOrUpdateRepoPermissionsLegacyRequestWithBody(server, teamId, owner, repo, "application/json", bodyReader)
}

// NewTeamsaddOrUpdateRepoPermissionsLegacyRequestWithBody generates requests for TeamsaddOrUpdateRepoPermissionsLegacy with any type of body
func NewTeamsaddOrUpdateRepoPermissionsLegacyRequestWithBody(server string, teamId TeamId, owner Owner, repo Repo, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/repos/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistIdpGroupsForLegacyRequest generates requests for TeamslistIdpGroupsForLegacy
func NewTeamslistIdpGroupsForLegacyRequest(server string, teamId TeamId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/team-sync/group-mappings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequest calls the generic TeamscreateOrUpdateIdpGroupConnectionsLegacy builder with application/json body
func NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequest(server string, teamId TeamId, body TeamscreateOrUpdateIdpGroupConnectionsLegacyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequestWithBody generates requests for TeamscreateOrUpdateIdpGroupConnectionsLegacy with any type of body
func NewTeamscreateOrUpdateIdpGroupConnectionsLegacyRequestWithBody(server string, teamId TeamId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/team-sync/group-mappings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTeamslistChildLegacyRequest generates requests for TeamslistChildLegacy
func NewTeamslistChildLegacyRequest(server string, teamId TeamId, params *TeamslistChildLegacyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s/teams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersgetAuthenticatedRequest generates requests for UsersgetAuthenticated
func NewUsersgetAuthenticatedRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersupdateAuthenticatedRequest calls the generic UsersupdateAuthenticated builder with application/json body
func NewUsersupdateAuthenticatedRequest(server string, body UsersupdateAuthenticatedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersupdateAuthenticatedRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersupdateAuthenticatedRequestWithBody generates requests for UsersupdateAuthenticated with any type of body
func NewUsersupdateAuthenticatedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserslistBlockedByAuthenticatedUserRequest generates requests for UserslistBlockedByAuthenticatedUser
func NewUserslistBlockedByAuthenticatedUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersunblockRequest generates requests for Usersunblock
func NewUsersunblockRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/blocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserscheckBlockedRequest generates requests for UserscheckBlocked
func NewUserscheckBlockedRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/blocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersblockRequest generates requests for Usersblock
func NewUsersblockRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/blocks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespaceslistForAuthenticatedUserRequest generates requests for CodespaceslistForAuthenticatedUser
func NewCodespaceslistForAuthenticatedUserRequest(server string, params *CodespaceslistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.RepositoryId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository_id", runtime.ParamLocationQuery, *params.RepositoryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacescreateForAuthenticatedUserRequest calls the generic CodespacescreateForAuthenticatedUser builder with application/json body
func NewCodespacescreateForAuthenticatedUserRequest(server string, body CodespacescreateForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacescreateForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCodespacescreateForAuthenticatedUserRequestWithBody generates requests for CodespacescreateForAuthenticatedUser with any type of body
func NewCodespacescreateForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespaceslistSecretsForAuthenticatedUserRequest generates requests for CodespaceslistSecretsForAuthenticatedUser
func NewCodespaceslistSecretsForAuthenticatedUserRequest(server string, params *CodespaceslistSecretsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetPublicKeyForAuthenticatedUserRequest generates requests for CodespacesgetPublicKeyForAuthenticatedUser
func NewCodespacesgetPublicKeyForAuthenticatedUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/public-key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesdeleteSecretForAuthenticatedUserRequest generates requests for CodespacesdeleteSecretForAuthenticatedUser
func NewCodespacesdeleteSecretForAuthenticatedUserRequest(server string, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetSecretForAuthenticatedUserRequest generates requests for CodespacesgetSecretForAuthenticatedUser
func NewCodespacesgetSecretForAuthenticatedUserRequest(server string, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequest calls the generic CodespacescreateOrUpdateSecretForAuthenticatedUser builder with application/json body
func NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequest(server string, secretName SecretName, body CodespacescreateOrUpdateSecretForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequestWithBody(server, secretName, "application/json", bodyReader)
}

// NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequestWithBody generates requests for CodespacescreateOrUpdateSecretForAuthenticatedUser with any type of body
func NewCodespacescreateOrUpdateSecretForAuthenticatedUserRequestWithBody(server string, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespaceslistRepositoriesForSecretForAuthenticatedUserRequest generates requests for CodespaceslistRepositoriesForSecretForAuthenticatedUser
func NewCodespaceslistRepositoriesForSecretForAuthenticatedUserRequest(server string, secretName SecretName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequest calls the generic CodespacessetRepositoriesForSecretForAuthenticatedUser builder with application/json body
func NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequest(server string, secretName SecretName, body CodespacessetRepositoriesForSecretForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequestWithBody(server, secretName, "application/json", bodyReader)
}

// NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequestWithBody generates requests for CodespacessetRepositoriesForSecretForAuthenticatedUser with any type of body
func NewCodespacessetRepositoriesForSecretForAuthenticatedUserRequestWithBody(server string, secretName SecretName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespacesremoveRepositoryForSecretForAuthenticatedUserRequest generates requests for CodespacesremoveRepositoryForSecretForAuthenticatedUser
func NewCodespacesremoveRepositoryForSecretForAuthenticatedUserRequest(server string, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesaddRepositoryForSecretForAuthenticatedUserRequest generates requests for CodespacesaddRepositoryForSecretForAuthenticatedUser
func NewCodespacesaddRepositoryForSecretForAuthenticatedUserRequest(server string, secretName SecretName, repositoryId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "secret_name", runtime.ParamLocationPath, secretName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/secrets/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesdeleteForAuthenticatedUserRequest generates requests for CodespacesdeleteForAuthenticatedUser
func NewCodespacesdeleteForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetForAuthenticatedUserRequest generates requests for CodespacesgetForAuthenticatedUser
func NewCodespacesgetForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesupdateForAuthenticatedUserRequest calls the generic CodespacesupdateForAuthenticatedUser builder with application/json body
func NewCodespacesupdateForAuthenticatedUserRequest(server string, codespaceName CodespaceName, body CodespacesupdateForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCodespacesupdateForAuthenticatedUserRequestWithBody(server, codespaceName, "application/json", bodyReader)
}

// NewCodespacesupdateForAuthenticatedUserRequestWithBody generates requests for CodespacesupdateForAuthenticatedUser with any type of body
func NewCodespacesupdateForAuthenticatedUserRequestWithBody(server string, codespaceName CodespaceName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCodespacesexportForAuthenticatedUserRequest generates requests for CodespacesexportForAuthenticatedUser
func NewCodespacesexportForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s/exports", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesgetExportDetailsForAuthenticatedUserRequest generates requests for CodespacesgetExportDetailsForAuthenticatedUser
func NewCodespacesgetExportDetailsForAuthenticatedUserRequest(server string, codespaceName CodespaceName, exportId ExportId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "export_id", runtime.ParamLocationPath, exportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s/exports/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacescodespaceMachinesForAuthenticatedUserRequest generates requests for CodespacescodespaceMachinesForAuthenticatedUser
func NewCodespacescodespaceMachinesForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s/machines", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesstartForAuthenticatedUserRequest generates requests for CodespacesstartForAuthenticatedUser
func NewCodespacesstartForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s/start", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCodespacesstopForAuthenticatedUserRequest generates requests for CodespacesstopForAuthenticatedUser
func NewCodespacesstopForAuthenticatedUserRequest(server string, codespaceName CodespaceName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "codespace_name", runtime.ParamLocationPath, codespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/codespaces/%s/stop", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequest calls the generic UserssetPrimaryEmailVisibilityForAuthenticatedUser builder with application/json body
func NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequest(server string, body UserssetPrimaryEmailVisibilityForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequestWithBody generates requests for UserssetPrimaryEmailVisibilityForAuthenticatedUser with any type of body
func NewUserssetPrimaryEmailVisibilityForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/email/visibility")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersdeleteEmailForAuthenticatedUserRequest calls the generic UsersdeleteEmailForAuthenticatedUser builder with application/json body
func NewUsersdeleteEmailForAuthenticatedUserRequest(server string, body UsersdeleteEmailForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersdeleteEmailForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersdeleteEmailForAuthenticatedUserRequestWithBody generates requests for UsersdeleteEmailForAuthenticatedUser with any type of body
func NewUsersdeleteEmailForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserslistEmailsForAuthenticatedUserRequest generates requests for UserslistEmailsForAuthenticatedUser
func NewUserslistEmailsForAuthenticatedUserRequest(server string, params *UserslistEmailsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersaddEmailForAuthenticatedUserRequest calls the generic UsersaddEmailForAuthenticatedUser builder with application/json body
func NewUsersaddEmailForAuthenticatedUserRequest(server string, body UsersaddEmailForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUsersaddEmailForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUsersaddEmailForAuthenticatedUserRequestWithBody generates requests for UsersaddEmailForAuthenticatedUser with any type of body
func NewUsersaddEmailForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserslistFollowersForAuthenticatedUserRequest generates requests for UserslistFollowersForAuthenticatedUser
func NewUserslistFollowersForAuthenticatedUserRequest(server string, params *UserslistFollowersForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/followers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistFollowedByAuthenticatedUserRequest generates requests for UserslistFollowedByAuthenticatedUser
func NewUserslistFollowedByAuthenticatedUserRequest(server string, params *UserslistFollowedByAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/following")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersunfollowRequest generates requests for Usersunfollow
func NewUsersunfollowRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/following/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserscheckPersonIsFollowedByAuthenticatedRequest generates requests for UserscheckPersonIsFollowedByAuthenticated
func NewUserscheckPersonIsFollowedByAuthenticatedRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/following/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersfollowRequest generates requests for Usersfollow
func NewUsersfollowRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/following/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistGpgKeysForAuthenticatedUserRequest generates requests for UserslistGpgKeysForAuthenticatedUser
func NewUserslistGpgKeysForAuthenticatedUserRequest(server string, params *UserslistGpgKeysForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/gpg_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserscreateGpgKeyForAuthenticatedUserRequest calls the generic UserscreateGpgKeyForAuthenticatedUser builder with application/json body
func NewUserscreateGpgKeyForAuthenticatedUserRequest(server string, body UserscreateGpgKeyForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserscreateGpgKeyForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUserscreateGpgKeyForAuthenticatedUserRequestWithBody generates requests for UserscreateGpgKeyForAuthenticatedUser with any type of body
func NewUserscreateGpgKeyForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/gpg_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersdeleteGpgKeyForAuthenticatedUserRequest generates requests for UsersdeleteGpgKeyForAuthenticatedUser
func NewUsersdeleteGpgKeyForAuthenticatedUserRequest(server string, gpgKeyId GpgKeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gpg_key_id", runtime.ParamLocationPath, gpgKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/gpg_keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersgetGpgKeyForAuthenticatedUserRequest generates requests for UsersgetGpgKeyForAuthenticatedUser
func NewUsersgetGpgKeyForAuthenticatedUserRequest(server string, gpgKeyId GpgKeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gpg_key_id", runtime.ParamLocationPath, gpgKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/gpg_keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistInstallationsForAuthenticatedUserRequest generates requests for AppslistInstallationsForAuthenticatedUser
func NewAppslistInstallationsForAuthenticatedUserRequest(server string, params *AppslistInstallationsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/installations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistInstallationReposForAuthenticatedUserRequest generates requests for AppslistInstallationReposForAuthenticatedUser
func NewAppslistInstallationReposForAuthenticatedUserRequest(server string, installationId InstallationId, params *AppslistInstallationReposForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/installations/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsremoveRepoFromInstallationForAuthenticatedUserRequest generates requests for AppsremoveRepoFromInstallationForAuthenticatedUser
func NewAppsremoveRepoFromInstallationForAuthenticatedUserRequest(server string, installationId InstallationId, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/installations/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsaddRepoToInstallationForAuthenticatedUserRequest generates requests for AppsaddRepoToInstallationForAuthenticatedUser
func NewAppsaddRepoToInstallationForAuthenticatedUserRequest(server string, installationId InstallationId, repositoryId RepositoryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "installation_id", runtime.ParamLocationPath, installationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repository_id", runtime.ParamLocationPath, repositoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/installations/%s/repositories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsremoveRestrictionsForAuthenticatedUserRequest generates requests for InteractionsremoveRestrictionsForAuthenticatedUser
func NewInteractionsremoveRestrictionsForAuthenticatedUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/interaction-limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionsgetRestrictionsForAuthenticatedUserRequest generates requests for InteractionsgetRestrictionsForAuthenticatedUser
func NewInteractionsgetRestrictionsForAuthenticatedUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/interaction-limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInteractionssetRestrictionsForAuthenticatedUserRequest calls the generic InteractionssetRestrictionsForAuthenticatedUser builder with application/json body
func NewInteractionssetRestrictionsForAuthenticatedUserRequest(server string, body InteractionssetRestrictionsForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInteractionssetRestrictionsForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewInteractionssetRestrictionsForAuthenticatedUserRequestWithBody generates requests for InteractionssetRestrictionsForAuthenticatedUser with any type of body
func NewInteractionssetRestrictionsForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/interaction-limits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssueslistForAuthenticatedUserRequest generates requests for IssueslistForAuthenticatedUser
func NewIssueslistForAuthenticatedUserRequest(server string, params *IssueslistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Filter != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Labels != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "labels", runtime.ParamLocationQuery, *params.Labels); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistPublicSshKeysForAuthenticatedUserRequest generates requests for UserslistPublicSshKeysForAuthenticatedUser
func NewUserslistPublicSshKeysForAuthenticatedUserRequest(server string, params *UserslistPublicSshKeysForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserscreatePublicSshKeyForAuthenticatedUserRequest calls the generic UserscreatePublicSshKeyForAuthenticatedUser builder with application/json body
func NewUserscreatePublicSshKeyForAuthenticatedUserRequest(server string, body UserscreatePublicSshKeyForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserscreatePublicSshKeyForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewUserscreatePublicSshKeyForAuthenticatedUserRequestWithBody generates requests for UserscreatePublicSshKeyForAuthenticatedUser with any type of body
func NewUserscreatePublicSshKeyForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUsersdeletePublicSshKeyForAuthenticatedUserRequest generates requests for UsersdeletePublicSshKeyForAuthenticatedUser
func NewUsersdeletePublicSshKeyForAuthenticatedUserRequest(server string, keyId KeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersgetPublicSshKeyForAuthenticatedUserRequest generates requests for UsersgetPublicSshKeyForAuthenticatedUser
func NewUsersgetPublicSshKeyForAuthenticatedUserRequest(server string, keyId KeyId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "key_id", runtime.ParamLocationPath, keyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistSubscriptionsForAuthenticatedUserRequest generates requests for AppslistSubscriptionsForAuthenticatedUser
func NewAppslistSubscriptionsForAuthenticatedUserRequest(server string, params *AppslistSubscriptionsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/marketplace_purchases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppslistSubscriptionsForAuthenticatedUserStubbedRequest generates requests for AppslistSubscriptionsForAuthenticatedUserStubbed
func NewAppslistSubscriptionsForAuthenticatedUserStubbedRequest(server string, params *AppslistSubscriptionsForAuthenticatedUserStubbedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/marketplace_purchases/stubbed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistMembershipsForAuthenticatedUserRequest generates requests for OrgslistMembershipsForAuthenticatedUser
func NewOrgslistMembershipsForAuthenticatedUserRequest(server string, params *OrgslistMembershipsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/memberships/orgs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsgetMembershipForAuthenticatedUserRequest generates requests for OrgsgetMembershipForAuthenticatedUser
func NewOrgsgetMembershipForAuthenticatedUserRequest(server string, org Org) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/memberships/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgsupdateMembershipForAuthenticatedUserRequest calls the generic OrgsupdateMembershipForAuthenticatedUser builder with application/json body
func NewOrgsupdateMembershipForAuthenticatedUserRequest(server string, org Org, body OrgsupdateMembershipForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewOrgsupdateMembershipForAuthenticatedUserRequestWithBody(server, org, "application/json", bodyReader)
}

// NewOrgsupdateMembershipForAuthenticatedUserRequestWithBody generates requests for OrgsupdateMembershipForAuthenticatedUser with any type of body
func NewOrgsupdateMembershipForAuthenticatedUserRequestWithBody(server string, org Org, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/memberships/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationslistForAuthenticatedUserRequest generates requests for MigrationslistForAuthenticatedUser
func NewMigrationslistForAuthenticatedUserRequest(server string, params *MigrationslistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsstartForAuthenticatedUserRequest calls the generic MigrationsstartForAuthenticatedUser builder with application/json body
func NewMigrationsstartForAuthenticatedUserRequest(server string, body MigrationsstartForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMigrationsstartForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewMigrationsstartForAuthenticatedUserRequestWithBody generates requests for MigrationsstartForAuthenticatedUser with any type of body
func NewMigrationsstartForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMigrationsgetStatusForAuthenticatedUserRequest generates requests for MigrationsgetStatusForAuthenticatedUser
func NewMigrationsgetStatusForAuthenticatedUserRequest(server string, migrationId MigrationId, params *MigrationsgetStatusForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Exclude != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exclude", runtime.ParamLocationQuery, *params.Exclude); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsdeleteArchiveForAuthenticatedUserRequest generates requests for MigrationsdeleteArchiveForAuthenticatedUser
func NewMigrationsdeleteArchiveForAuthenticatedUserRequest(server string, migrationId MigrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsgetArchiveForAuthenticatedUserRequest generates requests for MigrationsgetArchiveForAuthenticatedUser
func NewMigrationsgetArchiveForAuthenticatedUserRequest(server string, migrationId MigrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations/%s/archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationsunlockRepoForAuthenticatedUserRequest generates requests for MigrationsunlockRepoForAuthenticatedUser
func NewMigrationsunlockRepoForAuthenticatedUserRequest(server string, migrationId MigrationId, repoName RepoName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo_name", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations/%s/repos/%s/lock", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMigrationslistReposForAuthenticatedUserRequest generates requests for MigrationslistReposForAuthenticatedUser
func NewMigrationslistReposForAuthenticatedUserRequest(server string, migrationId MigrationId, params *MigrationslistReposForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "migration_id", runtime.ParamLocationPath, migrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/migrations/%s/repositories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistForAuthenticatedUserRequest generates requests for OrgslistForAuthenticatedUser
func NewOrgslistForAuthenticatedUserRequest(server string, params *OrgslistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/orgs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackageslistPackagesForAuthenticatedUserRequest generates requests for PackageslistPackagesForAuthenticatedUser
func NewPackageslistPackagesForAuthenticatedUserRequest(server string, params *PackageslistPackagesForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package_type", runtime.ParamLocationQuery, params.PackageType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Visibility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageForAuthenticatedUserRequest generates requests for PackagesdeletePackageForAuthenticatedUser
func NewPackagesdeletePackageForAuthenticatedUserRequest(server string, packageType PackagesdeletePackageForAuthenticatedUserParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageForAuthenticatedUserRequest generates requests for PackagesgetPackageForAuthenticatedUser
func NewPackagesgetPackageForAuthenticatedUserRequest(server string, packageType PackagesgetPackageForAuthenticatedUserParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageForAuthenticatedUserRequest generates requests for PackagesrestorePackageForAuthenticatedUser
func NewPackagesrestorePackageForAuthenticatedUserRequest(server string, packageType PackagesrestorePackageForAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s/restore", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Token != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest generates requests for PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser
func NewPackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest(server string, packageType PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageVersionForAuthenticatedUserRequest generates requests for PackagesdeletePackageVersionForAuthenticatedUser
func NewPackagesdeletePackageVersionForAuthenticatedUserRequest(server string, packageType PackagesdeletePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageVersionForAuthenticatedUserRequest generates requests for PackagesgetPackageVersionForAuthenticatedUser
func NewPackagesgetPackageVersionForAuthenticatedUserRequest(server string, packageType PackagesgetPackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageVersionForAuthenticatedUserRequest generates requests for PackagesrestorePackageVersionForAuthenticatedUser
func NewPackagesrestorePackageVersionForAuthenticatedUserRequest(server string, packageType PackagesrestorePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/packages/%s/%s/versions/%s/restore", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectscreateForAuthenticatedUserRequest calls the generic ProjectscreateForAuthenticatedUser builder with application/json body
func NewProjectscreateForAuthenticatedUserRequest(server string, body ProjectscreateForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewProjectscreateForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewProjectscreateForAuthenticatedUserRequestWithBody generates requests for ProjectscreateForAuthenticatedUser with any type of body
func NewProjectscreateForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserslistPublicEmailsForAuthenticatedUserRequest generates requests for UserslistPublicEmailsForAuthenticatedUser
func NewUserslistPublicEmailsForAuthenticatedUserRequest(server string, params *UserslistPublicEmailsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/public_emails")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistForAuthenticatedUserRequest generates requests for ReposlistForAuthenticatedUser
func NewReposlistForAuthenticatedUserRequest(server string, params *ReposlistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Visibility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Affiliation != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "affiliation", runtime.ParamLocationQuery, *params.Affiliation); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Before != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposcreateForAuthenticatedUserRequest calls the generic ReposcreateForAuthenticatedUser builder with application/json body
func NewReposcreateForAuthenticatedUserRequest(server string, body ReposcreateForAuthenticatedUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReposcreateForAuthenticatedUserRequestWithBody(server, "application/json", bodyReader)
}

// NewReposcreateForAuthenticatedUserRequestWithBody generates requests for ReposcreateForAuthenticatedUser with any type of body
func NewReposcreateForAuthenticatedUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/repos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReposlistInvitationsForAuthenticatedUserRequest generates requests for ReposlistInvitationsForAuthenticatedUser
func NewReposlistInvitationsForAuthenticatedUserRequest(server string, params *ReposlistInvitationsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/repository_invitations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposdeclineInvitationForAuthenticatedUserRequest generates requests for ReposdeclineInvitationForAuthenticatedUser
func NewReposdeclineInvitationForAuthenticatedUserRequest(server string, invitationId InvitationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/repository_invitations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposacceptInvitationForAuthenticatedUserRequest generates requests for ReposacceptInvitationForAuthenticatedUser
func NewReposacceptInvitationForAuthenticatedUserRequest(server string, invitationId InvitationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "invitation_id", runtime.ParamLocationPath, invitationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/repository_invitations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistReposStarredByAuthenticatedUserRequest generates requests for ActivitylistReposStarredByAuthenticatedUser
func NewActivitylistReposStarredByAuthenticatedUserRequest(server string, params *ActivitylistReposStarredByAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/starred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivityunstarRepoForAuthenticatedUserRequest generates requests for ActivityunstarRepoForAuthenticatedUser
func NewActivityunstarRepoForAuthenticatedUserRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/starred/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitycheckRepoIsStarredByAuthenticatedUserRequest generates requests for ActivitycheckRepoIsStarredByAuthenticatedUser
func NewActivitycheckRepoIsStarredByAuthenticatedUserRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/starred/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitystarRepoForAuthenticatedUserRequest generates requests for ActivitystarRepoForAuthenticatedUser
func NewActivitystarRepoForAuthenticatedUserRequest(server string, owner Owner, repo Repo) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "owner", runtime.ParamLocationPath, owner)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repo", runtime.ParamLocationPath, repo)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/starred/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistWatchedReposForAuthenticatedUserRequest generates requests for ActivitylistWatchedReposForAuthenticatedUser
func NewActivitylistWatchedReposForAuthenticatedUserRequest(server string, params *ActivitylistWatchedReposForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTeamslistForAuthenticatedUserRequest generates requests for TeamslistForAuthenticatedUser
func NewTeamslistForAuthenticatedUserRequest(server string, params *TeamslistForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistRequest generates requests for Userslist
func NewUserslistRequest(server string, params *UserslistParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersgetByUsernameRequest generates requests for UsersgetByUsername
func NewUsersgetByUsernameRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistEventsForAuthenticatedUserRequest generates requests for ActivitylistEventsForAuthenticatedUser
func NewActivitylistEventsForAuthenticatedUserRequest(server string, username Username, params *ActivitylistEventsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistOrgEventsForAuthenticatedUserRequest generates requests for ActivitylistOrgEventsForAuthenticatedUser
func NewActivitylistOrgEventsForAuthenticatedUserRequest(server string, username Username, org Org, params *ActivitylistOrgEventsForAuthenticatedUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "org", runtime.ParamLocationPath, org)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/events/orgs/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistPublicEventsForUserRequest generates requests for ActivitylistPublicEventsForUser
func NewActivitylistPublicEventsForUserRequest(server string, username Username, params *ActivitylistPublicEventsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/events/public", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistFollowersForUserRequest generates requests for UserslistFollowersForUser
func NewUserslistFollowersForUserRequest(server string, username Username, params *UserslistFollowersForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistFollowingForUserRequest generates requests for UserslistFollowingForUser
func NewUserslistFollowingForUserRequest(server string, username Username, params *UserslistFollowingForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/following", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserscheckFollowingForUserRequest generates requests for UserscheckFollowingForUser
func NewUserscheckFollowingForUserRequest(server string, username Username, targetUser string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "target_user", runtime.ParamLocationPath, targetUser)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/following/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGistslistForUserRequest generates requests for GistslistForUser
func NewGistslistForUserRequest(server string, username Username, params *GistslistForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/gists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Since != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, *params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistGpgKeysForUserRequest generates requests for UserslistGpgKeysForUser
func NewUserslistGpgKeysForUserRequest(server string, username Username, params *UserslistGpgKeysForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/gpg_keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersgetContextForUserRequest generates requests for UsersgetContextForUser
func NewUsersgetContextForUserRequest(server string, username Username, params *UsersgetContextForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/hovercard", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.SubjectType != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject_type", runtime.ParamLocationQuery, *params.SubjectType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.SubjectId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subject_id", runtime.ParamLocationQuery, *params.SubjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAppsgetUserInstallationRequest generates requests for AppsgetUserInstallation
func NewAppsgetUserInstallationRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/installation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserslistPublicKeysForUserRequest generates requests for UserslistPublicKeysForUser
func NewUserslistPublicKeysForUserRequest(server string, username Username, params *UserslistPublicKeysForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewOrgslistForUserRequest generates requests for OrgslistForUser
func NewOrgslistForUserRequest(server string, username Username, params *OrgslistForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/orgs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackageslistPackagesForUserRequest generates requests for PackageslistPackagesForUser
func NewPackageslistPackagesForUserRequest(server string, username Username, params *PackageslistPackagesForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package_type", runtime.ParamLocationQuery, params.PackageType); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Visibility != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "visibility", runtime.ParamLocationQuery, *params.Visibility); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageForUserRequest generates requests for PackagesdeletePackageForUser
func NewPackagesdeletePackageForUserRequest(server string, username Username, packageType PackagesdeletePackageForUserParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageForUserRequest generates requests for PackagesgetPackageForUser
func NewPackagesgetPackageForUserRequest(server string, username Username, packageType PackagesgetPackageForUserParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageForUserRequest generates requests for PackagesrestorePackageForUser
func NewPackagesrestorePackageForUserRequest(server string, username Username, packageType PackagesrestorePackageForUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s/restore", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Token != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, *params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetAllPackageVersionsForPackageOwnedByUserRequest generates requests for PackagesgetAllPackageVersionsForPackageOwnedByUser
func NewPackagesgetAllPackageVersionsForPackageOwnedByUserRequest(server string, username Username, packageType PackagesgetAllPackageVersionsForPackageOwnedByUserParamsPackageType, packageName PackageName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s/versions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesdeletePackageVersionForUserRequest generates requests for PackagesdeletePackageVersionForUser
func NewPackagesdeletePackageVersionForUserRequest(server string, username Username, packageType PackagesdeletePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesgetPackageVersionForUserRequest generates requests for PackagesgetPackageVersionForUser
func NewPackagesgetPackageVersionForUserRequest(server string, username Username, packageType PackagesgetPackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s/versions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPackagesrestorePackageVersionForUserRequest generates requests for PackagesrestorePackageVersionForUser
func NewPackagesrestorePackageVersionForUserRequest(server string, username Username, packageType PackagesrestorePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "package_type", runtime.ParamLocationPath, packageType)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "package_name", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "package_version_id", runtime.ParamLocationPath, packageVersionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/packages/%s/%s/versions/%s/restore", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProjectslistForUserRequest generates requests for ProjectslistForUser
func NewProjectslistForUserRequest(server string, username Username, params *ProjectslistForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/projects", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.State != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistReceivedEventsForUserRequest generates requests for ActivitylistReceivedEventsForUser
func NewActivitylistReceivedEventsForUserRequest(server string, username Username, params *ActivitylistReceivedEventsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/received_events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistReceivedPublicEventsForUserRequest generates requests for ActivitylistReceivedPublicEventsForUser
func NewActivitylistReceivedPublicEventsForUserRequest(server string, username Username, params *ActivitylistReceivedPublicEventsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/received_events/public", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReposlistForUserRequest generates requests for ReposlistForUser
func NewReposlistForUserRequest(server string, username Username, params *ReposlistForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/repos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Type != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubActionsBillingUserRequest generates requests for BillinggetGithubActionsBillingUser
func NewBillinggetGithubActionsBillingUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings/billing/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetGithubPackagesBillingUserRequest generates requests for BillinggetGithubPackagesBillingUser
func NewBillinggetGithubPackagesBillingUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings/billing/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBillinggetSharedStorageBillingUserRequest generates requests for BillinggetSharedStorageBillingUser
func NewBillinggetSharedStorageBillingUserRequest(server string, username Username) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings/billing/shared-storage", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistReposStarredByUserRequest generates requests for ActivitylistReposStarredByUser
func NewActivitylistReposStarredByUserRequest(server string, username Username, params *ActivitylistReposStarredByUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/starred", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Sort != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Direction != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewActivitylistReposWatchedByUserRequest generates requests for ActivitylistReposWatchedByUser
func NewActivitylistReposWatchedByUserRequest(server string, username Username, params *ActivitylistReposWatchedByUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/subscriptions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.PerPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Page != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMetagetZenRequest generates requests for MetagetZen
func NewMetagetZenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/zen")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Metaroot request
	MetarootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetarootResponse, error)

	// AppsgetAuthenticated request
	AppsgetAuthenticatedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsgetAuthenticatedResponse, error)

	// AppscreateFromManifest request
	AppscreateFromManifestWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*AppscreateFromManifestResponse, error)

	// AppsgetWebhookConfigForApp request
	AppsgetWebhookConfigForAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsgetWebhookConfigForAppResponse, error)

	// AppsupdateWebhookConfigForApp request with any body
	AppsupdateWebhookConfigForAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsupdateWebhookConfigForAppResponse, error)

	AppsupdateWebhookConfigForAppWithResponse(ctx context.Context, body AppsupdateWebhookConfigForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsupdateWebhookConfigForAppResponse, error)

	// AppslistWebhookDeliveries request
	AppslistWebhookDeliveriesWithResponse(ctx context.Context, params *AppslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*AppslistWebhookDeliveriesResponse, error)

	// AppsgetWebhookDelivery request
	AppsgetWebhookDeliveryWithResponse(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*AppsgetWebhookDeliveryResponse, error)

	// AppsredeliverWebhookDelivery request
	AppsredeliverWebhookDeliveryWithResponse(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*AppsredeliverWebhookDeliveryResponse, error)

	// AppslistInstallations request
	AppslistInstallationsWithResponse(ctx context.Context, params *AppslistInstallationsParams, reqEditors ...RequestEditorFn) (*AppslistInstallationsResponse, error)

	// AppsdeleteInstallation request
	AppsdeleteInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsdeleteInstallationResponse, error)

	// AppsgetInstallation request
	AppsgetInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsgetInstallationResponse, error)

	// AppscreateInstallationAccessToken request with any body
	AppscreateInstallationAccessTokenWithBodyWithResponse(ctx context.Context, installationId InstallationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppscreateInstallationAccessTokenResponse, error)

	AppscreateInstallationAccessTokenWithResponse(ctx context.Context, installationId InstallationId, body AppscreateInstallationAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppscreateInstallationAccessTokenResponse, error)

	// AppsunsuspendInstallation request
	AppsunsuspendInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsunsuspendInstallationResponse, error)

	// AppssuspendInstallation request
	AppssuspendInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppssuspendInstallationResponse, error)

	// OauthAuthorizationslistGrants request
	OauthAuthorizationslistGrantsWithResponse(ctx context.Context, params *OauthAuthorizationslistGrantsParams, reqEditors ...RequestEditorFn) (*OauthAuthorizationslistGrantsResponse, error)

	// OauthAuthorizationsdeleteGrant request
	OauthAuthorizationsdeleteGrantWithResponse(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsdeleteGrantResponse, error)

	// OauthAuthorizationsgetGrant request
	OauthAuthorizationsgetGrantWithResponse(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetGrantResponse, error)

	// AppsdeleteAuthorization request with any body
	AppsdeleteAuthorizationWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsdeleteAuthorizationResponse, error)

	AppsdeleteAuthorizationWithResponse(ctx context.Context, clientId ClientId, body AppsdeleteAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsdeleteAuthorizationResponse, error)

	// AppsdeleteToken request with any body
	AppsdeleteTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsdeleteTokenResponse, error)

	AppsdeleteTokenWithResponse(ctx context.Context, clientId ClientId, body AppsdeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsdeleteTokenResponse, error)

	// AppsresetToken request with any body
	AppsresetTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsresetTokenResponse, error)

	AppsresetTokenWithResponse(ctx context.Context, clientId ClientId, body AppsresetTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsresetTokenResponse, error)

	// AppscheckToken request with any body
	AppscheckTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppscheckTokenResponse, error)

	AppscheckTokenWithResponse(ctx context.Context, clientId ClientId, body AppscheckTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppscheckTokenResponse, error)

	// AppsscopeToken request with any body
	AppsscopeTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsscopeTokenResponse, error)

	AppsscopeTokenWithResponse(ctx context.Context, clientId ClientId, body AppsscopeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsscopeTokenResponse, error)

	// AppsgetBySlug request
	AppsgetBySlugWithResponse(ctx context.Context, appSlug AppSlug, reqEditors ...RequestEditorFn) (*AppsgetBySlugResponse, error)

	// OauthAuthorizationslistAuthorizations request
	OauthAuthorizationslistAuthorizationsWithResponse(ctx context.Context, params *OauthAuthorizationslistAuthorizationsParams, reqEditors ...RequestEditorFn) (*OauthAuthorizationslistAuthorizationsResponse, error)

	// OauthAuthorizationscreateAuthorization request with any body
	OauthAuthorizationscreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationscreateAuthorizationResponse, error)

	OauthAuthorizationscreateAuthorizationWithResponse(ctx context.Context, body OauthAuthorizationscreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationscreateAuthorizationResponse, error)

	// OauthAuthorizationsgetOrCreateAuthorizationForApp request with any body
	OauthAuthorizationsgetOrCreateAuthorizationForAppWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppResponse, error)

	OauthAuthorizationsgetOrCreateAuthorizationForAppWithResponse(ctx context.Context, clientId ClientId, body OauthAuthorizationsgetOrCreateAuthorizationForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppResponse, error)

	// OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint request with any body
	OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBodyWithResponse(ctx context.Context, clientId ClientId, fingerprint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse, error)

	OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithResponse(ctx context.Context, clientId ClientId, fingerprint string, body OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse, error)

	// OauthAuthorizationsdeleteAuthorization request
	OauthAuthorizationsdeleteAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsdeleteAuthorizationResponse, error)

	// OauthAuthorizationsgetAuthorization request
	OauthAuthorizationsgetAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetAuthorizationResponse, error)

	// OauthAuthorizationsupdateAuthorization request with any body
	OauthAuthorizationsupdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationId AuthorizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsupdateAuthorizationResponse, error)

	OauthAuthorizationsupdateAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, body OauthAuthorizationsupdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsupdateAuthorizationResponse, error)

	// CodesOfConductgetAllCodesOfConduct request
	CodesOfConductgetAllCodesOfConductWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CodesOfConductgetAllCodesOfConductResponse, error)

	// CodesOfConductgetConductCode request
	CodesOfConductgetConductCodeWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*CodesOfConductgetConductCodeResponse, error)

	// Emojisget request
	EmojisgetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EmojisgetResponse, error)

	// EnterpriseAdmingetServerStatistics request
	EnterpriseAdmingetServerStatisticsWithResponse(ctx context.Context, enterpriseOrOrg EnterpriseOrOrg, params *EnterpriseAdmingetServerStatisticsParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetServerStatisticsResponse, error)

	// ActionsgetActionsCacheUsageForEnterprise request
	ActionsgetActionsCacheUsageForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageForEnterpriseResponse, error)

	// EnterpriseAdmingetGithubActionsPermissionsEnterprise request
	EnterpriseAdmingetGithubActionsPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse, error)

	// EnterpriseAdminsetGithubActionsPermissionsEnterprise request with any body
	EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse, error)

	EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetGithubActionsPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse, error)

	// EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise request
	EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error)

	// EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise request with any body
	EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error)

	EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error)

	// EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise request
	EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse, error)

	// EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise request
	EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse, error)

	// EnterpriseAdmingetAllowedActionsEnterprise request
	EnterpriseAdmingetAllowedActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetAllowedActionsEnterpriseResponse, error)

	// EnterpriseAdminsetAllowedActionsEnterprise request with any body
	EnterpriseAdminsetAllowedActionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetAllowedActionsEnterpriseResponse, error)

	EnterpriseAdminsetAllowedActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetAllowedActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetAllowedActionsEnterpriseResponse, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise request
	ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error)

	// EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise request
	EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse, error)

	// EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise request with any body
	EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse, error)

	EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse, error)

	// EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise request
	EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse, error)

	// EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise request
	EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse, error)

	// EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise request with any body
	EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse, error)

	EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse, error)

	// EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error)

	// EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise request with any body
	EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error)

	EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error)

	// EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error)

	// EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise request
	EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error)

	// EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise request
	EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse, error)

	// EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise request with any body
	EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse, error)

	EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse, error)

	// EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise request
	EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse, error)

	// EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise request
	EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse, error)

	// EnterpriseAdminlistSelfHostedRunnersForEnterprise request
	EnterpriseAdminlistSelfHostedRunnersForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnersForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse, error)

	// EnterpriseAdminlistRunnerApplicationsForEnterprise request
	EnterpriseAdminlistRunnerApplicationsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse, error)

	// EnterpriseAdmincreateRegistrationTokenForEnterprise request
	EnterpriseAdmincreateRegistrationTokenForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse, error)

	// EnterpriseAdmincreateRemoveTokenForEnterprise request
	EnterpriseAdmincreateRemoveTokenForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateRemoveTokenForEnterpriseResponse, error)

	// EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise request
	EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse, error)

	// EnterpriseAdmingetSelfHostedRunnerForEnterprise request
	EnterpriseAdmingetSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise request
	EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise request
	EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise request with any body
	EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse, error)

	EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise request with any body
	EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse, error)

	EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise request
	EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse, error)

	// EnterpriseAdmingetAuditLog request
	EnterpriseAdmingetAuditLogWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdmingetAuditLogParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetAuditLogResponse, error)

	// SecretScanninglistAlertsForEnterprise request
	SecretScanninglistAlertsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *SecretScanninglistAlertsForEnterpriseParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForEnterpriseResponse, error)

	// BillinggetGithubActionsBillingGhe request
	BillinggetGithubActionsBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingGheResponse, error)

	// BillinggetGithubAdvancedSecurityBillingGhe request
	BillinggetGithubAdvancedSecurityBillingGheWithResponse(ctx context.Context, enterprise Enterprise, params *BillinggetGithubAdvancedSecurityBillingGheParams, reqEditors ...RequestEditorFn) (*BillinggetGithubAdvancedSecurityBillingGheResponse, error)

	// BillinggetGithubPackagesBillingGhe request
	BillinggetGithubPackagesBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingGheResponse, error)

	// BillinggetSharedStorageBillingGhe request
	BillinggetSharedStorageBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingGheResponse, error)

	// ActivitylistPublicEvents request
	ActivitylistPublicEventsWithResponse(ctx context.Context, params *ActivitylistPublicEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsResponse, error)

	// ActivitygetFeeds request
	ActivitygetFeedsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ActivitygetFeedsResponse, error)

	// Gistslist request
	GistslistWithResponse(ctx context.Context, params *GistslistParams, reqEditors ...RequestEditorFn) (*GistslistResponse, error)

	// Gistscreate request with any body
	GistscreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistscreateResponse, error)

	GistscreateWithResponse(ctx context.Context, body GistscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GistscreateResponse, error)

	// GistslistPublic request
	GistslistPublicWithResponse(ctx context.Context, params *GistslistPublicParams, reqEditors ...RequestEditorFn) (*GistslistPublicResponse, error)

	// GistslistStarred request
	GistslistStarredWithResponse(ctx context.Context, params *GistslistStarredParams, reqEditors ...RequestEditorFn) (*GistslistStarredResponse, error)

	// Gistsdelete request
	GistsdeleteWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsdeleteResponse, error)

	// Gistsget request
	GistsgetWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsgetResponse, error)

	// Gistsupdate request with any body
	GistsupdateWithBodyWithResponse(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistsupdateResponse, error)

	GistsupdateWithResponse(ctx context.Context, gistId GistId, body GistsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GistsupdateResponse, error)

	// GistslistComments request
	GistslistCommentsWithResponse(ctx context.Context, gistId GistId, params *GistslistCommentsParams, reqEditors ...RequestEditorFn) (*GistslistCommentsResponse, error)

	// GistscreateComment request with any body
	GistscreateCommentWithBodyWithResponse(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistscreateCommentResponse, error)

	GistscreateCommentWithResponse(ctx context.Context, gistId GistId, body GistscreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*GistscreateCommentResponse, error)

	// GistsdeleteComment request
	GistsdeleteCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*GistsdeleteCommentResponse, error)

	// GistsgetComment request
	GistsgetCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*GistsgetCommentResponse, error)

	// GistsupdateComment request with any body
	GistsupdateCommentWithBodyWithResponse(ctx context.Context, gistId GistId, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistsupdateCommentResponse, error)

	GistsupdateCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, body GistsupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*GistsupdateCommentResponse, error)

	// GistslistCommits request
	GistslistCommitsWithResponse(ctx context.Context, gistId GistId, params *GistslistCommitsParams, reqEditors ...RequestEditorFn) (*GistslistCommitsResponse, error)

	// GistslistForks request
	GistslistForksWithResponse(ctx context.Context, gistId GistId, params *GistslistForksParams, reqEditors ...RequestEditorFn) (*GistslistForksResponse, error)

	// Gistsfork request
	GistsforkWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsforkResponse, error)

	// Gistsunstar request
	GistsunstarWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsunstarResponse, error)

	// GistscheckIsStarred request
	GistscheckIsStarredWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistscheckIsStarredResponse, error)

	// Gistsstar request
	GistsstarWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsstarResponse, error)

	// GistsgetRevision request
	GistsgetRevisionWithResponse(ctx context.Context, gistId GistId, sha string, reqEditors ...RequestEditorFn) (*GistsgetRevisionResponse, error)

	// GitignoregetAllTemplates request
	GitignoregetAllTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GitignoregetAllTemplatesResponse, error)

	// GitignoregetTemplate request
	GitignoregetTemplateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GitignoregetTemplateResponse, error)

	// AppslistReposAccessibleToInstallation request
	AppslistReposAccessibleToInstallationWithResponse(ctx context.Context, params *AppslistReposAccessibleToInstallationParams, reqEditors ...RequestEditorFn) (*AppslistReposAccessibleToInstallationResponse, error)

	// AppsrevokeInstallationAccessToken request
	AppsrevokeInstallationAccessTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsrevokeInstallationAccessTokenResponse, error)

	// Issueslist request
	IssueslistWithResponse(ctx context.Context, params *IssueslistParams, reqEditors ...RequestEditorFn) (*IssueslistResponse, error)

	// LicensesgetAllCommonlyUsed request
	LicensesgetAllCommonlyUsedWithResponse(ctx context.Context, params *LicensesgetAllCommonlyUsedParams, reqEditors ...RequestEditorFn) (*LicensesgetAllCommonlyUsedResponse, error)

	// Licensesget request
	LicensesgetWithResponse(ctx context.Context, license string, reqEditors ...RequestEditorFn) (*LicensesgetResponse, error)

	// Markdownrender request with any body
	MarkdownrenderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkdownrenderResponse, error)

	MarkdownrenderWithResponse(ctx context.Context, body MarkdownrenderJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkdownrenderResponse, error)

	// MarkdownrenderRaw request with any body
	MarkdownrenderRawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkdownrenderRawResponse, error)

	// AppsgetSubscriptionPlanForAccount request
	AppsgetSubscriptionPlanForAccountWithResponse(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*AppsgetSubscriptionPlanForAccountResponse, error)

	// AppslistPlans request
	AppslistPlansWithResponse(ctx context.Context, params *AppslistPlansParams, reqEditors ...RequestEditorFn) (*AppslistPlansResponse, error)

	// AppslistAccountsForPlan request
	AppslistAccountsForPlanWithResponse(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanParams, reqEditors ...RequestEditorFn) (*AppslistAccountsForPlanResponse, error)

	// AppsgetSubscriptionPlanForAccountStubbed request
	AppsgetSubscriptionPlanForAccountStubbedWithResponse(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*AppsgetSubscriptionPlanForAccountStubbedResponse, error)

	// AppslistPlansStubbed request
	AppslistPlansStubbedWithResponse(ctx context.Context, params *AppslistPlansStubbedParams, reqEditors ...RequestEditorFn) (*AppslistPlansStubbedResponse, error)

	// AppslistAccountsForPlanStubbed request
	AppslistAccountsForPlanStubbedWithResponse(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanStubbedParams, reqEditors ...RequestEditorFn) (*AppslistAccountsForPlanStubbedResponse, error)

	// Metaget request
	MetagetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetagetResponse, error)

	// ActivitylistPublicEventsForRepoNetwork request
	ActivitylistPublicEventsForRepoNetworkWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistPublicEventsForRepoNetworkParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsForRepoNetworkResponse, error)

	// ActivitylistNotificationsForAuthenticatedUser request
	ActivitylistNotificationsForAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistNotificationsForAuthenticatedUserResponse, error)

	// ActivitymarkNotificationsAsRead request with any body
	ActivitymarkNotificationsAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitymarkNotificationsAsReadResponse, error)

	ActivitymarkNotificationsAsReadWithResponse(ctx context.Context, body ActivitymarkNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitymarkNotificationsAsReadResponse, error)

	// ActivitygetThread request
	ActivitygetThreadWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitygetThreadResponse, error)

	// ActivitymarkThreadAsRead request
	ActivitymarkThreadAsReadWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitymarkThreadAsReadResponse, error)

	// ActivitydeleteThreadSubscription request
	ActivitydeleteThreadSubscriptionWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitydeleteThreadSubscriptionResponse, error)

	// ActivitygetThreadSubscriptionForAuthenticatedUser request
	ActivitygetThreadSubscriptionForAuthenticatedUserWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitygetThreadSubscriptionForAuthenticatedUserResponse, error)

	// ActivitysetThreadSubscription request with any body
	ActivitysetThreadSubscriptionWithBodyWithResponse(ctx context.Context, threadId ThreadId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitysetThreadSubscriptionResponse, error)

	ActivitysetThreadSubscriptionWithResponse(ctx context.Context, threadId ThreadId, body ActivitysetThreadSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitysetThreadSubscriptionResponse, error)

	// MetagetOctocat request
	MetagetOctocatWithResponse(ctx context.Context, params *MetagetOctocatParams, reqEditors ...RequestEditorFn) (*MetagetOctocatResponse, error)

	// Orgslist request
	OrgslistWithResponse(ctx context.Context, params *OrgslistParams, reqEditors ...RequestEditorFn) (*OrgslistResponse, error)

	// OrgslistCustomRoles request
	OrgslistCustomRolesWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*OrgslistCustomRolesResponse, error)

	// Orgsget request
	OrgsgetWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgsgetResponse, error)

	// Orgsupdate request with any body
	OrgsupdateWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateResponse, error)

	OrgsupdateWithResponse(ctx context.Context, org Org, body OrgsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateResponse, error)

	// ActionsgetActionsCacheUsageForOrg request
	ActionsgetActionsCacheUsageForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageForOrgResponse, error)

	// ActionsgetActionsCacheUsageByRepoForOrg request
	ActionsgetActionsCacheUsageByRepoForOrgWithResponse(ctx context.Context, org Org, params *ActionsgetActionsCacheUsageByRepoForOrgParams, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageByRepoForOrgResponse, error)

	// ActionsgetGithubActionsPermissionsOrganization request
	ActionsgetGithubActionsPermissionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsPermissionsOrganizationResponse, error)

	// ActionssetGithubActionsPermissionsOrganization request with any body
	ActionssetGithubActionsPermissionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsOrganizationResponse, error)

	ActionssetGithubActionsPermissionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetGithubActionsPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsOrganizationResponse, error)

	// ActionslistSelectedRepositoriesEnabledGithubActionsOrganization request
	ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse(ctx context.Context, org Org, params *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationParams, reqEditors ...RequestEditorFn) (*ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error)

	// ActionssetSelectedRepositoriesEnabledGithubActionsOrganization request with any body
	ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error)

	ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error)

	// ActionsdisableSelectedRepositoryGithubActionsOrganization request
	ActionsdisableSelectedRepositoryGithubActionsOrganizationWithResponse(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse, error)

	// ActionsenableSelectedRepositoryGithubActionsOrganization request
	ActionsenableSelectedRepositoryGithubActionsOrganizationWithResponse(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsenableSelectedRepositoryGithubActionsOrganizationResponse, error)

	// ActionsgetAllowedActionsOrganization request
	ActionsgetAllowedActionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetAllowedActionsOrganizationResponse, error)

	// ActionssetAllowedActionsOrganization request with any body
	ActionssetAllowedActionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsOrganizationResponse, error)

	ActionssetAllowedActionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetAllowedActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsOrganizationResponse, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization request
	ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsOrganization request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error)

	// ActionslistSelfHostedRunnerGroupsForOrg request
	ActionslistSelfHostedRunnerGroupsForOrgWithResponse(ctx context.Context, org Org, params *ActionslistSelfHostedRunnerGroupsForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnerGroupsForOrgResponse, error)

	// ActionscreateSelfHostedRunnerGroupForOrg request with any body
	ActionscreateSelfHostedRunnerGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateSelfHostedRunnerGroupForOrgResponse, error)

	ActionscreateSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, body ActionscreateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateSelfHostedRunnerGroupForOrgResponse, error)

	// ActionsdeleteSelfHostedRunnerGroupFromOrg request
	ActionsdeleteSelfHostedRunnerGroupFromOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerGroupFromOrgResponse, error)

	// ActionsgetSelfHostedRunnerGroupForOrg request
	ActionsgetSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerGroupForOrgResponse, error)

	// ActionsupdateSelfHostedRunnerGroupForOrg request with any body
	ActionsupdateSelfHostedRunnerGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsupdateSelfHostedRunnerGroupForOrgResponse, error)

	ActionsupdateSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionsupdateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsupdateSelfHostedRunnerGroupForOrgResponse, error)

	// ActionslistRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionslistRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgParams, reqEditors ...RequestEditorFn) (*ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse, error)

	// ActionssetRepoAccessToSelfHostedRunnerGroupInOrg request with any body
	ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse, error)

	ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetRepoAccessToSelfHostedRunnerGroupInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse, error)

	// ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse, error)

	// ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg request
	ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse, error)

	// ActionslistSelfHostedRunnersInGroupForOrg request
	ActionslistSelfHostedRunnersInGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistSelfHostedRunnersInGroupForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersInGroupForOrgResponse, error)

	// ActionssetSelfHostedRunnersInGroupForOrg request with any body
	ActionssetSelfHostedRunnersInGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelfHostedRunnersInGroupForOrgResponse, error)

	ActionssetSelfHostedRunnersInGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetSelfHostedRunnersInGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelfHostedRunnersInGroupForOrgResponse, error)

	// ActionsremoveSelfHostedRunnerFromGroupForOrg request
	ActionsremoveSelfHostedRunnerFromGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveSelfHostedRunnerFromGroupForOrgResponse, error)

	// ActionsaddSelfHostedRunnerToGroupForOrg request
	ActionsaddSelfHostedRunnerToGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsaddSelfHostedRunnerToGroupForOrgResponse, error)

	// ActionslistSelfHostedRunnersForOrg request
	ActionslistSelfHostedRunnersForOrgWithResponse(ctx context.Context, org Org, params *ActionslistSelfHostedRunnersForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersForOrgResponse, error)

	// ActionslistRunnerApplicationsForOrg request
	ActionslistRunnerApplicationsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionslistRunnerApplicationsForOrgResponse, error)

	// ActionscreateRegistrationTokenForOrg request
	ActionscreateRegistrationTokenForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionscreateRegistrationTokenForOrgResponse, error)

	// ActionscreateRemoveTokenForOrg request
	ActionscreateRemoveTokenForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionscreateRemoveTokenForOrgResponse, error)

	// ActionsdeleteSelfHostedRunnerFromOrg request
	ActionsdeleteSelfHostedRunnerFromOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerFromOrgResponse, error)

	// ActionsgetSelfHostedRunnerForOrg request
	ActionsgetSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerForOrgResponse, error)

	// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg request
	ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse, error)

	// ActionslistLabelsForSelfHostedRunnerForOrg request
	ActionslistLabelsForSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionslistLabelsForSelfHostedRunnerForOrgResponse, error)

	// ActionsaddCustomLabelsToSelfHostedRunnerForOrg request with any body
	ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse, error)

	ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse, error)

	// ActionssetCustomLabelsForSelfHostedRunnerForOrg request with any body
	ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse, error)

	ActionssetCustomLabelsForSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse, error)

	// ActionsremoveCustomLabelFromSelfHostedRunnerForOrg request
	ActionsremoveCustomLabelFromSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse, error)

	// ActionslistOrgSecrets request
	ActionslistOrgSecretsWithResponse(ctx context.Context, org Org, params *ActionslistOrgSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistOrgSecretsResponse, error)

	// ActionsgetOrgPublicKey request
	ActionsgetOrgPublicKeyWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetOrgPublicKeyResponse, error)

	// ActionsdeleteOrgSecret request
	ActionsdeleteOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteOrgSecretResponse, error)

	// ActionsgetOrgSecret request
	ActionsgetOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetOrgSecretResponse, error)

	// ActionscreateOrUpdateOrgSecret request with any body
	ActionscreateOrUpdateOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateOrgSecretResponse, error)

	ActionscreateOrUpdateOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body ActionscreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateOrgSecretResponse, error)

	// ActionslistSelectedReposForOrgSecret request
	ActionslistSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, params *ActionslistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*ActionslistSelectedReposForOrgSecretResponse, error)

	// ActionssetSelectedReposForOrgSecret request with any body
	ActionssetSelectedReposForOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelectedReposForOrgSecretResponse, error)

	ActionssetSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body ActionssetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelectedReposForOrgSecretResponse, error)

	// ActionsremoveSelectedRepoFromOrgSecret request
	ActionsremoveSelectedRepoFromOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*ActionsremoveSelectedRepoFromOrgSecretResponse, error)

	// ActionsaddSelectedRepoToOrgSecret request
	ActionsaddSelectedRepoToOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*ActionsaddSelectedRepoToOrgSecretResponse, error)

	// OrgsgetAuditLog request
	OrgsgetAuditLogWithResponse(ctx context.Context, org Org, params *OrgsgetAuditLogParams, reqEditors ...RequestEditorFn) (*OrgsgetAuditLogResponse, error)

	// OrgslistBlockedUsers request
	OrgslistBlockedUsersWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgslistBlockedUsersResponse, error)

	// OrgsunblockUser request
	OrgsunblockUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsunblockUserResponse, error)

	// OrgscheckBlockedUser request
	OrgscheckBlockedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckBlockedUserResponse, error)

	// OrgsblockUser request
	OrgsblockUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsblockUserResponse, error)

	// CodeScanninglistAlertsForOrg request
	CodeScanninglistAlertsForOrgWithResponse(ctx context.Context, org Org, params *CodeScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertsForOrgResponse, error)

	// OrgslistSamlSsoAuthorizations request
	OrgslistSamlSsoAuthorizationsWithResponse(ctx context.Context, org Org, params *OrgslistSamlSsoAuthorizationsParams, reqEditors ...RequestEditorFn) (*OrgslistSamlSsoAuthorizationsResponse, error)

	// OrgsremoveSamlSsoAuthorization request
	OrgsremoveSamlSsoAuthorizationWithResponse(ctx context.Context, org Org, credentialId int, reqEditors ...RequestEditorFn) (*OrgsremoveSamlSsoAuthorizationResponse, error)

	// DependabotlistOrgSecrets request
	DependabotlistOrgSecretsWithResponse(ctx context.Context, org Org, params *DependabotlistOrgSecretsParams, reqEditors ...RequestEditorFn) (*DependabotlistOrgSecretsResponse, error)

	// DependabotgetOrgPublicKey request
	DependabotgetOrgPublicKeyWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*DependabotgetOrgPublicKeyResponse, error)

	// DependabotdeleteOrgSecret request
	DependabotdeleteOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotdeleteOrgSecretResponse, error)

	// DependabotgetOrgSecret request
	DependabotgetOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotgetOrgSecretResponse, error)

	// DependabotcreateOrUpdateOrgSecret request with any body
	DependabotcreateOrUpdateOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateOrgSecretResponse, error)

	DependabotcreateOrUpdateOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body DependabotcreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateOrgSecretResponse, error)

	// DependabotlistSelectedReposForOrgSecret request
	DependabotlistSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, params *DependabotlistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*DependabotlistSelectedReposForOrgSecretResponse, error)

	// DependabotsetSelectedReposForOrgSecret request with any body
	DependabotsetSelectedReposForOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotsetSelectedReposForOrgSecretResponse, error)

	DependabotsetSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body DependabotsetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotsetSelectedReposForOrgSecretResponse, error)

	// DependabotremoveSelectedRepoFromOrgSecret request
	DependabotremoveSelectedRepoFromOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*DependabotremoveSelectedRepoFromOrgSecretResponse, error)

	// DependabotaddSelectedRepoToOrgSecret request
	DependabotaddSelectedRepoToOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*DependabotaddSelectedRepoToOrgSecretResponse, error)

	// ActivitylistPublicOrgEvents request
	ActivitylistPublicOrgEventsWithResponse(ctx context.Context, org Org, params *ActivitylistPublicOrgEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicOrgEventsResponse, error)

	// TeamsexternalIdpGroupInfoForOrg request
	TeamsexternalIdpGroupInfoForOrgWithResponse(ctx context.Context, org Org, groupId GroupId, reqEditors ...RequestEditorFn) (*TeamsexternalIdpGroupInfoForOrgResponse, error)

	// TeamslistExternalIdpGroupsForOrg request
	TeamslistExternalIdpGroupsForOrgWithResponse(ctx context.Context, org Org, params *TeamslistExternalIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*TeamslistExternalIdpGroupsForOrgResponse, error)

	// OrgslistFailedInvitations request
	OrgslistFailedInvitationsWithResponse(ctx context.Context, org Org, params *OrgslistFailedInvitationsParams, reqEditors ...RequestEditorFn) (*OrgslistFailedInvitationsResponse, error)

	// OrgslistWebhooks request
	OrgslistWebhooksWithResponse(ctx context.Context, org Org, params *OrgslistWebhooksParams, reqEditors ...RequestEditorFn) (*OrgslistWebhooksResponse, error)

	// OrgscreateWebhook request with any body
	OrgscreateWebhookWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgscreateWebhookResponse, error)

	OrgscreateWebhookWithResponse(ctx context.Context, org Org, body OrgscreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgscreateWebhookResponse, error)

	// OrgsdeleteWebhook request
	OrgsdeleteWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsdeleteWebhookResponse, error)

	// OrgsgetWebhook request
	OrgsgetWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookResponse, error)

	// OrgsupdateWebhook request with any body
	OrgsupdateWebhookWithBodyWithResponse(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookResponse, error)

	OrgsupdateWebhookWithResponse(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookResponse, error)

	// OrgsgetWebhookConfigForOrg request
	OrgsgetWebhookConfigForOrgWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookConfigForOrgResponse, error)

	// OrgsupdateWebhookConfigForOrg request with any body
	OrgsupdateWebhookConfigForOrgWithBodyWithResponse(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookConfigForOrgResponse, error)

	OrgsupdateWebhookConfigForOrgWithResponse(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookConfigForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookConfigForOrgResponse, error)

	// OrgslistWebhookDeliveries request
	OrgslistWebhookDeliveriesWithResponse(ctx context.Context, org Org, hookId HookId, params *OrgslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*OrgslistWebhookDeliveriesResponse, error)

	// OrgsgetWebhookDelivery request
	OrgsgetWebhookDeliveryWithResponse(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookDeliveryResponse, error)

	// OrgsredeliverWebhookDelivery request
	OrgsredeliverWebhookDeliveryWithResponse(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*OrgsredeliverWebhookDeliveryResponse, error)

	// OrgspingWebhook request
	OrgspingWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgspingWebhookResponse, error)

	// AppsgetOrgInstallation request
	AppsgetOrgInstallationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*AppsgetOrgInstallationResponse, error)

	// OrgslistAppInstallations request
	OrgslistAppInstallationsWithResponse(ctx context.Context, org Org, params *OrgslistAppInstallationsParams, reqEditors ...RequestEditorFn) (*OrgslistAppInstallationsResponse, error)

	// InteractionsremoveRestrictionsForOrg request
	InteractionsremoveRestrictionsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForOrgResponse, error)

	// InteractionsgetRestrictionsForOrg request
	InteractionsgetRestrictionsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForOrgResponse, error)

	// InteractionssetRestrictionsForOrg request with any body
	InteractionssetRestrictionsForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForOrgResponse, error)

	InteractionssetRestrictionsForOrgWithResponse(ctx context.Context, org Org, body InteractionssetRestrictionsForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForOrgResponse, error)

	// OrgslistPendingInvitations request
	OrgslistPendingInvitationsWithResponse(ctx context.Context, org Org, params *OrgslistPendingInvitationsParams, reqEditors ...RequestEditorFn) (*OrgslistPendingInvitationsResponse, error)

	// OrgscreateInvitation request with any body
	OrgscreateInvitationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgscreateInvitationResponse, error)

	OrgscreateInvitationWithResponse(ctx context.Context, org Org, body OrgscreateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgscreateInvitationResponse, error)

	// OrgscancelInvitation request
	OrgscancelInvitationWithResponse(ctx context.Context, org Org, invitationId InvitationId, reqEditors ...RequestEditorFn) (*OrgscancelInvitationResponse, error)

	// OrgslistInvitationTeams request
	OrgslistInvitationTeamsWithResponse(ctx context.Context, org Org, invitationId InvitationId, params *OrgslistInvitationTeamsParams, reqEditors ...RequestEditorFn) (*OrgslistInvitationTeamsResponse, error)

	// IssueslistForOrg request
	IssueslistForOrgWithResponse(ctx context.Context, org Org, params *IssueslistForOrgParams, reqEditors ...RequestEditorFn) (*IssueslistForOrgResponse, error)

	// OrgslistMembers request
	OrgslistMembersWithResponse(ctx context.Context, org Org, params *OrgslistMembersParams, reqEditors ...RequestEditorFn) (*OrgslistMembersResponse, error)

	// OrgsremoveMember request
	OrgsremoveMemberWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveMemberResponse, error)

	// OrgscheckMembershipForUser request
	OrgscheckMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckMembershipForUserResponse, error)

	// OrgsremoveMembershipForUser request
	OrgsremoveMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveMembershipForUserResponse, error)

	// OrgsgetMembershipForUser request
	OrgsgetMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsgetMembershipForUserResponse, error)

	// OrgssetMembershipForUser request with any body
	OrgssetMembershipForUserWithBodyWithResponse(ctx context.Context, org Org, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgssetMembershipForUserResponse, error)

	OrgssetMembershipForUserWithResponse(ctx context.Context, org Org, username Username, body OrgssetMembershipForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgssetMembershipForUserResponse, error)

	// MigrationslistForOrg request
	MigrationslistForOrgWithResponse(ctx context.Context, org Org, params *MigrationslistForOrgParams, reqEditors ...RequestEditorFn) (*MigrationslistForOrgResponse, error)

	// MigrationsstartForOrg request with any body
	MigrationsstartForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartForOrgResponse, error)

	MigrationsstartForOrgWithResponse(ctx context.Context, org Org, body MigrationsstartForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartForOrgResponse, error)

	// MigrationsgetStatusForOrg request
	MigrationsgetStatusForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, params *MigrationsgetStatusForOrgParams, reqEditors ...RequestEditorFn) (*MigrationsgetStatusForOrgResponse, error)

	// MigrationsdeleteArchiveForOrg request
	MigrationsdeleteArchiveForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdeleteArchiveForOrgResponse, error)

	// MigrationsdownloadArchiveForOrg request
	MigrationsdownloadArchiveForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdownloadArchiveForOrgResponse, error)

	// MigrationsunlockRepoForOrg request
	MigrationsunlockRepoForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*MigrationsunlockRepoForOrgResponse, error)

	// MigrationslistReposForOrg request
	MigrationslistReposForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, params *MigrationslistReposForOrgParams, reqEditors ...RequestEditorFn) (*MigrationslistReposForOrgResponse, error)

	// OrgslistOutsideCollaborators request
	OrgslistOutsideCollaboratorsWithResponse(ctx context.Context, org Org, params *OrgslistOutsideCollaboratorsParams, reqEditors ...RequestEditorFn) (*OrgslistOutsideCollaboratorsResponse, error)

	// OrgsremoveOutsideCollaborator request
	OrgsremoveOutsideCollaboratorWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveOutsideCollaboratorResponse, error)

	// OrgsconvertMemberToOutsideCollaborator request
	OrgsconvertMemberToOutsideCollaboratorWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsconvertMemberToOutsideCollaboratorResponse, error)

	// PackageslistPackagesForOrganization request
	PackageslistPackagesForOrganizationWithResponse(ctx context.Context, org Org, params *PackageslistPackagesForOrganizationParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForOrganizationResponse, error)

	// PackagesdeletePackageForOrg request
	PackagesdeletePackageForOrgWithResponse(ctx context.Context, org Org, packageType PackagesdeletePackageForOrgParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForOrgResponse, error)

	// PackagesgetPackageForOrganization request
	PackagesgetPackageForOrganizationWithResponse(ctx context.Context, org Org, packageType PackagesgetPackageForOrganizationParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForOrganizationResponse, error)

	// PackagesrestorePackageForOrg request
	PackagesrestorePackageForOrgWithResponse(ctx context.Context, org Org, packageType PackagesrestorePackageForOrgParamsPackageType, packageName PackageName, params *PackagesrestorePackageForOrgParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForOrgResponse, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByOrg request
	PackagesgetAllPackageVersionsForPackageOwnedByOrgWithResponse(ctx context.Context, org Org, packageType PackagesgetAllPackageVersionsForPackageOwnedByOrgParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByOrgParams, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse, error)

	// PackagesdeletePackageVersionForOrg request
	PackagesdeletePackageVersionForOrgWithResponse(ctx context.Context, org Org, packageType PackagesdeletePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForOrgResponse, error)

	// PackagesgetPackageVersionForOrganization request
	PackagesgetPackageVersionForOrganizationWithResponse(ctx context.Context, org Org, packageType PackagesgetPackageVersionForOrganizationParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForOrganizationResponse, error)

	// PackagesrestorePackageVersionForOrg request
	PackagesrestorePackageVersionForOrgWithResponse(ctx context.Context, org Org, packageType PackagesrestorePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForOrgResponse, error)

	// ProjectslistForOrg request
	ProjectslistForOrgWithResponse(ctx context.Context, org Org, params *ProjectslistForOrgParams, reqEditors ...RequestEditorFn) (*ProjectslistForOrgResponse, error)

	// ProjectscreateForOrg request with any body
	ProjectscreateForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForOrgResponse, error)

	ProjectscreateForOrgWithResponse(ctx context.Context, org Org, body ProjectscreateForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForOrgResponse, error)

	// OrgslistPublicMembers request
	OrgslistPublicMembersWithResponse(ctx context.Context, org Org, params *OrgslistPublicMembersParams, reqEditors ...RequestEditorFn) (*OrgslistPublicMembersResponse, error)

	// OrgsremovePublicMembershipForAuthenticatedUser request
	OrgsremovePublicMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremovePublicMembershipForAuthenticatedUserResponse, error)

	// OrgscheckPublicMembershipForUser request
	OrgscheckPublicMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckPublicMembershipForUserResponse, error)

	// OrgssetPublicMembershipForAuthenticatedUser request
	OrgssetPublicMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgssetPublicMembershipForAuthenticatedUserResponse, error)

	// ReposlistForOrg request
	ReposlistForOrgWithResponse(ctx context.Context, org Org, params *ReposlistForOrgParams, reqEditors ...RequestEditorFn) (*ReposlistForOrgResponse, error)

	// ReposcreateInOrg request with any body
	ReposcreateInOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateInOrgResponse, error)

	ReposcreateInOrgWithResponse(ctx context.Context, org Org, body ReposcreateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateInOrgResponse, error)

	// SecretScanninglistAlertsForOrg request
	SecretScanninglistAlertsForOrgWithResponse(ctx context.Context, org Org, params *SecretScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForOrgResponse, error)

	// BillinggetGithubActionsBillingOrg request
	BillinggetGithubActionsBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingOrgResponse, error)

	// BillinggetGithubAdvancedSecurityBillingOrg request
	BillinggetGithubAdvancedSecurityBillingOrgWithResponse(ctx context.Context, org Org, params *BillinggetGithubAdvancedSecurityBillingOrgParams, reqEditors ...RequestEditorFn) (*BillinggetGithubAdvancedSecurityBillingOrgResponse, error)

	// BillinggetGithubPackagesBillingOrg request
	BillinggetGithubPackagesBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingOrgResponse, error)

	// BillinggetSharedStorageBillingOrg request
	BillinggetSharedStorageBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingOrgResponse, error)

	// TeamslistIdpGroupsForOrg request
	TeamslistIdpGroupsForOrgWithResponse(ctx context.Context, org Org, params *TeamslistIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsForOrgResponse, error)

	// Teamslist request
	TeamslistWithResponse(ctx context.Context, org Org, params *TeamslistParams, reqEditors ...RequestEditorFn) (*TeamslistResponse, error)

	// Teamscreate request with any body
	TeamscreateWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateResponse, error)

	TeamscreateWithResponse(ctx context.Context, org Org, body TeamscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateResponse, error)

	// TeamsdeleteInOrg request
	TeamsdeleteInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsdeleteInOrgResponse, error)

	// TeamsgetByName request
	TeamsgetByNameWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsgetByNameResponse, error)

	// TeamsupdateInOrg request with any body
	TeamsupdateInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateInOrgResponse, error)

	TeamsupdateInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamsupdateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateInOrgResponse, error)

	// TeamslistDiscussionsInOrg request
	TeamslistDiscussionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistDiscussionsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionsInOrgResponse, error)

	// TeamscreateDiscussionInOrg request with any body
	TeamscreateDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionInOrgResponse, error)

	TeamscreateDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionInOrgResponse, error)

	// TeamsdeleteDiscussionInOrg request
	TeamsdeleteDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionInOrgResponse, error)

	// TeamsgetDiscussionInOrg request
	TeamsgetDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionInOrgResponse, error)

	// TeamsupdateDiscussionInOrg request with any body
	TeamsupdateDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionInOrgResponse, error)

	TeamsupdateDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamsupdateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionInOrgResponse, error)

	// TeamslistDiscussionCommentsInOrg request
	TeamslistDiscussionCommentsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionCommentsInOrgResponse, error)

	// TeamscreateDiscussionCommentInOrg request with any body
	TeamscreateDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentInOrgResponse, error)

	TeamscreateDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentInOrgResponse, error)

	// TeamsdeleteDiscussionCommentInOrg request
	TeamsdeleteDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionCommentInOrgResponse, error)

	// TeamsgetDiscussionCommentInOrg request
	TeamsgetDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionCommentInOrgResponse, error)

	// TeamsupdateDiscussionCommentInOrg request with any body
	TeamsupdateDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentInOrgResponse, error)

	TeamsupdateDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentInOrgResponse, error)

	// ReactionslistForTeamDiscussionCommentInOrg request
	ReactionslistForTeamDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentInOrgParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionCommentInOrgResponse, error)

	// ReactionscreateForTeamDiscussionCommentInOrg request with any body
	ReactionscreateForTeamDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentInOrgResponse, error)

	ReactionscreateForTeamDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentInOrgResponse, error)

	// ReactionsdeleteForTeamDiscussionComment request
	ReactionsdeleteForTeamDiscussionCommentWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForTeamDiscussionCommentResponse, error)

	// ReactionslistForTeamDiscussionInOrg request
	ReactionslistForTeamDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionInOrgParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionInOrgResponse, error)

	// ReactionscreateForTeamDiscussionInOrg request with any body
	ReactionscreateForTeamDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionInOrgResponse, error)

	ReactionscreateForTeamDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionInOrgResponse, error)

	// ReactionsdeleteForTeamDiscussion request
	ReactionsdeleteForTeamDiscussionWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForTeamDiscussionResponse, error)

	// TeamsunlinkExternalIdpGroupFromTeamForOrg request
	TeamsunlinkExternalIdpGroupFromTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsunlinkExternalIdpGroupFromTeamForOrgResponse, error)

	// TeamslistLinkedExternalIdpGroupsToTeamForOrg request
	TeamslistLinkedExternalIdpGroupsToTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse, error)

	// TeamslinkExternalIdpGroupToTeamForOrg request with any body
	TeamslinkExternalIdpGroupToTeamForOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamslinkExternalIdpGroupToTeamForOrgResponse, error)

	TeamslinkExternalIdpGroupToTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamslinkExternalIdpGroupToTeamForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamslinkExternalIdpGroupToTeamForOrgResponse, error)

	// TeamslistPendingInvitationsInOrg request
	TeamslistPendingInvitationsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistPendingInvitationsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistPendingInvitationsInOrgResponse, error)

	// TeamslistMembersInOrg request
	TeamslistMembersInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistMembersInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistMembersInOrgResponse, error)

	// TeamsremoveMembershipForUserInOrg request
	TeamsremoveMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMembershipForUserInOrgResponse, error)

	// TeamsgetMembershipForUserInOrg request
	TeamsgetMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMembershipForUserInOrgResponse, error)

	// TeamsaddOrUpdateMembershipForUserInOrg request with any body
	TeamsaddOrUpdateMembershipForUserInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserInOrgResponse, error)

	TeamsaddOrUpdateMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, body TeamsaddOrUpdateMembershipForUserInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserInOrgResponse, error)

	// TeamslistProjectsInOrg request
	TeamslistProjectsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistProjectsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistProjectsInOrgResponse, error)

	// TeamsremoveProjectInOrg request
	TeamsremoveProjectInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamsremoveProjectInOrgResponse, error)

	// TeamscheckPermissionsForProjectInOrg request
	TeamscheckPermissionsForProjectInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForProjectInOrgResponse, error)

	// TeamsaddOrUpdateProjectPermissionsInOrg request with any body
	TeamsaddOrUpdateProjectPermissionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsInOrgResponse, error)

	TeamsaddOrUpdateProjectPermissionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsInOrgResponse, error)

	// TeamslistReposInOrg request
	TeamslistReposInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistReposInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistReposInOrgResponse, error)

	// TeamsremoveRepoInOrg request
	TeamsremoveRepoInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamsremoveRepoInOrgResponse, error)

	// TeamscheckPermissionsForRepoInOrg request
	TeamscheckPermissionsForRepoInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForRepoInOrgResponse, error)

	// TeamsaddOrUpdateRepoPermissionsInOrg request with any body
	TeamsaddOrUpdateRepoPermissionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsInOrgResponse, error)

	TeamsaddOrUpdateRepoPermissionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsInOrgResponse, error)

	// TeamslistIdpGroupsInOrg request
	TeamslistIdpGroupsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsInOrgResponse, error)

	// TeamscreateOrUpdateIdpGroupConnectionsInOrg request with any body
	TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse, error)

	TeamscreateOrUpdateIdpGroupConnectionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateOrUpdateIdpGroupConnectionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse, error)

	// TeamslistChildInOrg request
	TeamslistChildInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistChildInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistChildInOrgResponse, error)

	// ProjectsdeleteCard request
	ProjectsdeleteCardWithResponse(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*ProjectsdeleteCardResponse, error)

	// ProjectsgetCard request
	ProjectsgetCardWithResponse(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*ProjectsgetCardResponse, error)

	// ProjectsupdateCard request with any body
	ProjectsupdateCardWithBodyWithResponse(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateCardResponse, error)

	ProjectsupdateCardWithResponse(ctx context.Context, cardId CardId, body ProjectsupdateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateCardResponse, error)

	// ProjectsmoveCard request with any body
	ProjectsmoveCardWithBodyWithResponse(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsmoveCardResponse, error)

	ProjectsmoveCardWithResponse(ctx context.Context, cardId CardId, body ProjectsmoveCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsmoveCardResponse, error)

	// ProjectsdeleteColumn request
	ProjectsdeleteColumnWithResponse(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*ProjectsdeleteColumnResponse, error)

	// ProjectsgetColumn request
	ProjectsgetColumnWithResponse(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*ProjectsgetColumnResponse, error)

	// ProjectsupdateColumn request with any body
	ProjectsupdateColumnWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateColumnResponse, error)

	ProjectsupdateColumnWithResponse(ctx context.Context, columnId ColumnId, body ProjectsupdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateColumnResponse, error)

	// ProjectslistCards request
	ProjectslistCardsWithResponse(ctx context.Context, columnId ColumnId, params *ProjectslistCardsParams, reqEditors ...RequestEditorFn) (*ProjectslistCardsResponse, error)

	// ProjectscreateCard request with any body
	ProjectscreateCardWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateCardResponse, error)

	ProjectscreateCardWithResponse(ctx context.Context, columnId ColumnId, body ProjectscreateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateCardResponse, error)

	// ProjectsmoveColumn request with any body
	ProjectsmoveColumnWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsmoveColumnResponse, error)

	ProjectsmoveColumnWithResponse(ctx context.Context, columnId ColumnId, body ProjectsmoveColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsmoveColumnResponse, error)

	// Projectsdelete request
	ProjectsdeleteWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ProjectsdeleteResponse, error)

	// Projectsget request
	ProjectsgetWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ProjectsgetResponse, error)

	// Projectsupdate request with any body
	ProjectsupdateWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateResponse, error)

	ProjectsupdateWithResponse(ctx context.Context, projectId ProjectId, body ProjectsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateResponse, error)

	// ProjectslistCollaborators request
	ProjectslistCollaboratorsWithResponse(ctx context.Context, projectId ProjectId, params *ProjectslistCollaboratorsParams, reqEditors ...RequestEditorFn) (*ProjectslistCollaboratorsResponse, error)

	// ProjectsremoveCollaborator request
	ProjectsremoveCollaboratorWithResponse(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*ProjectsremoveCollaboratorResponse, error)

	// ProjectsaddCollaborator request with any body
	ProjectsaddCollaboratorWithBodyWithResponse(ctx context.Context, projectId ProjectId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsaddCollaboratorResponse, error)

	ProjectsaddCollaboratorWithResponse(ctx context.Context, projectId ProjectId, username Username, body ProjectsaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsaddCollaboratorResponse, error)

	// ProjectsgetPermissionForUser request
	ProjectsgetPermissionForUserWithResponse(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*ProjectsgetPermissionForUserResponse, error)

	// ProjectslistColumns request
	ProjectslistColumnsWithResponse(ctx context.Context, projectId ProjectId, params *ProjectslistColumnsParams, reqEditors ...RequestEditorFn) (*ProjectslistColumnsResponse, error)

	// ProjectscreateColumn request with any body
	ProjectscreateColumnWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateColumnResponse, error)

	ProjectscreateColumnWithResponse(ctx context.Context, projectId ProjectId, body ProjectscreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateColumnResponse, error)

	// RateLimitget request
	RateLimitgetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RateLimitgetResponse, error)

	// Reposdelete request
	ReposdeleteWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdeleteResponse, error)

	// Reposget request
	ReposgetWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetResponse, error)

	// Reposupdate request with any body
	ReposupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateResponse, error)

	ReposupdateWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateResponse, error)

	// ActionslistArtifactsForRepo request
	ActionslistArtifactsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistArtifactsForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistArtifactsForRepoResponse, error)

	// ActionsdeleteArtifact request
	ActionsdeleteArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*ActionsdeleteArtifactResponse, error)

	// ActionsgetArtifact request
	ActionsgetArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*ActionsgetArtifactResponse, error)

	// ActionsdownloadArtifact request
	ActionsdownloadArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, archiveFormat string, reqEditors ...RequestEditorFn) (*ActionsdownloadArtifactResponse, error)

	// ActionsgetActionsCacheUsage request
	ActionsgetActionsCacheUsageWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageResponse, error)

	// ActionsgetJobForWorkflowRun request
	ActionsgetJobForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*ActionsgetJobForWorkflowRunResponse, error)

	// ActionsdownloadJobLogsForWorkflowRun request
	ActionsdownloadJobLogsForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*ActionsdownloadJobLogsForWorkflowRunResponse, error)

	// ActionsreRunJobForWorkflowRun request with any body
	ActionsreRunJobForWorkflowRunWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunJobForWorkflowRunResponse, error)

	ActionsreRunJobForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, body ActionsreRunJobForWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunJobForWorkflowRunResponse, error)

	// ActionsgetGithubActionsPermissionsRepository request
	ActionsgetGithubActionsPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsPermissionsRepositoryResponse, error)

	// ActionssetGithubActionsPermissionsRepository request with any body
	ActionssetGithubActionsPermissionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsRepositoryResponse, error)

	ActionssetGithubActionsPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsRepositoryResponse, error)

	// ActionsgetWorkflowAccessToRepository request
	ActionsgetWorkflowAccessToRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowAccessToRepositoryResponse, error)

	// ActionssetWorkflowAccessToRepository request with any body
	ActionssetWorkflowAccessToRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetWorkflowAccessToRepositoryResponse, error)

	ActionssetWorkflowAccessToRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetWorkflowAccessToRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetWorkflowAccessToRepositoryResponse, error)

	// ActionsgetAllowedActionsRepository request
	ActionsgetAllowedActionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetAllowedActionsRepositoryResponse, error)

	// ActionssetAllowedActionsRepository request with any body
	ActionssetAllowedActionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsRepositoryResponse, error)

	ActionssetAllowedActionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetAllowedActionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsRepositoryResponse, error)

	// ActionsgetGithubActionsDefaultWorkflowPermissionsRepository request
	ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error)

	// ActionssetGithubActionsDefaultWorkflowPermissionsRepository request with any body
	ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error)

	ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error)

	// ActionslistSelfHostedRunnersForRepo request
	ActionslistSelfHostedRunnersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistSelfHostedRunnersForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersForRepoResponse, error)

	// ActionslistRunnerApplicationsForRepo request
	ActionslistRunnerApplicationsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionslistRunnerApplicationsForRepoResponse, error)

	// ActionscreateRegistrationTokenForRepo request
	ActionscreateRegistrationTokenForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionscreateRegistrationTokenForRepoResponse, error)

	// ActionscreateRemoveTokenForRepo request
	ActionscreateRemoveTokenForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionscreateRemoveTokenForRepoResponse, error)

	// ActionsdeleteSelfHostedRunnerFromRepo request
	ActionsdeleteSelfHostedRunnerFromRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerFromRepoResponse, error)

	// ActionsgetSelfHostedRunnerForRepo request
	ActionsgetSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerForRepoResponse, error)

	// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo request
	ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse, error)

	// ActionslistLabelsForSelfHostedRunnerForRepo request
	ActionslistLabelsForSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionslistLabelsForSelfHostedRunnerForRepoResponse, error)

	// ActionsaddCustomLabelsToSelfHostedRunnerForRepo request with any body
	ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse, error)

	ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse, error)

	// ActionssetCustomLabelsForSelfHostedRunnerForRepo request with any body
	ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse, error)

	ActionssetCustomLabelsForSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse, error)

	// ActionsremoveCustomLabelFromSelfHostedRunnerForRepo request
	ActionsremoveCustomLabelFromSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse, error)

	// ActionslistWorkflowRunsForRepo request
	ActionslistWorkflowRunsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistWorkflowRunsForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunsForRepoResponse, error)

	// ActionsdeleteWorkflowRun request
	ActionsdeleteWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdeleteWorkflowRunResponse, error)

	// ActionsgetWorkflowRun request
	ActionsgetWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionsgetWorkflowRunParams, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunResponse, error)

	// ActionsgetReviewsForRun request
	ActionsgetReviewsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetReviewsForRunResponse, error)

	// ActionsapproveWorkflowRun request
	ActionsapproveWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsapproveWorkflowRunResponse, error)

	// ActionslistWorkflowRunArtifacts request
	ActionslistWorkflowRunArtifactsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistWorkflowRunArtifactsParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunArtifactsResponse, error)

	// ActionsgetWorkflowRunAttempt request
	ActionsgetWorkflowRunAttemptWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionsgetWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunAttemptResponse, error)

	// ActionslistJobsForWorkflowRunAttempt request
	ActionslistJobsForWorkflowRunAttemptWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionslistJobsForWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*ActionslistJobsForWorkflowRunAttemptResponse, error)

	// ActionsdownloadWorkflowRunAttemptLogs request
	ActionsdownloadWorkflowRunAttemptLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, reqEditors ...RequestEditorFn) (*ActionsdownloadWorkflowRunAttemptLogsResponse, error)

	// ActionscancelWorkflowRun request
	ActionscancelWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionscancelWorkflowRunResponse, error)

	// ActionslistJobsForWorkflowRun request
	ActionslistJobsForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistJobsForWorkflowRunParams, reqEditors ...RequestEditorFn) (*ActionslistJobsForWorkflowRunResponse, error)

	// ActionsdeleteWorkflowRunLogs request
	ActionsdeleteWorkflowRunLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdeleteWorkflowRunLogsResponse, error)

	// ActionsdownloadWorkflowRunLogs request
	ActionsdownloadWorkflowRunLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdownloadWorkflowRunLogsResponse, error)

	// ActionsgetPendingDeploymentsForRun request
	ActionsgetPendingDeploymentsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetPendingDeploymentsForRunResponse, error)

	// ActionsreviewPendingDeploymentsForRun request with any body
	ActionsreviewPendingDeploymentsForRunWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreviewPendingDeploymentsForRunResponse, error)

	ActionsreviewPendingDeploymentsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreviewPendingDeploymentsForRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreviewPendingDeploymentsForRunResponse, error)

	// ActionsreRunWorkflow request with any body
	ActionsreRunWorkflowWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowResponse, error)

	ActionsreRunWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowResponse, error)

	// ActionsreRunWorkflowFailedJobs request with any body
	ActionsreRunWorkflowFailedJobsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowFailedJobsResponse, error)

	ActionsreRunWorkflowFailedJobsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowFailedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowFailedJobsResponse, error)

	// ActionsgetWorkflowRunUsage request
	ActionsgetWorkflowRunUsageWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunUsageResponse, error)

	// ActionslistRepoSecrets request
	ActionslistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistRepoSecretsResponse, error)

	// ActionsgetRepoPublicKey request
	ActionsgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetRepoPublicKeyResponse, error)

	// ActionsdeleteRepoSecret request
	ActionsdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteRepoSecretResponse, error)

	// ActionsgetRepoSecret request
	ActionsgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetRepoSecretResponse, error)

	// ActionscreateOrUpdateRepoSecret request with any body
	ActionscreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateRepoSecretResponse, error)

	ActionscreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body ActionscreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateRepoSecretResponse, error)

	// ActionslistRepoWorkflows request
	ActionslistRepoWorkflowsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoWorkflowsParams, reqEditors ...RequestEditorFn) (*ActionslistRepoWorkflowsResponse, error)

	// ActionsgetWorkflow request
	ActionsgetWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowResponse, error)

	// ActionsdisableWorkflow request
	ActionsdisableWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsdisableWorkflowResponse, error)

	// ActionscreateWorkflowDispatch request with any body
	ActionscreateWorkflowDispatchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateWorkflowDispatchResponse, error)

	ActionscreateWorkflowDispatchWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, body ActionscreateWorkflowDispatchJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateWorkflowDispatchResponse, error)

	// ActionsenableWorkflow request
	ActionsenableWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsenableWorkflowResponse, error)

	// ActionslistWorkflowRuns request
	ActionslistWorkflowRunsWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, params *ActionslistWorkflowRunsParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunsResponse, error)

	// ActionsgetWorkflowUsage request
	ActionsgetWorkflowUsageWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowUsageResponse, error)

	// IssueslistAssignees request
	IssueslistAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistAssigneesParams, reqEditors ...RequestEditorFn) (*IssueslistAssigneesResponse, error)

	// IssuescheckUserCanBeAssigned request
	IssuescheckUserCanBeAssignedWithResponse(ctx context.Context, owner Owner, repo Repo, assignee string, reqEditors ...RequestEditorFn) (*IssuescheckUserCanBeAssignedResponse, error)

	// ReposlistAutolinks request
	ReposlistAutolinksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistAutolinksParams, reqEditors ...RequestEditorFn) (*ReposlistAutolinksResponse, error)

	// ReposcreateAutolink request with any body
	ReposcreateAutolinkWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateAutolinkResponse, error)

	ReposcreateAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateAutolinkJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateAutolinkResponse, error)

	// ReposdeleteAutolink request
	ReposdeleteAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*ReposdeleteAutolinkResponse, error)

	// ReposgetAutolink request
	ReposgetAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*ReposgetAutolinkResponse, error)

	// ReposdisableAutomatedSecurityFixes request
	ReposdisableAutomatedSecurityFixesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableAutomatedSecurityFixesResponse, error)

	// ReposenableAutomatedSecurityFixes request
	ReposenableAutomatedSecurityFixesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableAutomatedSecurityFixesResponse, error)

	// ReposlistBranches request
	ReposlistBranchesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistBranchesParams, reqEditors ...RequestEditorFn) (*ReposlistBranchesResponse, error)

	// ReposgetBranch request
	ReposgetBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetBranchResponse, error)

	// ReposdeleteBranchProtection request
	ReposdeleteBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteBranchProtectionResponse, error)

	// ReposgetBranchProtection request
	ReposgetBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetBranchProtectionResponse, error)

	// ReposupdateBranchProtection request with any body
	ReposupdateBranchProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateBranchProtectionResponse, error)

	ReposupdateBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateBranchProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateBranchProtectionResponse, error)

	// ReposdeleteAdminBranchProtection request
	ReposdeleteAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteAdminBranchProtectionResponse, error)

	// ReposgetAdminBranchProtection request
	ReposgetAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAdminBranchProtectionResponse, error)

	// RepossetAdminBranchProtection request
	RepossetAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*RepossetAdminBranchProtectionResponse, error)

	// ReposdeletePullRequestReviewProtection request
	ReposdeletePullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeletePullRequestReviewProtectionResponse, error)

	// ReposgetPullRequestReviewProtection request
	ReposgetPullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetPullRequestReviewProtectionResponse, error)

	// ReposupdatePullRequestReviewProtection request with any body
	ReposupdatePullRequestReviewProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdatePullRequestReviewProtectionResponse, error)

	ReposupdatePullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdatePullRequestReviewProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdatePullRequestReviewProtectionResponse, error)

	// ReposdeleteCommitSignatureProtection request
	ReposdeleteCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteCommitSignatureProtectionResponse, error)

	// ReposgetCommitSignatureProtection request
	ReposgetCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetCommitSignatureProtectionResponse, error)

	// ReposcreateCommitSignatureProtection request
	ReposcreateCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposcreateCommitSignatureProtectionResponse, error)

	// ReposremoveStatusCheckProtection request
	ReposremoveStatusCheckProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckProtectionResponse, error)

	// ReposgetStatusChecksProtection request
	ReposgetStatusChecksProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetStatusChecksProtectionResponse, error)

	// ReposupdateStatusCheckProtection request with any body
	ReposupdateStatusCheckProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateStatusCheckProtectionResponse, error)

	ReposupdateStatusCheckProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateStatusCheckProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateStatusCheckProtectionResponse, error)

	// ReposremoveStatusCheckContexts request with any body
	ReposremoveStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckContextsResponse, error)

	ReposremoveStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckContextsResponse, error)

	// ReposgetAllStatusCheckContexts request
	ReposgetAllStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAllStatusCheckContextsResponse, error)

	// ReposaddStatusCheckContexts request with any body
	ReposaddStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddStatusCheckContextsResponse, error)

	ReposaddStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddStatusCheckContextsResponse, error)

	// RepossetStatusCheckContexts request with any body
	RepossetStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetStatusCheckContextsResponse, error)

	RepossetStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetStatusCheckContextsResponse, error)

	// ReposdeleteAccessRestrictions request
	ReposdeleteAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteAccessRestrictionsResponse, error)

	// ReposgetAccessRestrictions request
	ReposgetAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAccessRestrictionsResponse, error)

	// ReposremoveAppAccessRestrictions request with any body
	ReposremoveAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveAppAccessRestrictionsResponse, error)

	ReposremoveAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveAppAccessRestrictionsResponse, error)

	// ReposgetAppsWithAccessToProtectedBranch request
	ReposgetAppsWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAppsWithAccessToProtectedBranchResponse, error)

	// ReposaddAppAccessRestrictions request with any body
	ReposaddAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddAppAccessRestrictionsResponse, error)

	ReposaddAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddAppAccessRestrictionsResponse, error)

	// RepossetAppAccessRestrictions request with any body
	RepossetAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetAppAccessRestrictionsResponse, error)

	RepossetAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetAppAccessRestrictionsResponse, error)

	// ReposremoveTeamAccessRestrictions request with any body
	ReposremoveTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveTeamAccessRestrictionsResponse, error)

	ReposremoveTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveTeamAccessRestrictionsResponse, error)

	// ReposgetTeamsWithAccessToProtectedBranch request
	ReposgetTeamsWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetTeamsWithAccessToProtectedBranchResponse, error)

	// ReposaddTeamAccessRestrictions request with any body
	ReposaddTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddTeamAccessRestrictionsResponse, error)

	ReposaddTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddTeamAccessRestrictionsResponse, error)

	// RepossetTeamAccessRestrictions request with any body
	RepossetTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetTeamAccessRestrictionsResponse, error)

	RepossetTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetTeamAccessRestrictionsResponse, error)

	// ReposremoveUserAccessRestrictions request with any body
	ReposremoveUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveUserAccessRestrictionsResponse, error)

	ReposremoveUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveUserAccessRestrictionsResponse, error)

	// ReposgetUsersWithAccessToProtectedBranch request
	ReposgetUsersWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetUsersWithAccessToProtectedBranchResponse, error)

	// ReposaddUserAccessRestrictions request with any body
	ReposaddUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddUserAccessRestrictionsResponse, error)

	ReposaddUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddUserAccessRestrictionsResponse, error)

	// RepossetUserAccessRestrictions request with any body
	RepossetUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetUserAccessRestrictionsResponse, error)

	RepossetUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetUserAccessRestrictionsResponse, error)

	// ReposrenameBranch request with any body
	ReposrenameBranchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposrenameBranchResponse, error)

	ReposrenameBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposrenameBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposrenameBranchResponse, error)

	// Checkscreate request with any body
	CheckscreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckscreateResponse, error)

	CheckscreateWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckscreateResponse, error)

	// Checksget request
	ChecksgetWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*ChecksgetResponse, error)

	// Checksupdate request with any body
	ChecksupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChecksupdateResponse, error)

	ChecksupdateWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, body ChecksupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChecksupdateResponse, error)

	// CheckslistAnnotations request
	CheckslistAnnotationsWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, params *CheckslistAnnotationsParams, reqEditors ...RequestEditorFn) (*CheckslistAnnotationsResponse, error)

	// ChecksrerequestRun request
	ChecksrerequestRunWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*ChecksrerequestRunResponse, error)

	// CheckscreateSuite request with any body
	CheckscreateSuiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckscreateSuiteResponse, error)

	CheckscreateSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckscreateSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckscreateSuiteResponse, error)

	// CheckssetSuitesPreferences request with any body
	CheckssetSuitesPreferencesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckssetSuitesPreferencesResponse, error)

	CheckssetSuitesPreferencesWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckssetSuitesPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckssetSuitesPreferencesResponse, error)

	// ChecksgetSuite request
	ChecksgetSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*ChecksgetSuiteResponse, error)

	// CheckslistForSuite request
	CheckslistForSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, params *CheckslistForSuiteParams, reqEditors ...RequestEditorFn) (*CheckslistForSuiteResponse, error)

	// ChecksrerequestSuite request
	ChecksrerequestSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*ChecksrerequestSuiteResponse, error)

	// CodeScanninglistAlertsForRepo request
	CodeScanninglistAlertsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertsForRepoResponse, error)

	// CodeScanninggetAlert request
	CodeScanninggetAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*CodeScanninggetAlertResponse, error)

	// CodeScanningupdateAlert request with any body
	CodeScanningupdateAlertWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeScanningupdateAlertResponse, error)

	CodeScanningupdateAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body CodeScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeScanningupdateAlertResponse, error)

	// CodeScanninglistAlertInstances request
	CodeScanninglistAlertInstancesWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *CodeScanninglistAlertInstancesParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertInstancesResponse, error)

	// CodeScanninglistRecentAnalyses request
	CodeScanninglistRecentAnalysesWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistRecentAnalysesParams, reqEditors ...RequestEditorFn) (*CodeScanninglistRecentAnalysesResponse, error)

	// CodeScanningdeleteAnalysis request
	CodeScanningdeleteAnalysisWithResponse(ctx context.Context, owner Owner, repo Repo, analysisId int, params *CodeScanningdeleteAnalysisParams, reqEditors ...RequestEditorFn) (*CodeScanningdeleteAnalysisResponse, error)

	// CodeScanninggetAnalysis request
	CodeScanninggetAnalysisWithResponse(ctx context.Context, owner Owner, repo Repo, analysisId int, reqEditors ...RequestEditorFn) (*CodeScanninggetAnalysisResponse, error)

	// CodeScanninguploadSarif request with any body
	CodeScanninguploadSarifWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeScanninguploadSarifResponse, error)

	CodeScanninguploadSarifWithResponse(ctx context.Context, owner Owner, repo Repo, body CodeScanninguploadSarifJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeScanninguploadSarifResponse, error)

	// CodeScanninggetSarif request
	CodeScanninggetSarifWithResponse(ctx context.Context, owner Owner, repo Repo, sarifId string, reqEditors ...RequestEditorFn) (*CodeScanninggetSarifResponse, error)

	// ReposcodeownersErrors request
	ReposcodeownersErrorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposcodeownersErrorsParams, reqEditors ...RequestEditorFn) (*ReposcodeownersErrorsResponse, error)

	// CodespaceslistInRepositoryForAuthenticatedUser request
	CodespaceslistInRepositoryForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistInRepositoryForAuthenticatedUserResponse, error)

	// CodespacescreateWithRepoForAuthenticatedUser request with any body
	CodespacescreateWithRepoForAuthenticatedUserWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateWithRepoForAuthenticatedUserResponse, error)

	CodespacescreateWithRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, body CodespacescreateWithRepoForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateWithRepoForAuthenticatedUserResponse, error)

	// CodespaceslistDevcontainersInRepositoryForAuthenticatedUser request
	CodespaceslistDevcontainersInRepositoryForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse, error)

	// CodespacesrepoMachinesForAuthenticatedUser request
	CodespacesrepoMachinesForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespacesrepoMachinesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespacesrepoMachinesForAuthenticatedUserResponse, error)

	// CodespaceslistRepoSecrets request
	CodespaceslistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*CodespaceslistRepoSecretsResponse, error)

	// CodespacesgetRepoPublicKey request
	CodespacesgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*CodespacesgetRepoPublicKeyResponse, error)

	// CodespacesdeleteRepoSecret request
	CodespacesdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesdeleteRepoSecretResponse, error)

	// CodespacesgetRepoSecret request
	CodespacesgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesgetRepoSecretResponse, error)

	// CodespacescreateOrUpdateRepoSecret request with any body
	CodespacescreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateRepoSecretResponse, error)

	CodespacescreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body CodespacescreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateRepoSecretResponse, error)

	// ReposlistCollaborators request
	ReposlistCollaboratorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCollaboratorsParams, reqEditors ...RequestEditorFn) (*ReposlistCollaboratorsResponse, error)

	// ReposremoveCollaborator request
	ReposremoveCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposremoveCollaboratorResponse, error)

	// ReposcheckCollaborator request
	ReposcheckCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposcheckCollaboratorResponse, error)

	// ReposaddCollaborator request with any body
	ReposaddCollaboratorWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddCollaboratorResponse, error)

	ReposaddCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, body ReposaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddCollaboratorResponse, error)

	// ReposgetCollaboratorPermissionLevel request
	ReposgetCollaboratorPermissionLevelWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposgetCollaboratorPermissionLevelResponse, error)

	// ReposlistCommitCommentsForRepo request
	ReposlistCommitCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitCommentsForRepoParams, reqEditors ...RequestEditorFn) (*ReposlistCommitCommentsForRepoResponse, error)

	// ReposdeleteCommitComment request
	ReposdeleteCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*ReposdeleteCommitCommentResponse, error)

	// ReposgetCommitComment request
	ReposgetCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*ReposgetCommitCommentResponse, error)

	// ReposupdateCommitComment request with any body
	ReposupdateCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateCommitCommentResponse, error)

	ReposupdateCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReposupdateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateCommitCommentResponse, error)

	// ReactionslistForCommitComment request
	ReactionslistForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForCommitCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForCommitCommentResponse, error)

	// ReactionscreateForCommitComment request with any body
	ReactionscreateForCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForCommitCommentResponse, error)

	ReactionscreateForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForCommitCommentResponse, error)

	// ReactionsdeleteForCommitComment request
	ReactionsdeleteForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForCommitCommentResponse, error)

	// ReposlistCommits request
	ReposlistCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitsParams, reqEditors ...RequestEditorFn) (*ReposlistCommitsResponse, error)

	// ReposlistBranchesForHeadCommit request
	ReposlistBranchesForHeadCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*ReposlistBranchesForHeadCommitResponse, error)

	// ReposlistCommentsForCommit request
	ReposlistCommentsForCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistCommentsForCommitParams, reqEditors ...RequestEditorFn) (*ReposlistCommentsForCommitResponse, error)

	// ReposcreateCommitComment request with any body
	ReposcreateCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateCommitCommentResponse, error)

	ReposcreateCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, body ReposcreateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateCommitCommentResponse, error)

	// ReposlistPullRequestsAssociatedWithCommit request
	ReposlistPullRequestsAssociatedWithCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistPullRequestsAssociatedWithCommitParams, reqEditors ...RequestEditorFn) (*ReposlistPullRequestsAssociatedWithCommitResponse, error)

	// ReposgetCommit request
	ReposgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCommitParams, reqEditors ...RequestEditorFn) (*ReposgetCommitResponse, error)

	// CheckslistForRef request
	CheckslistForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistForRefParams, reqEditors ...RequestEditorFn) (*CheckslistForRefResponse, error)

	// CheckslistSuitesForRef request
	CheckslistSuitesForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistSuitesForRefParams, reqEditors ...RequestEditorFn) (*CheckslistSuitesForRefResponse, error)

	// ReposgetCombinedStatusForRef request
	ReposgetCombinedStatusForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCombinedStatusForRefParams, reqEditors ...RequestEditorFn) (*ReposgetCombinedStatusForRefResponse, error)

	// ReposlistCommitStatusesForRef request
	ReposlistCommitStatusesForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposlistCommitStatusesForRefParams, reqEditors ...RequestEditorFn) (*ReposlistCommitStatusesForRefResponse, error)

	// ReposgetCommunityProfileMetrics request
	ReposgetCommunityProfileMetricsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCommunityProfileMetricsResponse, error)

	// ReposcompareCommits request
	ReposcompareCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, basehead string, params *ReposcompareCommitsParams, reqEditors ...RequestEditorFn) (*ReposcompareCommitsResponse, error)

	// ReposdeleteFile request with any body
	ReposdeleteFileWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposdeleteFileResponse, error)

	ReposdeleteFileWithResponse(ctx context.Context, owner Owner, repo Repo, path string, body ReposdeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposdeleteFileResponse, error)

	// ReposgetContent request
	ReposgetContentWithResponse(ctx context.Context, owner Owner, repo Repo, path string, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*ReposgetContentResponse, error)

	// ReposcreateOrUpdateFileContents request with any body
	ReposcreateOrUpdateFileContentsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error)

	ReposcreateOrUpdateFileContentsWithResponse(ctx context.Context, owner Owner, repo Repo, path string, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error)

	// ReposlistContributors request
	ReposlistContributorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistContributorsParams, reqEditors ...RequestEditorFn) (*ReposlistContributorsResponse, error)

	// DependabotlistRepoSecrets request
	DependabotlistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *DependabotlistRepoSecretsParams, reqEditors ...RequestEditorFn) (*DependabotlistRepoSecretsResponse, error)

	// DependabotgetRepoPublicKey request
	DependabotgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*DependabotgetRepoPublicKeyResponse, error)

	// DependabotdeleteRepoSecret request
	DependabotdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotdeleteRepoSecretResponse, error)

	// DependabotgetRepoSecret request
	DependabotgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotgetRepoSecretResponse, error)

	// DependabotcreateOrUpdateRepoSecret request with any body
	DependabotcreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateRepoSecretResponse, error)

	DependabotcreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body DependabotcreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateRepoSecretResponse, error)

	// DependencyGraphdiffRange request
	DependencyGraphdiffRangeWithResponse(ctx context.Context, owner Owner, repo Repo, basehead string, params *DependencyGraphdiffRangeParams, reqEditors ...RequestEditorFn) (*DependencyGraphdiffRangeResponse, error)

	// ReposlistDeployments request
	ReposlistDeploymentsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeploymentsParams, reqEditors ...RequestEditorFn) (*ReposlistDeploymentsResponse, error)

	// ReposcreateDeployment request with any body
	ReposcreateDeploymentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentResponse, error)

	ReposcreateDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentResponse, error)

	// ReposdeleteDeployment request
	ReposdeleteDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*ReposdeleteDeploymentResponse, error)

	// ReposgetDeployment request
	ReposgetDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*ReposgetDeploymentResponse, error)

	// ReposlistDeploymentStatuses request
	ReposlistDeploymentStatusesWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, params *ReposlistDeploymentStatusesParams, reqEditors ...RequestEditorFn) (*ReposlistDeploymentStatusesResponse, error)

	// ReposcreateDeploymentStatus request with any body
	ReposcreateDeploymentStatusWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentStatusResponse, error)

	ReposcreateDeploymentStatusWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, body ReposcreateDeploymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentStatusResponse, error)

	// ReposgetDeploymentStatus request
	ReposgetDeploymentStatusWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, statusId int, reqEditors ...RequestEditorFn) (*ReposgetDeploymentStatusResponse, error)

	// ReposcreateDispatchEvent request with any body
	ReposcreateDispatchEventWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDispatchEventResponse, error)

	ReposcreateDispatchEventWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDispatchEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDispatchEventResponse, error)

	// ReposgetAllEnvironments request
	ReposgetAllEnvironmentsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllEnvironmentsParams, reqEditors ...RequestEditorFn) (*ReposgetAllEnvironmentsResponse, error)

	// ReposdeleteAnEnvironment request
	ReposdeleteAnEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ReposdeleteAnEnvironmentResponse, error)

	// ReposgetEnvironment request
	ReposgetEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ReposgetEnvironmentResponse, error)

	// ReposcreateOrUpdateEnvironment request with any body
	ReposcreateOrUpdateEnvironmentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateEnvironmentResponse, error)

	ReposcreateOrUpdateEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, body ReposcreateOrUpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateEnvironmentResponse, error)

	// ActivitylistRepoEvents request
	ActivitylistRepoEventsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistRepoEventsResponse, error)

	// ReposlistForks request
	ReposlistForksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistForksParams, reqEditors ...RequestEditorFn) (*ReposlistForksResponse, error)

	// ReposcreateFork request with any body
	ReposcreateForkWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateForkResponse, error)

	ReposcreateForkWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateForkJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateForkResponse, error)

	// GitcreateBlob request with any body
	GitcreateBlobWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateBlobResponse, error)

	GitcreateBlobWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateBlobResponse, error)

	// GitgetBlob request
	GitgetBlobWithResponse(ctx context.Context, owner Owner, repo Repo, fileSha string, reqEditors ...RequestEditorFn) (*GitgetBlobResponse, error)

	// GitcreateCommit request with any body
	GitcreateCommitWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateCommitResponse, error)

	GitcreateCommitWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateCommitResponse, error)

	// GitgetCommit request
	GitgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*GitgetCommitResponse, error)

	// GitlistMatchingRefs request
	GitlistMatchingRefsWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *GitlistMatchingRefsParams, reqEditors ...RequestEditorFn) (*GitlistMatchingRefsResponse, error)

	// GitgetRef request
	GitgetRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*GitgetRefResponse, error)

	// GitcreateRef request with any body
	GitcreateRefWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateRefResponse, error)

	GitcreateRefWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateRefResponse, error)

	// GitdeleteRef request
	GitdeleteRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*GitdeleteRefResponse, error)

	// GitupdateRef request with any body
	GitupdateRefWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitupdateRefResponse, error)

	GitupdateRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, body GitupdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*GitupdateRefResponse, error)

	// GitcreateTag request with any body
	GitcreateTagWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateTagResponse, error)

	GitcreateTagWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateTagResponse, error)

	// GitgetTag request
	GitgetTagWithResponse(ctx context.Context, owner Owner, repo Repo, tagSha string, reqEditors ...RequestEditorFn) (*GitgetTagResponse, error)

	// GitcreateTree request with any body
	GitcreateTreeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateTreeResponse, error)

	GitcreateTreeWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateTreeResponse, error)

	// GitgetTree request
	GitgetTreeWithResponse(ctx context.Context, owner Owner, repo Repo, treeSha string, params *GitgetTreeParams, reqEditors ...RequestEditorFn) (*GitgetTreeResponse, error)

	// ReposlistWebhooks request
	ReposlistWebhooksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistWebhooksParams, reqEditors ...RequestEditorFn) (*ReposlistWebhooksResponse, error)

	// ReposcreateWebhook request with any body
	ReposcreateWebhookWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateWebhookResponse, error)

	ReposcreateWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateWebhookResponse, error)

	// ReposdeleteWebhook request
	ReposdeleteWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposdeleteWebhookResponse, error)

	// ReposgetWebhook request
	ReposgetWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposgetWebhookResponse, error)

	// ReposupdateWebhook request with any body
	ReposupdateWebhookWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateWebhookResponse, error)

	ReposupdateWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateWebhookResponse, error)

	// ReposgetWebhookConfigForRepo request
	ReposgetWebhookConfigForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposgetWebhookConfigForRepoResponse, error)

	// ReposupdateWebhookConfigForRepo request with any body
	ReposupdateWebhookConfigForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateWebhookConfigForRepoResponse, error)

	ReposupdateWebhookConfigForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookConfigForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateWebhookConfigForRepoResponse, error)

	// ReposlistWebhookDeliveries request
	ReposlistWebhookDeliveriesWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, params *ReposlistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*ReposlistWebhookDeliveriesResponse, error)

	// ReposgetWebhookDelivery request
	ReposgetWebhookDeliveryWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*ReposgetWebhookDeliveryResponse, error)

	// ReposredeliverWebhookDelivery request
	ReposredeliverWebhookDeliveryWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*ReposredeliverWebhookDeliveryResponse, error)

	// RepospingWebhook request
	RepospingWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*RepospingWebhookResponse, error)

	// RepostestPushWebhook request
	RepostestPushWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*RepostestPushWebhookResponse, error)

	// MigrationscancelImport request
	MigrationscancelImportWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationscancelImportResponse, error)

	// MigrationsgetImportStatus request
	MigrationsgetImportStatusWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationsgetImportStatusResponse, error)

	// MigrationsupdateImport request with any body
	MigrationsupdateImportWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsupdateImportResponse, error)

	MigrationsupdateImportWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationsupdateImportJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsupdateImportResponse, error)

	// MigrationsstartImport request with any body
	MigrationsstartImportWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartImportResponse, error)

	MigrationsstartImportWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationsstartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartImportResponse, error)

	// MigrationsgetCommitAuthors request
	MigrationsgetCommitAuthorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *MigrationsgetCommitAuthorsParams, reqEditors ...RequestEditorFn) (*MigrationsgetCommitAuthorsResponse, error)

	// MigrationsmapCommitAuthor request with any body
	MigrationsmapCommitAuthorWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, authorId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsmapCommitAuthorResponse, error)

	MigrationsmapCommitAuthorWithResponse(ctx context.Context, owner Owner, repo Repo, authorId int, body MigrationsmapCommitAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsmapCommitAuthorResponse, error)

	// MigrationsgetLargeFiles request
	MigrationsgetLargeFilesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationsgetLargeFilesResponse, error)

	// MigrationssetLfsPreference request with any body
	MigrationssetLfsPreferenceWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationssetLfsPreferenceResponse, error)

	MigrationssetLfsPreferenceWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationssetLfsPreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationssetLfsPreferenceResponse, error)

	// AppsgetRepoInstallation request
	AppsgetRepoInstallationWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*AppsgetRepoInstallationResponse, error)

	// InteractionsremoveRestrictionsForRepo request
	InteractionsremoveRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForRepoResponse, error)

	// InteractionsgetRestrictionsForRepo request
	InteractionsgetRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForRepoResponse, error)

	// InteractionssetRestrictionsForRepo request with any body
	InteractionssetRestrictionsForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForRepoResponse, error)

	InteractionssetRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, body InteractionssetRestrictionsForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForRepoResponse, error)

	// ReposlistInvitations request
	ReposlistInvitationsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistInvitationsParams, reqEditors ...RequestEditorFn) (*ReposlistInvitationsResponse, error)

	// ReposdeleteInvitation request
	ReposdeleteInvitationWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposdeleteInvitationResponse, error)

	// ReposupdateInvitation request with any body
	ReposupdateInvitationWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateInvitationResponse, error)

	ReposupdateInvitationWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, body ReposupdateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateInvitationResponse, error)

	// IssueslistForRepo request
	IssueslistForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistForRepoResponse, error)

	// Issuescreate request with any body
	IssuescreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateResponse, error)

	IssuescreateWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateResponse, error)

	// IssueslistCommentsForRepo request
	IssueslistCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistCommentsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistCommentsForRepoResponse, error)

	// IssuesdeleteComment request
	IssuesdeleteCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*IssuesdeleteCommentResponse, error)

	// IssuesgetComment request
	IssuesgetCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*IssuesgetCommentResponse, error)

	// IssuesupdateComment request with any body
	IssuesupdateCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateCommentResponse, error)

	IssuesupdateCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body IssuesupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateCommentResponse, error)

	// ReactionslistForIssueComment request
	ReactionslistForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForIssueCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForIssueCommentResponse, error)

	// ReactionscreateForIssueComment request with any body
	ReactionscreateForIssueCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueCommentResponse, error)

	ReactionscreateForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForIssueCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueCommentResponse, error)

	// ReactionsdeleteForIssueComment request
	ReactionsdeleteForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForIssueCommentResponse, error)

	// IssueslistEventsForRepo request
	IssueslistEventsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistEventsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistEventsForRepoResponse, error)

	// IssuesgetEvent request
	IssuesgetEventWithResponse(ctx context.Context, owner Owner, repo Repo, eventId int, reqEditors ...RequestEditorFn) (*IssuesgetEventResponse, error)

	// Issuesget request
	IssuesgetWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesgetResponse, error)

	// Issuesupdate request with any body
	IssuesupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateResponse, error)

	IssuesupdateWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateResponse, error)

	// IssuesremoveAssignees request with any body
	IssuesremoveAssigneesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesremoveAssigneesResponse, error)

	IssuesremoveAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesremoveAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesremoveAssigneesResponse, error)

	// IssuesaddAssignees request with any body
	IssuesaddAssigneesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesaddAssigneesResponse, error)

	IssuesaddAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesaddAssigneesResponse, error)

	// IssueslistComments request
	IssueslistCommentsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistCommentsParams, reqEditors ...RequestEditorFn) (*IssueslistCommentsResponse, error)

	// IssuescreateComment request with any body
	IssuescreateCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateCommentResponse, error)

	IssuescreateCommentWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuescreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateCommentResponse, error)

	// IssueslistEvents request
	IssueslistEventsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsParams, reqEditors ...RequestEditorFn) (*IssueslistEventsResponse, error)

	// IssuesremoveAllLabels request
	IssuesremoveAllLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesremoveAllLabelsResponse, error)

	// IssueslistLabelsOnIssue request
	IssueslistLabelsOnIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistLabelsOnIssueParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsOnIssueResponse, error)

	// IssuesaddLabels request with any body
	IssuesaddLabelsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesaddLabelsResponse, error)

	IssuesaddLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesaddLabelsResponse, error)

	// IssuessetLabels request with any body
	IssuessetLabelsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuessetLabelsResponse, error)

	IssuessetLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuessetLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuessetLabelsResponse, error)

	// IssuesremoveLabel request
	IssuesremoveLabelWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, name string, reqEditors ...RequestEditorFn) (*IssuesremoveLabelResponse, error)

	// Issuesunlock request
	IssuesunlockWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesunlockResponse, error)

	// Issueslock request with any body
	IssueslockWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueslockResponse, error)

	IssueslockWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssueslockJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueslockResponse, error)

	// ReactionslistForIssue request
	ReactionslistForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *ReactionslistForIssueParams, reqEditors ...RequestEditorFn) (*ReactionslistForIssueResponse, error)

	// ReactionscreateForIssue request with any body
	ReactionscreateForIssueWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueResponse, error)

	ReactionscreateForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body ReactionscreateForIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueResponse, error)

	// ReactionsdeleteForIssue request
	ReactionsdeleteForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForIssueResponse, error)

	// IssueslistEventsForTimeline request
	IssueslistEventsForTimelineWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsForTimelineParams, reqEditors ...RequestEditorFn) (*IssueslistEventsForTimelineResponse, error)

	// ReposlistDeployKeys request
	ReposlistDeployKeysWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeployKeysParams, reqEditors ...RequestEditorFn) (*ReposlistDeployKeysResponse, error)

	// ReposcreateDeployKey request with any body
	ReposcreateDeployKeyWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeployKeyResponse, error)

	ReposcreateDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeployKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeployKeyResponse, error)

	// ReposdeleteDeployKey request
	ReposdeleteDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*ReposdeleteDeployKeyResponse, error)

	// ReposgetDeployKey request
	ReposgetDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*ReposgetDeployKeyResponse, error)

	// IssueslistLabelsForRepo request
	IssueslistLabelsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistLabelsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsForRepoResponse, error)

	// IssuescreateLabel request with any body
	IssuescreateLabelWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateLabelResponse, error)

	IssuescreateLabelWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateLabelResponse, error)

	// IssuesdeleteLabel request
	IssuesdeleteLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*IssuesdeleteLabelResponse, error)

	// IssuesgetLabel request
	IssuesgetLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*IssuesgetLabelResponse, error)

	// IssuesupdateLabel request with any body
	IssuesupdateLabelWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateLabelResponse, error)

	IssuesupdateLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, body IssuesupdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateLabelResponse, error)

	// ReposlistLanguages request
	ReposlistLanguagesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposlistLanguagesResponse, error)

	// ReposdisableLfsForRepo request
	ReposdisableLfsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableLfsForRepoResponse, error)

	// ReposenableLfsForRepo request
	ReposenableLfsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableLfsForRepoResponse, error)

	// LicensesgetForRepo request
	LicensesgetForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*LicensesgetForRepoResponse, error)

	// ReposmergeUpstream request with any body
	ReposmergeUpstreamWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposmergeUpstreamResponse, error)

	ReposmergeUpstreamWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposmergeUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposmergeUpstreamResponse, error)

	// Reposmerge request with any body
	ReposmergeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposmergeResponse, error)

	ReposmergeWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposmergeResponse, error)

	// IssueslistMilestones request
	IssueslistMilestonesWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistMilestonesParams, reqEditors ...RequestEditorFn) (*IssueslistMilestonesResponse, error)

	// IssuescreateMilestone request with any body
	IssuescreateMilestoneWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateMilestoneResponse, error)

	IssuescreateMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateMilestoneResponse, error)

	// IssuesdeleteMilestone request
	IssuesdeleteMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*IssuesdeleteMilestoneResponse, error)

	// IssuesgetMilestone request
	IssuesgetMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*IssuesgetMilestoneResponse, error)

	// IssuesupdateMilestone request with any body
	IssuesupdateMilestoneWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateMilestoneResponse, error)

	IssuesupdateMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, body IssuesupdateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateMilestoneResponse, error)

	// IssueslistLabelsForMilestone request
	IssueslistLabelsForMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, params *IssueslistLabelsForMilestoneParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsForMilestoneResponse, error)

	// ActivitylistRepoNotificationsForAuthenticatedUser request
	ActivitylistRepoNotificationsForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistRepoNotificationsForAuthenticatedUserResponse, error)

	// ActivitymarkRepoNotificationsAsRead request with any body
	ActivitymarkRepoNotificationsAsReadWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitymarkRepoNotificationsAsReadResponse, error)

	ActivitymarkRepoNotificationsAsReadWithResponse(ctx context.Context, owner Owner, repo Repo, body ActivitymarkRepoNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitymarkRepoNotificationsAsReadResponse, error)

	// ReposdeletePagesSite request
	ReposdeletePagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdeletePagesSiteResponse, error)

	// ReposgetPages request
	ReposgetPagesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPagesResponse, error)

	// ReposcreatePagesSite request with any body
	ReposcreatePagesSiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreatePagesSiteResponse, error)

	ReposcreatePagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreatePagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreatePagesSiteResponse, error)

	// ReposupdateInformationAboutPagesSite request with any body
	ReposupdateInformationAboutPagesSiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateInformationAboutPagesSiteResponse, error)

	ReposupdateInformationAboutPagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposupdateInformationAboutPagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateInformationAboutPagesSiteResponse, error)

	// ReposlistPagesBuilds request
	ReposlistPagesBuildsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistPagesBuildsParams, reqEditors ...RequestEditorFn) (*ReposlistPagesBuildsResponse, error)

	// ReposrequestPagesBuild request
	ReposrequestPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposrequestPagesBuildResponse, error)

	// ReposgetLatestPagesBuild request
	ReposgetLatestPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetLatestPagesBuildResponse, error)

	// ReposgetPagesBuild request
	ReposgetPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, buildId int, reqEditors ...RequestEditorFn) (*ReposgetPagesBuildResponse, error)

	// ReposgetPagesHealthCheck request
	ReposgetPagesHealthCheckWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPagesHealthCheckResponse, error)

	// ProjectslistForRepo request
	ProjectslistForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ProjectslistForRepoParams, reqEditors ...RequestEditorFn) (*ProjectslistForRepoResponse, error)

	// ProjectscreateForRepo request with any body
	ProjectscreateForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForRepoResponse, error)

	ProjectscreateForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, body ProjectscreateForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForRepoResponse, error)

	// Pullslist request
	PullslistWithResponse(ctx context.Context, owner Owner, repo Repo, params *PullslistParams, reqEditors ...RequestEditorFn) (*PullslistResponse, error)

	// Pullscreate request with any body
	PullscreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateResponse, error)

	PullscreateWithResponse(ctx context.Context, owner Owner, repo Repo, body PullscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateResponse, error)

	// PullslistReviewCommentsForRepo request
	PullslistReviewCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *PullslistReviewCommentsForRepoParams, reqEditors ...RequestEditorFn) (*PullslistReviewCommentsForRepoResponse, error)

	// PullsdeleteReviewComment request
	PullsdeleteReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*PullsdeleteReviewCommentResponse, error)

	// PullsgetReviewComment request
	PullsgetReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*PullsgetReviewCommentResponse, error)

	// PullsupdateReviewComment request with any body
	PullsupdateReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateReviewCommentResponse, error)

	PullsupdateReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body PullsupdateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateReviewCommentResponse, error)

	// ReactionslistForPullRequestReviewComment request
	ReactionslistForPullRequestReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForPullRequestReviewCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForPullRequestReviewCommentResponse, error)

	// ReactionscreateForPullRequestReviewComment request with any body
	ReactionscreateForPullRequestReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForPullRequestReviewCommentResponse, error)

	ReactionscreateForPullRequestReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForPullRequestReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForPullRequestReviewCommentResponse, error)

	// ReactionsdeleteForPullRequestComment request
	ReactionsdeleteForPullRequestCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForPullRequestCommentResponse, error)

	// Pullsget request
	PullsgetWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*PullsgetResponse, error)

	// Pullsupdate request with any body
	PullsupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateResponse, error)

	PullsupdateWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateResponse, error)

	// CodespacescreateWithPrForAuthenticatedUser request with any body
	CodespacescreateWithPrForAuthenticatedUserWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateWithPrForAuthenticatedUserResponse, error)

	CodespacescreateWithPrForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body CodespacescreateWithPrForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateWithPrForAuthenticatedUserResponse, error)

	// PullslistReviewComments request
	PullslistReviewCommentsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewCommentsParams, reqEditors ...RequestEditorFn) (*PullslistReviewCommentsResponse, error)

	// PullscreateReviewComment request with any body
	PullscreateReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReviewCommentResponse, error)

	PullscreateReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReviewCommentResponse, error)

	// PullscreateReplyForReviewComment request with any body
	PullscreateReplyForReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReplyForReviewCommentResponse, error)

	PullscreateReplyForReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, body PullscreateReplyForReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReplyForReviewCommentResponse, error)

	// PullslistCommits request
	PullslistCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistCommitsParams, reqEditors ...RequestEditorFn) (*PullslistCommitsResponse, error)

	// PullslistFiles request
	PullslistFilesWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistFilesParams, reqEditors ...RequestEditorFn) (*PullslistFilesResponse, error)

	// PullscheckIfMerged request
	PullscheckIfMergedWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*PullscheckIfMergedResponse, error)

	// Pullsmerge request with any body
	PullsmergeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsmergeResponse, error)

	PullsmergeWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsmergeResponse, error)

	// PullsremoveRequestedReviewers request with any body
	PullsremoveRequestedReviewersWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsremoveRequestedReviewersResponse, error)

	PullsremoveRequestedReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsremoveRequestedReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsremoveRequestedReviewersResponse, error)

	// PullslistRequestedReviewers request
	PullslistRequestedReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistRequestedReviewersParams, reqEditors ...RequestEditorFn) (*PullslistRequestedReviewersResponse, error)

	// PullsrequestReviewers request with any body
	PullsrequestReviewersWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsrequestReviewersResponse, error)

	PullsrequestReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsrequestReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsrequestReviewersResponse, error)

	// PullslistReviews request
	PullslistReviewsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewsParams, reqEditors ...RequestEditorFn) (*PullslistReviewsResponse, error)

	// PullscreateReview request with any body
	PullscreateReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReviewResponse, error)

	PullscreateReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReviewResponse, error)

	// PullsdeletePendingReview request
	PullsdeletePendingReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*PullsdeletePendingReviewResponse, error)

	// PullsgetReview request
	PullsgetReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*PullsgetReviewResponse, error)

	// PullsupdateReview request with any body
	PullsupdateReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateReviewResponse, error)

	PullsupdateReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsupdateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateReviewResponse, error)

	// PullslistCommentsForReview request
	PullslistCommentsForReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, params *PullslistCommentsForReviewParams, reqEditors ...RequestEditorFn) (*PullslistCommentsForReviewResponse, error)

	// PullsdismissReview request with any body
	PullsdismissReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsdismissReviewResponse, error)

	PullsdismissReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsdismissReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsdismissReviewResponse, error)

	// PullssubmitReview request with any body
	PullssubmitReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullssubmitReviewResponse, error)

	PullssubmitReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullssubmitReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullssubmitReviewResponse, error)

	// PullsupdateBranch request with any body
	PullsupdateBranchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateBranchResponse, error)

	PullsupdateBranchWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateBranchResponse, error)

	// ReposgetReadme request
	ReposgetReadmeWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetReadmeParams, reqEditors ...RequestEditorFn) (*ReposgetReadmeResponse, error)

	// ReposgetReadmeInDirectory request
	ReposgetReadmeInDirectoryWithResponse(ctx context.Context, owner Owner, repo Repo, dir string, params *ReposgetReadmeInDirectoryParams, reqEditors ...RequestEditorFn) (*ReposgetReadmeInDirectoryResponse, error)

	// ReposlistReleases request
	ReposlistReleasesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistReleasesParams, reqEditors ...RequestEditorFn) (*ReposlistReleasesResponse, error)

	// ReposcreateRelease request with any body
	ReposcreateReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateReleaseResponse, error)

	ReposcreateReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateReleaseResponse, error)

	// ReposdeleteReleaseAsset request
	ReposdeleteReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*ReposdeleteReleaseAssetResponse, error)

	// ReposgetReleaseAsset request
	ReposgetReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*ReposgetReleaseAssetResponse, error)

	// ReposupdateReleaseAsset request with any body
	ReposupdateReleaseAssetWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateReleaseAssetResponse, error)

	ReposupdateReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, body ReposupdateReleaseAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateReleaseAssetResponse, error)

	// ReposgenerateReleaseNotes request with any body
	ReposgenerateReleaseNotesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposgenerateReleaseNotesResponse, error)

	ReposgenerateReleaseNotesWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposgenerateReleaseNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposgenerateReleaseNotesResponse, error)

	// ReposgetLatestRelease request
	ReposgetLatestReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetLatestReleaseResponse, error)

	// ReposgetReleaseByTag request
	ReposgetReleaseByTagWithResponse(ctx context.Context, owner Owner, repo Repo, tag string, reqEditors ...RequestEditorFn) (*ReposgetReleaseByTagResponse, error)

	// ReposdeleteRelease request
	ReposdeleteReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*ReposdeleteReleaseResponse, error)

	// ReposgetRelease request
	ReposgetReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*ReposgetReleaseResponse, error)

	// ReposupdateRelease request with any body
	ReposupdateReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateReleaseResponse, error)

	ReposupdateReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReposupdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateReleaseResponse, error)

	// ReposlistReleaseAssets request
	ReposlistReleaseAssetsWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposlistReleaseAssetsParams, reqEditors ...RequestEditorFn) (*ReposlistReleaseAssetsResponse, error)

	// ReposuploadReleaseAsset request with any body
	ReposuploadReleaseAssetWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposuploadReleaseAssetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposuploadReleaseAssetResponse, error)

	// ReactionslistForRelease request
	ReactionslistForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReactionslistForReleaseParams, reqEditors ...RequestEditorFn) (*ReactionslistForReleaseResponse, error)

	// ReactionscreateForRelease request with any body
	ReactionscreateForReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForReleaseResponse, error)

	ReactionscreateForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReactionscreateForReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForReleaseResponse, error)

	// ReactionsdeleteForRelease request
	ReactionsdeleteForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForReleaseResponse, error)

	// SecretScanninglistAlertsForRepo request
	SecretScanninglistAlertsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *SecretScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForRepoResponse, error)

	// SecretScanninggetAlert request
	SecretScanninggetAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*SecretScanninggetAlertResponse, error)

	// SecretScanningupdateAlert request with any body
	SecretScanningupdateAlertWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretScanningupdateAlertResponse, error)

	SecretScanningupdateAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body SecretScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretScanningupdateAlertResponse, error)

	// SecretScanninglistLocationsForAlert request
	SecretScanninglistLocationsForAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *SecretScanninglistLocationsForAlertParams, reqEditors ...RequestEditorFn) (*SecretScanninglistLocationsForAlertResponse, error)

	// ActivitylistStargazersForRepo request
	ActivitylistStargazersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistStargazersForRepoParams, reqEditors ...RequestEditorFn) (*ActivitylistStargazersForRepoResponse, error)

	// ReposgetCodeFrequencyStats request
	ReposgetCodeFrequencyStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCodeFrequencyStatsResponse, error)

	// ReposgetCommitActivityStats request
	ReposgetCommitActivityStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCommitActivityStatsResponse, error)

	// ReposgetContributorsStats request
	ReposgetContributorsStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetContributorsStatsResponse, error)

	// ReposgetParticipationStats request
	ReposgetParticipationStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetParticipationStatsResponse, error)

	// ReposgetPunchCardStats request
	ReposgetPunchCardStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPunchCardStatsResponse, error)

	// ReposcreateCommitStatus request with any body
	ReposcreateCommitStatusWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, sha string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateCommitStatusResponse, error)

	ReposcreateCommitStatusWithResponse(ctx context.Context, owner Owner, repo Repo, sha string, body ReposcreateCommitStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateCommitStatusResponse, error)

	// ActivitylistWatchersForRepo request
	ActivitylistWatchersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistWatchersForRepoParams, reqEditors ...RequestEditorFn) (*ActivitylistWatchersForRepoResponse, error)

	// ActivitydeleteRepoSubscription request
	ActivitydeleteRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitydeleteRepoSubscriptionResponse, error)

	// ActivitygetRepoSubscription request
	ActivitygetRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitygetRepoSubscriptionResponse, error)

	// ActivitysetRepoSubscription request with any body
	ActivitysetRepoSubscriptionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitysetRepoSubscriptionResponse, error)

	ActivitysetRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, body ActivitysetRepoSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitysetRepoSubscriptionResponse, error)

	// ReposlistTags request
	ReposlistTagsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistTagsParams, reqEditors ...RequestEditorFn) (*ReposlistTagsResponse, error)

	// ReposlistTagProtection request
	ReposlistTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposlistTagProtectionResponse, error)

	// ReposcreateTagProtection request with any body
	ReposcreateTagProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateTagProtectionResponse, error)

	ReposcreateTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateTagProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateTagProtectionResponse, error)

	// ReposdeleteTagProtection request
	ReposdeleteTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, tagProtectionId TagProtectionId, reqEditors ...RequestEditorFn) (*ReposdeleteTagProtectionResponse, error)

	// ReposdownloadTarballArchive request
	ReposdownloadTarballArchiveWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*ReposdownloadTarballArchiveResponse, error)

	// ReposlistTeams request
	ReposlistTeamsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistTeamsParams, reqEditors ...RequestEditorFn) (*ReposlistTeamsResponse, error)

	// ReposgetAllTopics request
	ReposgetAllTopicsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllTopicsParams, reqEditors ...RequestEditorFn) (*ReposgetAllTopicsResponse, error)

	// ReposreplaceAllTopics request with any body
	ReposreplaceAllTopicsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposreplaceAllTopicsResponse, error)

	ReposreplaceAllTopicsWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposreplaceAllTopicsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposreplaceAllTopicsResponse, error)

	// ReposgetClones request
	ReposgetClonesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetClonesParams, reqEditors ...RequestEditorFn) (*ReposgetClonesResponse, error)

	// ReposgetTopPaths request
	ReposgetTopPathsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetTopPathsResponse, error)

	// ReposgetTopReferrers request
	ReposgetTopReferrersWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetTopReferrersResponse, error)

	// ReposgetViews request
	ReposgetViewsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetViewsParams, reqEditors ...RequestEditorFn) (*ReposgetViewsResponse, error)

	// Repostransfer request with any body
	RepostransferWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepostransferResponse, error)

	RepostransferWithResponse(ctx context.Context, owner Owner, repo Repo, body RepostransferJSONRequestBody, reqEditors ...RequestEditorFn) (*RepostransferResponse, error)

	// ReposdisableVulnerabilityAlerts request
	ReposdisableVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableVulnerabilityAlertsResponse, error)

	// ReposcheckVulnerabilityAlerts request
	ReposcheckVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposcheckVulnerabilityAlertsResponse, error)

	// ReposenableVulnerabilityAlerts request
	ReposenableVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableVulnerabilityAlertsResponse, error)

	// ReposdownloadZipballArchive request
	ReposdownloadZipballArchiveWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*ReposdownloadZipballArchiveResponse, error)

	// ReposcreateUsingTemplate request with any body
	ReposcreateUsingTemplateWithBodyWithResponse(ctx context.Context, templateOwner string, templateRepo string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateUsingTemplateResponse, error)

	ReposcreateUsingTemplateWithResponse(ctx context.Context, templateOwner string, templateRepo string, body ReposcreateUsingTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateUsingTemplateResponse, error)

	// ReposlistPublic request
	ReposlistPublicWithResponse(ctx context.Context, params *ReposlistPublicParams, reqEditors ...RequestEditorFn) (*ReposlistPublicResponse, error)

	// ActionslistEnvironmentSecrets request
	ActionslistEnvironmentSecretsWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, params *ActionslistEnvironmentSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistEnvironmentSecretsResponse, error)

	// ActionsgetEnvironmentPublicKey request
	ActionsgetEnvironmentPublicKeyWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ActionsgetEnvironmentPublicKeyResponse, error)

	// ActionsdeleteEnvironmentSecret request
	ActionsdeleteEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteEnvironmentSecretResponse, error)

	// ActionsgetEnvironmentSecret request
	ActionsgetEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetEnvironmentSecretResponse, error)

	// ActionscreateOrUpdateEnvironmentSecret request with any body
	ActionscreateOrUpdateEnvironmentSecretWithBodyWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateEnvironmentSecretResponse, error)

	ActionscreateOrUpdateEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, body ActionscreateOrUpdateEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateEnvironmentSecretResponse, error)

	// EnterpriseAdminlistProvisionedGroupsEnterprise request
	EnterpriseAdminlistProvisionedGroupsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedGroupsEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistProvisionedGroupsEnterpriseResponse, error)

	// EnterpriseAdminprovisionAndInviteEnterpriseGroup request with any body
	EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse, error)

	EnterpriseAdminprovisionAndInviteEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse, error)

	// EnterpriseAdmindeleteScimGroupFromEnterprise request
	EnterpriseAdmindeleteScimGroupFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteScimGroupFromEnterpriseResponse, error)

	// EnterpriseAdmingetProvisioningInformationForEnterpriseGroup request
	EnterpriseAdmingetProvisioningInformationForEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, params *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse, error)

	// EnterpriseAdminupdateAttributeForEnterpriseGroup request with any body
	EnterpriseAdminupdateAttributeForEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseGroupResponse, error)

	EnterpriseAdminupdateAttributeForEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminupdateAttributeForEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseGroupResponse, error)

	// EnterpriseAdminsetInformationForProvisionedEnterpriseGroup request with any body
	EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse, error)

	EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminsetInformationForProvisionedEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse, error)

	// EnterpriseAdminlistProvisionedIdentitiesEnterprise request
	EnterpriseAdminlistProvisionedIdentitiesEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedIdentitiesEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse, error)

	// EnterpriseAdminprovisionAndInviteEnterpriseUser request with any body
	EnterpriseAdminprovisionAndInviteEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseUserResponse, error)

	EnterpriseAdminprovisionAndInviteEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseUserResponse, error)

	// EnterpriseAdmindeleteUserFromEnterprise request
	EnterpriseAdmindeleteUserFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteUserFromEnterpriseResponse, error)

	// EnterpriseAdmingetProvisioningInformationForEnterpriseUser request
	EnterpriseAdmingetProvisioningInformationForEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse, error)

	// EnterpriseAdminupdateAttributeForEnterpriseUser request with any body
	EnterpriseAdminupdateAttributeForEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseUserResponse, error)

	EnterpriseAdminupdateAttributeForEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminupdateAttributeForEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseUserResponse, error)

	// EnterpriseAdminsetInformationForProvisionedEnterpriseUser request with any body
	EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse, error)

	EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminsetInformationForProvisionedEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse, error)

	// ScimlistProvisionedIdentities request
	ScimlistProvisionedIdentitiesWithResponse(ctx context.Context, org Org, params *ScimlistProvisionedIdentitiesParams, reqEditors ...RequestEditorFn) (*ScimlistProvisionedIdentitiesResponse, error)

	// ScimprovisionAndInviteUser request with any body
	ScimprovisionAndInviteUserWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimprovisionAndInviteUserResponse, error)

	ScimprovisionAndInviteUserWithResponse(ctx context.Context, org Org, body ScimprovisionAndInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimprovisionAndInviteUserResponse, error)

	// ScimdeleteUserFromOrg request
	ScimdeleteUserFromOrgWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*ScimdeleteUserFromOrgResponse, error)

	// ScimgetProvisioningInformationForUser request
	ScimgetProvisioningInformationForUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*ScimgetProvisioningInformationForUserResponse, error)

	// ScimupdateAttributeForUser request with any body
	ScimupdateAttributeForUserWithBodyWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimupdateAttributeForUserResponse, error)

	ScimupdateAttributeForUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, body ScimupdateAttributeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimupdateAttributeForUserResponse, error)

	// ScimsetInformationForProvisionedUser request with any body
	ScimsetInformationForProvisionedUserWithBodyWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimsetInformationForProvisionedUserResponse, error)

	ScimsetInformationForProvisionedUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, body ScimsetInformationForProvisionedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimsetInformationForProvisionedUserResponse, error)

	// Searchcode request
	SearchcodeWithResponse(ctx context.Context, params *SearchcodeParams, reqEditors ...RequestEditorFn) (*SearchcodeResponse, error)

	// Searchcommits request
	SearchcommitsWithResponse(ctx context.Context, params *SearchcommitsParams, reqEditors ...RequestEditorFn) (*SearchcommitsResponse, error)

	// SearchissuesAndPullRequests request
	SearchissuesAndPullRequestsWithResponse(ctx context.Context, params *SearchissuesAndPullRequestsParams, reqEditors ...RequestEditorFn) (*SearchissuesAndPullRequestsResponse, error)

	// Searchlabels request
	SearchlabelsWithResponse(ctx context.Context, params *SearchlabelsParams, reqEditors ...RequestEditorFn) (*SearchlabelsResponse, error)

	// Searchrepos request
	SearchreposWithResponse(ctx context.Context, params *SearchreposParams, reqEditors ...RequestEditorFn) (*SearchreposResponse, error)

	// Searchtopics request
	SearchtopicsWithResponse(ctx context.Context, params *SearchtopicsParams, reqEditors ...RequestEditorFn) (*SearchtopicsResponse, error)

	// Searchusers request
	SearchusersWithResponse(ctx context.Context, params *SearchusersParams, reqEditors ...RequestEditorFn) (*SearchusersResponse, error)

	// TeamsdeleteLegacy request
	TeamsdeleteLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamsdeleteLegacyResponse, error)

	// TeamsgetLegacy request
	TeamsgetLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamsgetLegacyResponse, error)

	// TeamsupdateLegacy request with any body
	TeamsupdateLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateLegacyResponse, error)

	TeamsupdateLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamsupdateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateLegacyResponse, error)

	// TeamslistDiscussionsLegacy request
	TeamslistDiscussionsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistDiscussionsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionsLegacyResponse, error)

	// TeamscreateDiscussionLegacy request with any body
	TeamscreateDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionLegacyResponse, error)

	TeamscreateDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamscreateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionLegacyResponse, error)

	// TeamsdeleteDiscussionLegacy request
	TeamsdeleteDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionLegacyResponse, error)

	// TeamsgetDiscussionLegacy request
	TeamsgetDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionLegacyResponse, error)

	// TeamsupdateDiscussionLegacy request with any body
	TeamsupdateDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionLegacyResponse, error)

	TeamsupdateDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamsupdateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionLegacyResponse, error)

	// TeamslistDiscussionCommentsLegacy request
	TeamslistDiscussionCommentsLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionCommentsLegacyResponse, error)

	// TeamscreateDiscussionCommentLegacy request with any body
	TeamscreateDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentLegacyResponse, error)

	TeamscreateDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentLegacyResponse, error)

	// TeamsdeleteDiscussionCommentLegacy request
	TeamsdeleteDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionCommentLegacyResponse, error)

	// TeamsgetDiscussionCommentLegacy request
	TeamsgetDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionCommentLegacyResponse, error)

	// TeamsupdateDiscussionCommentLegacy request with any body
	TeamsupdateDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentLegacyResponse, error)

	TeamsupdateDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentLegacyResponse, error)

	// ReactionslistForTeamDiscussionCommentLegacy request
	ReactionslistForTeamDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentLegacyParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionCommentLegacyResponse, error)

	// ReactionscreateForTeamDiscussionCommentLegacy request with any body
	ReactionscreateForTeamDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentLegacyResponse, error)

	ReactionscreateForTeamDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentLegacyResponse, error)

	// ReactionslistForTeamDiscussionLegacy request
	ReactionslistForTeamDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionLegacyParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionLegacyResponse, error)

	// ReactionscreateForTeamDiscussionLegacy request with any body
	ReactionscreateForTeamDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionLegacyResponse, error)

	ReactionscreateForTeamDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionLegacyResponse, error)

	// TeamslistPendingInvitationsLegacy request
	TeamslistPendingInvitationsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistPendingInvitationsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistPendingInvitationsLegacyResponse, error)

	// TeamslistMembersLegacy request
	TeamslistMembersLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistMembersLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistMembersLegacyResponse, error)

	// TeamsremoveMemberLegacy request
	TeamsremoveMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMemberLegacyResponse, error)

	// TeamsgetMemberLegacy request
	TeamsgetMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMemberLegacyResponse, error)

	// TeamsaddMemberLegacy request
	TeamsaddMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsaddMemberLegacyResponse, error)

	// TeamsremoveMembershipForUserLegacy request
	TeamsremoveMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMembershipForUserLegacyResponse, error)

	// TeamsgetMembershipForUserLegacy request
	TeamsgetMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMembershipForUserLegacyResponse, error)

	// TeamsaddOrUpdateMembershipForUserLegacy request with any body
	TeamsaddOrUpdateMembershipForUserLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserLegacyResponse, error)

	TeamsaddOrUpdateMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, body TeamsaddOrUpdateMembershipForUserLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserLegacyResponse, error)

	// TeamslistProjectsLegacy request
	TeamslistProjectsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistProjectsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistProjectsLegacyResponse, error)

	// TeamsremoveProjectLegacy request
	TeamsremoveProjectLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamsremoveProjectLegacyResponse, error)

	// TeamscheckPermissionsForProjectLegacy request
	TeamscheckPermissionsForProjectLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForProjectLegacyResponse, error)

	// TeamsaddOrUpdateProjectPermissionsLegacy request with any body
	TeamsaddOrUpdateProjectPermissionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsLegacyResponse, error)

	TeamsaddOrUpdateProjectPermissionsLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsLegacyResponse, error)

	// TeamslistReposLegacy request
	TeamslistReposLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistReposLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistReposLegacyResponse, error)

	// TeamsremoveRepoLegacy request
	TeamsremoveRepoLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamsremoveRepoLegacyResponse, error)

	// TeamscheckPermissionsForRepoLegacy request
	TeamscheckPermissionsForRepoLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForRepoLegacyResponse, error)

	// TeamsaddOrUpdateRepoPermissionsLegacy request with any body
	TeamsaddOrUpdateRepoPermissionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsLegacyResponse, error)

	TeamsaddOrUpdateRepoPermissionsLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsLegacyResponse, error)

	// TeamslistIdpGroupsForLegacy request
	TeamslistIdpGroupsForLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsForLegacyResponse, error)

	// TeamscreateOrUpdateIdpGroupConnectionsLegacy request with any body
	TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse, error)

	TeamscreateOrUpdateIdpGroupConnectionsLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamscreateOrUpdateIdpGroupConnectionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse, error)

	// TeamslistChildLegacy request
	TeamslistChildLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistChildLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistChildLegacyResponse, error)

	// UsersgetAuthenticated request
	UsersgetAuthenticatedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersgetAuthenticatedResponse, error)

	// UsersupdateAuthenticated request with any body
	UsersupdateAuthenticatedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersupdateAuthenticatedResponse, error)

	UsersupdateAuthenticatedWithResponse(ctx context.Context, body UsersupdateAuthenticatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersupdateAuthenticatedResponse, error)

	// UserslistBlockedByAuthenticatedUser request
	UserslistBlockedByAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserslistBlockedByAuthenticatedUserResponse, error)

	// Usersunblock request
	UsersunblockWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersunblockResponse, error)

	// UserscheckBlocked request
	UserscheckBlockedWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UserscheckBlockedResponse, error)

	// Usersblock request
	UsersblockWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersblockResponse, error)

	// CodespaceslistForAuthenticatedUser request
	CodespaceslistForAuthenticatedUserWithResponse(ctx context.Context, params *CodespaceslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistForAuthenticatedUserResponse, error)

	// CodespacescreateForAuthenticatedUser request with any body
	CodespacescreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateForAuthenticatedUserResponse, error)

	CodespacescreateForAuthenticatedUserWithResponse(ctx context.Context, body CodespacescreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateForAuthenticatedUserResponse, error)

	// CodespaceslistSecretsForAuthenticatedUser request
	CodespaceslistSecretsForAuthenticatedUserWithResponse(ctx context.Context, params *CodespaceslistSecretsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistSecretsForAuthenticatedUserResponse, error)

	// CodespacesgetPublicKeyForAuthenticatedUser request
	CodespacesgetPublicKeyForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CodespacesgetPublicKeyForAuthenticatedUserResponse, error)

	// CodespacesdeleteSecretForAuthenticatedUser request
	CodespacesdeleteSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesdeleteSecretForAuthenticatedUserResponse, error)

	// CodespacesgetSecretForAuthenticatedUser request
	CodespacesgetSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesgetSecretForAuthenticatedUserResponse, error)

	// CodespacescreateOrUpdateSecretForAuthenticatedUser request with any body
	CodespacescreateOrUpdateSecretForAuthenticatedUserWithBodyWithResponse(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateSecretForAuthenticatedUserResponse, error)

	CodespacescreateOrUpdateSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, body CodespacescreateOrUpdateSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateSecretForAuthenticatedUserResponse, error)

	// CodespaceslistRepositoriesForSecretForAuthenticatedUser request
	CodespaceslistRepositoriesForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse, error)

	// CodespacessetRepositoriesForSecretForAuthenticatedUser request with any body
	CodespacessetRepositoriesForSecretForAuthenticatedUserWithBodyWithResponse(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacessetRepositoriesForSecretForAuthenticatedUserResponse, error)

	CodespacessetRepositoriesForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, body CodespacessetRepositoriesForSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacessetRepositoriesForSecretForAuthenticatedUserResponse, error)

	// CodespacesremoveRepositoryForSecretForAuthenticatedUser request
	CodespacesremoveRepositoryForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse, error)

	// CodespacesaddRepositoryForSecretForAuthenticatedUser request
	CodespacesaddRepositoryForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*CodespacesaddRepositoryForSecretForAuthenticatedUserResponse, error)

	// CodespacesdeleteForAuthenticatedUser request
	CodespacesdeleteForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesdeleteForAuthenticatedUserResponse, error)

	// CodespacesgetForAuthenticatedUser request
	CodespacesgetForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesgetForAuthenticatedUserResponse, error)

	// CodespacesupdateForAuthenticatedUser request with any body
	CodespacesupdateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, codespaceName CodespaceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacesupdateForAuthenticatedUserResponse, error)

	CodespacesupdateForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, body CodespacesupdateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacesupdateForAuthenticatedUserResponse, error)

	// CodespacesexportForAuthenticatedUser request
	CodespacesexportForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesexportForAuthenticatedUserResponse, error)

	// CodespacesgetExportDetailsForAuthenticatedUser request
	CodespacesgetExportDetailsForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, exportId ExportId, reqEditors ...RequestEditorFn) (*CodespacesgetExportDetailsForAuthenticatedUserResponse, error)

	// CodespacescodespaceMachinesForAuthenticatedUser request
	CodespacescodespaceMachinesForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacescodespaceMachinesForAuthenticatedUserResponse, error)

	// CodespacesstartForAuthenticatedUser request
	CodespacesstartForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesstartForAuthenticatedUserResponse, error)

	// CodespacesstopForAuthenticatedUser request
	CodespacesstopForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesstopForAuthenticatedUserResponse, error)

	// UserssetPrimaryEmailVisibilityForAuthenticatedUser request with any body
	UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse, error)

	UserssetPrimaryEmailVisibilityForAuthenticatedUserWithResponse(ctx context.Context, body UserssetPrimaryEmailVisibilityForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse, error)

	// UsersdeleteEmailForAuthenticatedUser request with any body
	UsersdeleteEmailForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersdeleteEmailForAuthenticatedUserResponse, error)

	UsersdeleteEmailForAuthenticatedUserWithResponse(ctx context.Context, body UsersdeleteEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersdeleteEmailForAuthenticatedUserResponse, error)

	// UserslistEmailsForAuthenticatedUser request
	UserslistEmailsForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistEmailsForAuthenticatedUserResponse, error)

	// UsersaddEmailForAuthenticatedUser request with any body
	UsersaddEmailForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersaddEmailForAuthenticatedUserResponse, error)

	UsersaddEmailForAuthenticatedUserWithResponse(ctx context.Context, body UsersaddEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersaddEmailForAuthenticatedUserResponse, error)

	// UserslistFollowersForAuthenticatedUser request
	UserslistFollowersForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistFollowersForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowersForAuthenticatedUserResponse, error)

	// UserslistFollowedByAuthenticatedUser request
	UserslistFollowedByAuthenticatedUserWithResponse(ctx context.Context, params *UserslistFollowedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowedByAuthenticatedUserResponse, error)

	// Usersunfollow request
	UsersunfollowWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersunfollowResponse, error)

	// UserscheckPersonIsFollowedByAuthenticated request
	UserscheckPersonIsFollowedByAuthenticatedWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UserscheckPersonIsFollowedByAuthenticatedResponse, error)

	// Usersfollow request
	UsersfollowWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersfollowResponse, error)

	// UserslistGpgKeysForAuthenticatedUser request
	UserslistGpgKeysForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistGpgKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistGpgKeysForAuthenticatedUserResponse, error)

	// UserscreateGpgKeyForAuthenticatedUser request with any body
	UserscreateGpgKeyForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserscreateGpgKeyForAuthenticatedUserResponse, error)

	UserscreateGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, body UserscreateGpgKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserscreateGpgKeyForAuthenticatedUserResponse, error)

	// UsersdeleteGpgKeyForAuthenticatedUser request
	UsersdeleteGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*UsersdeleteGpgKeyForAuthenticatedUserResponse, error)

	// UsersgetGpgKeyForAuthenticatedUser request
	UsersgetGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*UsersgetGpgKeyForAuthenticatedUserResponse, error)

	// AppslistInstallationsForAuthenticatedUser request
	AppslistInstallationsForAuthenticatedUserWithResponse(ctx context.Context, params *AppslistInstallationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistInstallationsForAuthenticatedUserResponse, error)

	// AppslistInstallationReposForAuthenticatedUser request
	AppslistInstallationReposForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, params *AppslistInstallationReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistInstallationReposForAuthenticatedUserResponse, error)

	// AppsremoveRepoFromInstallationForAuthenticatedUser request
	AppsremoveRepoFromInstallationForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*AppsremoveRepoFromInstallationForAuthenticatedUserResponse, error)

	// AppsaddRepoToInstallationForAuthenticatedUser request
	AppsaddRepoToInstallationForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*AppsaddRepoToInstallationForAuthenticatedUserResponse, error)

	// InteractionsremoveRestrictionsForAuthenticatedUser request
	InteractionsremoveRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForAuthenticatedUserResponse, error)

	// InteractionsgetRestrictionsForAuthenticatedUser request
	InteractionsgetRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForAuthenticatedUserResponse, error)

	// InteractionssetRestrictionsForAuthenticatedUser request with any body
	InteractionssetRestrictionsForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForAuthenticatedUserResponse, error)

	InteractionssetRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, body InteractionssetRestrictionsForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForAuthenticatedUserResponse, error)

	// IssueslistForAuthenticatedUser request
	IssueslistForAuthenticatedUserWithResponse(ctx context.Context, params *IssueslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*IssueslistForAuthenticatedUserResponse, error)

	// UserslistPublicSshKeysForAuthenticatedUser request
	UserslistPublicSshKeysForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistPublicSshKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicSshKeysForAuthenticatedUserResponse, error)

	// UserscreatePublicSshKeyForAuthenticatedUser request with any body
	UserscreatePublicSshKeyForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserscreatePublicSshKeyForAuthenticatedUserResponse, error)

	UserscreatePublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, body UserscreatePublicSshKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserscreatePublicSshKeyForAuthenticatedUserResponse, error)

	// UsersdeletePublicSshKeyForAuthenticatedUser request
	UsersdeletePublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*UsersdeletePublicSshKeyForAuthenticatedUserResponse, error)

	// UsersgetPublicSshKeyForAuthenticatedUser request
	UsersgetPublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*UsersgetPublicSshKeyForAuthenticatedUserResponse, error)

	// AppslistSubscriptionsForAuthenticatedUser request
	AppslistSubscriptionsForAuthenticatedUserWithResponse(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistSubscriptionsForAuthenticatedUserResponse, error)

	// AppslistSubscriptionsForAuthenticatedUserStubbed request
	AppslistSubscriptionsForAuthenticatedUserStubbedWithResponse(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserStubbedParams, reqEditors ...RequestEditorFn) (*AppslistSubscriptionsForAuthenticatedUserStubbedResponse, error)

	// OrgslistMembershipsForAuthenticatedUser request
	OrgslistMembershipsForAuthenticatedUserWithResponse(ctx context.Context, params *OrgslistMembershipsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*OrgslistMembershipsForAuthenticatedUserResponse, error)

	// OrgsgetMembershipForAuthenticatedUser request
	OrgsgetMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgsgetMembershipForAuthenticatedUserResponse, error)

	// OrgsupdateMembershipForAuthenticatedUser request with any body
	OrgsupdateMembershipForAuthenticatedUserWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateMembershipForAuthenticatedUserResponse, error)

	OrgsupdateMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, body OrgsupdateMembershipForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateMembershipForAuthenticatedUserResponse, error)

	// MigrationslistForAuthenticatedUser request
	MigrationslistForAuthenticatedUserWithResponse(ctx context.Context, params *MigrationslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationslistForAuthenticatedUserResponse, error)

	// MigrationsstartForAuthenticatedUser request with any body
	MigrationsstartForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartForAuthenticatedUserResponse, error)

	MigrationsstartForAuthenticatedUserWithResponse(ctx context.Context, body MigrationsstartForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartForAuthenticatedUserResponse, error)

	// MigrationsgetStatusForAuthenticatedUser request
	MigrationsgetStatusForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, params *MigrationsgetStatusForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationsgetStatusForAuthenticatedUserResponse, error)

	// MigrationsdeleteArchiveForAuthenticatedUser request
	MigrationsdeleteArchiveForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdeleteArchiveForAuthenticatedUserResponse, error)

	// MigrationsgetArchiveForAuthenticatedUser request
	MigrationsgetArchiveForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsgetArchiveForAuthenticatedUserResponse, error)

	// MigrationsunlockRepoForAuthenticatedUser request
	MigrationsunlockRepoForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*MigrationsunlockRepoForAuthenticatedUserResponse, error)

	// MigrationslistReposForAuthenticatedUser request
	MigrationslistReposForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, params *MigrationslistReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationslistReposForAuthenticatedUserResponse, error)

	// OrgslistForAuthenticatedUser request
	OrgslistForAuthenticatedUserWithResponse(ctx context.Context, params *OrgslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*OrgslistForAuthenticatedUserResponse, error)

	// PackageslistPackagesForAuthenticatedUser request
	PackageslistPackagesForAuthenticatedUserWithResponse(ctx context.Context, params *PackageslistPackagesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForAuthenticatedUserResponse, error)

	// PackagesdeletePackageForAuthenticatedUser request
	PackagesdeletePackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesdeletePackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForAuthenticatedUserResponse, error)

	// PackagesgetPackageForAuthenticatedUser request
	PackagesgetPackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetPackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForAuthenticatedUserResponse, error)

	// PackagesrestorePackageForAuthenticatedUser request
	PackagesrestorePackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesrestorePackageForAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForAuthenticatedUserResponse, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser request
	PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, error)

	// PackagesdeletePackageVersionForAuthenticatedUser request
	PackagesdeletePackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesdeletePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForAuthenticatedUserResponse, error)

	// PackagesgetPackageVersionForAuthenticatedUser request
	PackagesgetPackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetPackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForAuthenticatedUserResponse, error)

	// PackagesrestorePackageVersionForAuthenticatedUser request
	PackagesrestorePackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesrestorePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForAuthenticatedUserResponse, error)

	// ProjectscreateForAuthenticatedUser request with any body
	ProjectscreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForAuthenticatedUserResponse, error)

	ProjectscreateForAuthenticatedUserWithResponse(ctx context.Context, body ProjectscreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForAuthenticatedUserResponse, error)

	// UserslistPublicEmailsForAuthenticatedUser request
	UserslistPublicEmailsForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistPublicEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicEmailsForAuthenticatedUserResponse, error)

	// ReposlistForAuthenticatedUser request
	ReposlistForAuthenticatedUserWithResponse(ctx context.Context, params *ReposlistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ReposlistForAuthenticatedUserResponse, error)

	// ReposcreateForAuthenticatedUser request with any body
	ReposcreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateForAuthenticatedUserResponse, error)

	ReposcreateForAuthenticatedUserWithResponse(ctx context.Context, body ReposcreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateForAuthenticatedUserResponse, error)

	// ReposlistInvitationsForAuthenticatedUser request
	ReposlistInvitationsForAuthenticatedUserWithResponse(ctx context.Context, params *ReposlistInvitationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ReposlistInvitationsForAuthenticatedUserResponse, error)

	// ReposdeclineInvitationForAuthenticatedUser request
	ReposdeclineInvitationForAuthenticatedUserWithResponse(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposdeclineInvitationForAuthenticatedUserResponse, error)

	// ReposacceptInvitationForAuthenticatedUser request
	ReposacceptInvitationForAuthenticatedUserWithResponse(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposacceptInvitationForAuthenticatedUserResponse, error)

	// ActivitylistReposStarredByAuthenticatedUser request
	ActivitylistReposStarredByAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistReposStarredByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposStarredByAuthenticatedUserResponse, error)

	// ActivityunstarRepoForAuthenticatedUser request
	ActivityunstarRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivityunstarRepoForAuthenticatedUserResponse, error)

	// ActivitycheckRepoIsStarredByAuthenticatedUser request
	ActivitycheckRepoIsStarredByAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitycheckRepoIsStarredByAuthenticatedUserResponse, error)

	// ActivitystarRepoForAuthenticatedUser request
	ActivitystarRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitystarRepoForAuthenticatedUserResponse, error)

	// ActivitylistWatchedReposForAuthenticatedUser request
	ActivitylistWatchedReposForAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistWatchedReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistWatchedReposForAuthenticatedUserResponse, error)

	// TeamslistForAuthenticatedUser request
	TeamslistForAuthenticatedUserWithResponse(ctx context.Context, params *TeamslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*TeamslistForAuthenticatedUserResponse, error)

	// Userslist request
	UserslistWithResponse(ctx context.Context, params *UserslistParams, reqEditors ...RequestEditorFn) (*UserslistResponse, error)

	// UsersgetByUsername request
	UsersgetByUsernameWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersgetByUsernameResponse, error)

	// ActivitylistEventsForAuthenticatedUser request
	ActivitylistEventsForAuthenticatedUserWithResponse(ctx context.Context, username Username, params *ActivitylistEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistEventsForAuthenticatedUserResponse, error)

	// ActivitylistOrgEventsForAuthenticatedUser request
	ActivitylistOrgEventsForAuthenticatedUserWithResponse(ctx context.Context, username Username, org Org, params *ActivitylistOrgEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistOrgEventsForAuthenticatedUserResponse, error)

	// ActivitylistPublicEventsForUser request
	ActivitylistPublicEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsForUserResponse, error)

	// UserslistFollowersForUser request
	UserslistFollowersForUserWithResponse(ctx context.Context, username Username, params *UserslistFollowersForUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowersForUserResponse, error)

	// UserslistFollowingForUser request
	UserslistFollowingForUserWithResponse(ctx context.Context, username Username, params *UserslistFollowingForUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowingForUserResponse, error)

	// UserscheckFollowingForUser request
	UserscheckFollowingForUserWithResponse(ctx context.Context, username Username, targetUser string, reqEditors ...RequestEditorFn) (*UserscheckFollowingForUserResponse, error)

	// GistslistForUser request
	GistslistForUserWithResponse(ctx context.Context, username Username, params *GistslistForUserParams, reqEditors ...RequestEditorFn) (*GistslistForUserResponse, error)

	// UserslistGpgKeysForUser request
	UserslistGpgKeysForUserWithResponse(ctx context.Context, username Username, params *UserslistGpgKeysForUserParams, reqEditors ...RequestEditorFn) (*UserslistGpgKeysForUserResponse, error)

	// UsersgetContextForUser request
	UsersgetContextForUserWithResponse(ctx context.Context, username Username, params *UsersgetContextForUserParams, reqEditors ...RequestEditorFn) (*UsersgetContextForUserResponse, error)

	// AppsgetUserInstallation request
	AppsgetUserInstallationWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*AppsgetUserInstallationResponse, error)

	// UserslistPublicKeysForUser request
	UserslistPublicKeysForUserWithResponse(ctx context.Context, username Username, params *UserslistPublicKeysForUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicKeysForUserResponse, error)

	// OrgslistForUser request
	OrgslistForUserWithResponse(ctx context.Context, username Username, params *OrgslistForUserParams, reqEditors ...RequestEditorFn) (*OrgslistForUserResponse, error)

	// PackageslistPackagesForUser request
	PackageslistPackagesForUserWithResponse(ctx context.Context, username Username, params *PackageslistPackagesForUserParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForUserResponse, error)

	// PackagesdeletePackageForUser request
	PackagesdeletePackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesdeletePackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForUserResponse, error)

	// PackagesgetPackageForUser request
	PackagesgetPackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesgetPackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForUserResponse, error)

	// PackagesrestorePackageForUser request
	PackagesrestorePackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesrestorePackageForUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForUserParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForUserResponse, error)

	// PackagesgetAllPackageVersionsForPackageOwnedByUser request
	PackagesgetAllPackageVersionsForPackageOwnedByUserWithResponse(ctx context.Context, username Username, packageType PackagesgetAllPackageVersionsForPackageOwnedByUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByUserResponse, error)

	// PackagesdeletePackageVersionForUser request
	PackagesdeletePackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesdeletePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForUserResponse, error)

	// PackagesgetPackageVersionForUser request
	PackagesgetPackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesgetPackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForUserResponse, error)

	// PackagesrestorePackageVersionForUser request
	PackagesrestorePackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesrestorePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForUserResponse, error)

	// ProjectslistForUser request
	ProjectslistForUserWithResponse(ctx context.Context, username Username, params *ProjectslistForUserParams, reqEditors ...RequestEditorFn) (*ProjectslistForUserResponse, error)

	// ActivitylistReceivedEventsForUser request
	ActivitylistReceivedEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistReceivedEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReceivedEventsForUserResponse, error)

	// ActivitylistReceivedPublicEventsForUser request
	ActivitylistReceivedPublicEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistReceivedPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReceivedPublicEventsForUserResponse, error)

	// ReposlistForUser request
	ReposlistForUserWithResponse(ctx context.Context, username Username, params *ReposlistForUserParams, reqEditors ...RequestEditorFn) (*ReposlistForUserResponse, error)

	// BillinggetGithubActionsBillingUser request
	BillinggetGithubActionsBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingUserResponse, error)

	// BillinggetGithubPackagesBillingUser request
	BillinggetGithubPackagesBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingUserResponse, error)

	// BillinggetSharedStorageBillingUser request
	BillinggetSharedStorageBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingUserResponse, error)

	// ActivitylistReposStarredByUser request
	ActivitylistReposStarredByUserWithResponse(ctx context.Context, username Username, params *ActivitylistReposStarredByUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposStarredByUserResponse, error)

	// ActivitylistReposWatchedByUser request
	ActivitylistReposWatchedByUserWithResponse(ctx context.Context, username Username, params *ActivitylistReposWatchedByUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposWatchedByUserResponse, error)

	// MetagetZen request
	MetagetZenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetagetZenResponse, error)
}

type MetarootResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AuthorizationsUrl                string  `json:"authorizations_url"`
		CodeSearchUrl                    string  `json:"code_search_url"`
		CommitSearchUrl                  string  `json:"commit_search_url"`
		CurrentUserAuthorizationsHtmlUrl string  `json:"current_user_authorizations_html_url"`
		CurrentUserRepositoriesUrl       string  `json:"current_user_repositories_url"`
		CurrentUserUrl                   string  `json:"current_user_url"`
		EmailsUrl                        string  `json:"emails_url"`
		EmojisUrl                        string  `json:"emojis_url"`
		EventsUrl                        string  `json:"events_url"`
		FeedsUrl                         string  `json:"feeds_url"`
		FollowersUrl                     string  `json:"followers_url"`
		FollowingUrl                     string  `json:"following_url"`
		GistsUrl                         string  `json:"gists_url"`
		HubUrl                           string  `json:"hub_url"`
		IssueSearchUrl                   string  `json:"issue_search_url"`
		IssuesUrl                        string  `json:"issues_url"`
		KeysUrl                          string  `json:"keys_url"`
		LabelSearchUrl                   string  `json:"label_search_url"`
		NotificationsUrl                 string  `json:"notifications_url"`
		OrganizationRepositoriesUrl      string  `json:"organization_repositories_url"`
		OrganizationTeamsUrl             string  `json:"organization_teams_url"`
		OrganizationUrl                  string  `json:"organization_url"`
		PublicGistsUrl                   string  `json:"public_gists_url"`
		RateLimitUrl                     string  `json:"rate_limit_url"`
		RepositorySearchUrl              string  `json:"repository_search_url"`
		RepositoryUrl                    string  `json:"repository_url"`
		StarredGistsUrl                  string  `json:"starred_gists_url"`
		StarredUrl                       string  `json:"starred_url"`
		TopicSearchUrl                   *string `json:"topic_search_url,omitempty"`
		UserOrganizationsUrl             string  `json:"user_organizations_url"`
		UserRepositoriesUrl              string  `json:"user_repositories_url"`
		UserSearchUrl                    string  `json:"user_search_url"`
		UserUrl                          string  `json:"user_url"`
	}
}

// Status returns HTTPResponse.Status
func (r MetarootResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetarootResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetAuthenticatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
}

// Status returns HTTPResponse.Status
func (r AppsgetAuthenticatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetAuthenticatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppscreateFromManifestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Embedded struct due to allOf(#/components/schemas/integration)
		Integration `yaml:",inline"`
		// Embedded fields due to inline allOf schema
		ClientId             string                 `json:"client_id"`
		ClientSecret         string                 `json:"client_secret"`
		Pem                  string                 `json:"pem"`
		WebhookSecret        *string                `json:"webhook_secret"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r AppscreateFromManifestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppscreateFromManifestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetWebhookConfigForAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r AppsgetWebhookConfigForAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetWebhookConfigForAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsupdateWebhookConfigForAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r AppsupdateWebhookConfigForAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsupdateWebhookConfigForAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistWebhookDeliveriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HookDeliveryItem
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppslistWebhookDeliveriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistWebhookDeliveriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookDelivery
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsgetWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsredeliverWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsredeliverWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsredeliverWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistInstallationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Installation
}

// Status returns HTTPResponse.Status
func (r AppslistInstallationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistInstallationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsdeleteInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsdeleteInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsdeleteInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Installation
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsgetInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppscreateInstallationAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *InstallationToken
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppscreateInstallationAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppscreateInstallationAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsunsuspendInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsunsuspendInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsunsuspendInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppssuspendInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppssuspendInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppssuspendInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationslistGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApplicationGrant
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationslistGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationslistGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsdeleteGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsdeleteGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsdeleteGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsgetGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationGrant
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsgetGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsgetGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsdeleteAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsdeleteAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsdeleteAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsdeleteTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsdeleteTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsdeleteTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsresetTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsresetTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsresetTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppscheckTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppscheckTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppscheckTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsscopeTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppsscopeTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsscopeTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetBySlugResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Integration
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsgetBySlugResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetBySlugResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationslistAuthorizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Authorization
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationslistAuthorizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationslistAuthorizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationscreateAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Authorization
	JSON401      *BasicError
	JSON403      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationscreateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationscreateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsgetOrCreateAuthorizationForAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON201      *Authorization
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsgetOrCreateAuthorizationForAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsgetOrCreateAuthorizationForAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON201      *Authorization
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsdeleteAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsdeleteAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsdeleteAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsgetAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsgetAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsgetAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OauthAuthorizationsupdateAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Authorization
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OauthAuthorizationsupdateAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OauthAuthorizationsupdateAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodesOfConductgetAllCodesOfConductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeOfConduct
}

// Status returns HTTPResponse.Status
func (r CodesOfConductgetAllCodesOfConductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodesOfConductgetAllCodesOfConductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodesOfConductgetConductCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeOfConduct
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodesOfConductgetConductCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodesOfConductgetConductCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmojisgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AdditionalProperties map[string]string `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r EmojisgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmojisgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetServerStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerStatistics
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetServerStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetServerStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetActionsCacheUsageForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsCacheUsageOrgEnterprise
}

// Status returns HTTPResponse.Status
func (r ActionsgetActionsCacheUsageForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetActionsCacheUsageForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsEnterprisePermissions
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Organizations []OrganizationSimple `json:"organizations"`
		TotalCount    float32              `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetAllowedActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelectedActions
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetAllowedActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetAllowedActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetAllowedActionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetAllowedActionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetAllowedActionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsGetDefaultWorkflowPermissions
}

// Status returns HTTPResponse.Status
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		RunnerGroups []RunnerGroupsEnterprise `json:"runner_groups"`
		TotalCount   float32                  `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RunnerGroupsEnterprise
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunnerGroupsEnterprise
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunnerGroupsEnterprise
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Organizations []OrganizationSimple `json:"organizations"`
		TotalCount    float32              `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Runners    []Runner `json:"runners"`
		TotalCount float32  `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Runners    *[]Runner `json:"runners,omitempty"`
		TotalCount *float32  `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RunnerApplication
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmincreateRemoveTokenForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmincreateRemoveTokenForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmincreateRemoveTokenForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Runner
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLogEvent
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanninglistAlertsForEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationSecretScanningAlert
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanninglistAlertsForEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanninglistAlertsForEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubActionsBillingGheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubActionsBillingGheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubActionsBillingGheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubAdvancedSecurityBillingGheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdvancedSecurityActiveCommitters
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubAdvancedSecurityBillingGheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubAdvancedSecurityBillingGheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubPackagesBillingGheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackagesBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubPackagesBillingGheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubPackagesBillingGheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetSharedStorageBillingGheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CombinedBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetSharedStorageBillingGheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetSharedStorageBillingGheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistPublicEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
	JSON403      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ActivitylistPublicEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistPublicEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitygetFeedsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Feed
}

// Status returns HTTPResponse.Status
func (r ActivitygetFeedsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitygetFeedsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseGist
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistscreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GistSimple
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistscreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistscreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistPublicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseGist
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistslistPublicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistPublicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistStarredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseGist
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistslistStarredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistStarredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsdeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsdeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsdeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GistSimple
	JSON403      *struct {
		Block *struct {
			CreatedAt *string `json:"created_at,omitempty"`
			HtmlUrl   *string `json:"html_url"`
			Reason    *string `json:"reason,omitempty"`
		} `json:"block,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GistSimple
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistsupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GistComment
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistslistCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistscreateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GistComment
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistscreateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistscreateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsdeleteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsdeleteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsdeleteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsgetCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GistComment
	JSON403      *struct {
		Block *struct {
			CreatedAt *string `json:"created_at,omitempty"`
			HtmlUrl   *string `json:"html_url"`
			Reason    *string `json:"reason,omitempty"`
		} `json:"block,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsgetCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsgetCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsupdateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GistComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsupdateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsupdateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GistCommit
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistslistCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistForksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GistSimple
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistslistForksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistForksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsforkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BaseGist
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistsforkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsforkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsunstarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsunstarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsunstarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistscheckIsStarredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r GistscheckIsStarredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistscheckIsStarredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsstarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GistsstarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsstarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistsgetRevisionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GistSimple
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistsgetRevisionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistsgetRevisionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitignoregetAllTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GitignoregetAllTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitignoregetAllTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitignoregetTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitignoreTemplate
}

// Status returns HTTPResponse.Status
func (r GitignoregetTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitignoregetTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistReposAccessibleToInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories        []Repository `json:"repositories"`
		RepositorySelection *string      `json:"repository_selection,omitempty"`
		TotalCount          int          `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistReposAccessibleToInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistReposAccessibleToInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsrevokeInstallationAccessTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AppsrevokeInstallationAccessTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsrevokeInstallationAccessTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Issue
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssueslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LicensesgetAllCommonlyUsedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LicenseSimple
}

// Status returns HTTPResponse.Status
func (r LicensesgetAllCommonlyUsedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LicensesgetAllCommonlyUsedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LicensesgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *License
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r LicensesgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LicensesgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkdownrenderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkdownrenderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkdownrenderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MarkdownrenderRawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MarkdownrenderRawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MarkdownrenderRawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetSubscriptionPlanForAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketplacePurchase
	JSON401      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsgetSubscriptionPlanForAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetSubscriptionPlanForAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketplaceListingPlan
	JSON401      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistAccountsForPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketplacePurchase
	JSON401      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r AppslistAccountsForPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistAccountsForPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetSubscriptionPlanForAccountStubbedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MarketplacePurchase
	JSON401      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsgetSubscriptionPlanForAccountStubbedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetSubscriptionPlanForAccountStubbedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistPlansStubbedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketplaceListingPlan
	JSON401      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistPlansStubbedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistPlansStubbedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistAccountsForPlanStubbedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MarketplacePurchase
	JSON401      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistAccountsForPlanStubbedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistAccountsForPlanStubbedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetagetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiOverview
}

// Status returns HTTPResponse.Status
func (r MetagetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetagetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistPublicEventsForRepoNetworkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
	JSON301      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitylistPublicEventsForRepoNetworkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistPublicEventsForRepoNetworkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistNotificationsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Thread
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ActivitylistNotificationsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistNotificationsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitymarkNotificationsAsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitymarkNotificationsAsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitymarkNotificationsAsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitygetThreadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Thread
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitygetThreadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitygetThreadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitymarkThreadAsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitymarkThreadAsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitymarkThreadAsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitydeleteThreadSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitydeleteThreadSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitydeleteThreadSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitygetThreadSubscriptionForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadSubscription
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitygetThreadSubscriptionForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitygetThreadSubscriptionForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitysetThreadSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ThreadSubscription
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitysetThreadSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitysetThreadSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetagetOctocatResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetagetOctocatResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetagetOctocatResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationSimple
}

// Status returns HTTPResponse.Status
func (r OrgslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistCustomRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CustomRoles *[]OrganizationCustomRepositoryRole `json:"custom_roles,omitempty"`

		// The number of custom roles in this organization
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r OrgslistCustomRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistCustomRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationFull
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationFull
	JSON409      *BasicError
	JSON422      *interface{}
}

// Status returns HTTPResponse.Status
func (r OrgsupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetActionsCacheUsageForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsCacheUsageOrgEnterprise
}

// Status returns HTTPResponse.Status
func (r ActionsgetActionsCacheUsageForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetActionsCacheUsageForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetActionsCacheUsageByRepoForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		RepositoryCacheUsages []ActionsCacheUsageByRepository `json:"repository_cache_usages"`
		TotalCount            int                             `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionsgetActionsCacheUsageByRepoForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetActionsCacheUsageByRepoForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetGithubActionsPermissionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsOrganizationPermissions
}

// Status returns HTTPResponse.Status
func (r ActionsgetGithubActionsPermissionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetGithubActionsPermissionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetGithubActionsPermissionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetGithubActionsPermissionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetGithubActionsPermissionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories []Repository `json:"repositories"`
		TotalCount   float32      `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsenableSelectedRepositoryGithubActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsenableSelectedRepositoryGithubActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsenableSelectedRepositoryGithubActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetAllowedActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelectedActions
}

// Status returns HTTPResponse.Status
func (r ActionsgetAllowedActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetAllowedActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetAllowedActionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetAllowedActionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetAllowedActionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsGetDefaultWorkflowPermissions
}

// Status returns HTTPResponse.Status
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelfHostedRunnerGroupsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		RunnerGroups []RunnerGroupsOrg `json:"runner_groups"`
		TotalCount   float32           `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelfHostedRunnerGroupsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelfHostedRunnerGroupsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateSelfHostedRunnerGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RunnerGroupsOrg
}

// Status returns HTTPResponse.Status
func (r ActionscreateSelfHostedRunnerGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateSelfHostedRunnerGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteSelfHostedRunnerGroupFromOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteSelfHostedRunnerGroupFromOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteSelfHostedRunnerGroupFromOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetSelfHostedRunnerGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunnerGroupsOrg
}

// Status returns HTTPResponse.Status
func (r ActionsgetSelfHostedRunnerGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetSelfHostedRunnerGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsupdateSelfHostedRunnerGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunnerGroupsOrg
}

// Status returns HTTPResponse.Status
func (r ActionsupdateSelfHostedRunnerGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsupdateSelfHostedRunnerGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories []MinimalRepository `json:"repositories"`
		TotalCount   float32             `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelfHostedRunnersInGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Runners    []Runner `json:"runners"`
		TotalCount float32  `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelfHostedRunnersInGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelfHostedRunnersInGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetSelfHostedRunnersInGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetSelfHostedRunnersInGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetSelfHostedRunnersInGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveSelfHostedRunnerFromGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsremoveSelfHostedRunnerFromGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveSelfHostedRunnerFromGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsaddSelfHostedRunnerToGroupForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsaddSelfHostedRunnerToGroupForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsaddSelfHostedRunnerToGroupForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelfHostedRunnersForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Runners    []Runner `json:"runners"`
		TotalCount int      `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelfHostedRunnersForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelfHostedRunnersForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistRunnerApplicationsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RunnerApplication
}

// Status returns HTTPResponse.Status
func (r ActionslistRunnerApplicationsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistRunnerApplicationsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateRegistrationTokenForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r ActionscreateRegistrationTokenForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateRegistrationTokenForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateRemoveTokenForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r ActionscreateRemoveTokenForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateRemoveTokenForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteSelfHostedRunnerFromOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteSelfHostedRunnerFromOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteSelfHostedRunnerFromOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Runner
}

// Status returns HTTPResponse.Status
func (r ActionsgetSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistLabelsForSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionslistLabelsForSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistLabelsForSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistOrgSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []OrganizationActionsSecret `json:"secrets"`
		TotalCount int                         `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistOrgSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistOrgSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetOrgPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsPublicKey
}

// Status returns HTTPResponse.Status
func (r ActionsgetOrgPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetOrgPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationActionsSecret
}

// Status returns HTTPResponse.Status
func (r ActionsgetOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateOrUpdateOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
}

// Status returns HTTPResponse.Status
func (r ActionscreateOrUpdateOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateOrUpdateOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelectedReposForOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories []MinimalRepository `json:"repositories"`
		TotalCount   int                 `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelectedReposForOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelectedReposForOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetSelectedReposForOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetSelectedReposForOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetSelectedReposForOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveSelectedRepoFromOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsremoveSelectedRepoFromOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveSelectedRepoFromOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsaddSelectedRepoToOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsaddSelectedRepoToOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsaddSelectedRepoToOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetAuditLogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuditLogEvent
}

// Status returns HTTPResponse.Status
func (r OrgsgetAuditLogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetAuditLogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistBlockedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r OrgslistBlockedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistBlockedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsunblockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OrgsunblockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsunblockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscheckBlockedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgscheckBlockedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscheckBlockedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsblockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgsblockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsblockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninglistAlertsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeScanningOrganizationAlertItems
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninglistAlertsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninglistAlertsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistSamlSsoAuthorizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CredentialAuthorization
}

// Status returns HTTPResponse.Status
func (r OrgslistSamlSsoAuthorizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistSamlSsoAuthorizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsremoveSamlSsoAuthorizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsremoveSamlSsoAuthorizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsremoveSamlSsoAuthorizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotlistOrgSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []OrganizationDependabotSecret `json:"secrets"`
		TotalCount int                            `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r DependabotlistOrgSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotlistOrgSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotgetOrgPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DependabotPublicKey
}

// Status returns HTTPResponse.Status
func (r DependabotgetOrgPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotgetOrgPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotdeleteOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DependabotdeleteOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotdeleteOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotgetOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationDependabotSecret
}

// Status returns HTTPResponse.Status
func (r DependabotgetOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotgetOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotcreateOrUpdateOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
}

// Status returns HTTPResponse.Status
func (r DependabotcreateOrUpdateOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotcreateOrUpdateOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotlistSelectedReposForOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories []MinimalRepository `json:"repositories"`
		TotalCount   int                 `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r DependabotlistSelectedReposForOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotlistSelectedReposForOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotsetSelectedReposForOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DependabotsetSelectedReposForOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotsetSelectedReposForOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotremoveSelectedRepoFromOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DependabotremoveSelectedRepoFromOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotremoveSelectedRepoFromOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotaddSelectedRepoToOrgSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DependabotaddSelectedRepoToOrgSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotaddSelectedRepoToOrgSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistPublicOrgEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistPublicOrgEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistPublicOrgEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsexternalIdpGroupInfoForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalGroup
}

// Status returns HTTPResponse.Status
func (r TeamsexternalIdpGroupInfoForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsexternalIdpGroupInfoForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistExternalIdpGroupsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalGroups
}

// Status returns HTTPResponse.Status
func (r TeamslistExternalIdpGroupsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistExternalIdpGroupsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistFailedInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationInvitation
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgslistFailedInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistFailedInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrgHook
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgslistWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrgHook
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgscreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsdeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsdeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsdeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgHook
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsgetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsupdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgHook
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgsupdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsupdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetWebhookConfigForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r OrgsgetWebhookConfigForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetWebhookConfigForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsupdateWebhookConfigForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r OrgsupdateWebhookConfigForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsupdateWebhookConfigForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistWebhookDeliveriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HookDeliveryItem
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgslistWebhookDeliveriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistWebhookDeliveriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookDelivery
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgsgetWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsredeliverWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgsredeliverWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsredeliverWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgspingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgspingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgspingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetOrgInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Installation
}

// Status returns HTTPResponse.Status
func (r AppsgetOrgInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetOrgInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistAppInstallationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Installations []Installation `json:"installations"`
		TotalCount    int            `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r OrgslistAppInstallationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistAppInstallationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsremoveRestrictionsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InteractionsremoveRestrictionsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsremoveRestrictionsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsgetRestrictionsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r InteractionsgetRestrictionsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsgetRestrictionsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionssetRestrictionsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InteractionLimitResponse
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r InteractionssetRestrictionsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionssetRestrictionsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistPendingInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationInvitation
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgslistPendingInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistPendingInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscreateInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OrganizationInvitation
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgscreateInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscreateInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscancelInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgscancelInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscancelInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistInvitationTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgslistInvitationTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistInvitationTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Issue
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgslistMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsremoveMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsremoveMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsremoveMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscheckMembershipForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OrgscheckMembershipForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscheckMembershipForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsremoveMembershipForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsremoveMembershipForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsremoveMembershipForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetMembershipForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgMembership
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsgetMembershipForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetMembershipForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgssetMembershipForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgMembership
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgssetMembershipForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgssetMembershipForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationslistForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Migration
}

// Status returns HTTPResponse.Status
func (r MigrationslistForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationslistForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsstartForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Migration
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r MigrationsstartForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsstartForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetStatusForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Migration
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsgetStatusForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetStatusForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsdeleteArchiveForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsdeleteArchiveForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsdeleteArchiveForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsdownloadArchiveForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsdownloadArchiveForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsdownloadArchiveForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsunlockRepoForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsunlockRepoForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsunlockRepoForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationslistReposForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationslistReposForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationslistReposForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistOutsideCollaboratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r OrgslistOutsideCollaboratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistOutsideCollaboratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsremoveOutsideCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r OrgsremoveOutsideCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsremoveOutsideCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsconvertMemberToOutsideCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsconvertMemberToOutsideCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsconvertMemberToOutsideCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackageslistPackagesForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackageslistPackagesForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackageslistPackagesForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageVersion
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageVersionForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageVersionForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageVersionForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageVersionForOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageVersion
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageVersionForOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageVersionForOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageVersionForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageVersionForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageVersionForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Project
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectslistForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectscreateForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectscreateForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectscreateForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistPublicMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r OrgslistPublicMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistPublicMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsremovePublicMembershipForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OrgsremovePublicMembershipForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsremovePublicMembershipForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgscheckPublicMembershipForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r OrgscheckPublicMembershipForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgscheckPublicMembershipForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgssetPublicMembershipForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgssetPublicMembershipForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgssetPublicMembershipForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
}

// Status returns HTTPResponse.Status
func (r ReposlistForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanninglistAlertsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationSecretScanningAlert
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanninglistAlertsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanninglistAlertsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubActionsBillingOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubActionsBillingOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubActionsBillingOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubAdvancedSecurityBillingOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AdvancedSecurityActiveCommitters
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubAdvancedSecurityBillingOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubAdvancedSecurityBillingOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubPackagesBillingOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackagesBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubPackagesBillingOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubPackagesBillingOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetSharedStorageBillingOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CombinedBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetSharedStorageBillingOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetSharedStorageBillingOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistIdpGroupsForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMapping
}

// Status returns HTTPResponse.Status
func (r TeamslistIdpGroupsForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistIdpGroupsForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamFull
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamscreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetByNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamFull
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamsgetByNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetByNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamFull
}

// Status returns HTTPResponse.Status
func (r TeamsupdateInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistDiscussionsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamslistDiscussionsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistDiscussionsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamscreateDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamsgetDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamsupdateDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistDiscussionCommentsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamslistDiscussionCommentsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistDiscussionCommentsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamscreateDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamsgetDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamsupdateDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForTeamDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionslistForTeamDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForTeamDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForTeamDiscussionCommentInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForTeamDiscussionCommentInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForTeamDiscussionCommentInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForTeamDiscussionCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForTeamDiscussionCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForTeamDiscussionCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForTeamDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionslistForTeamDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForTeamDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForTeamDiscussionInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForTeamDiscussionInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForTeamDiscussionInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForTeamDiscussionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForTeamDiscussionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForTeamDiscussionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsunlinkExternalIdpGroupFromTeamForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsunlinkExternalIdpGroupFromTeamForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsunlinkExternalIdpGroupFromTeamForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalGroups
}

// Status returns HTTPResponse.Status
func (r TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslinkExternalIdpGroupToTeamForOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalGroup
}

// Status returns HTTPResponse.Status
func (r TeamslinkExternalIdpGroupToTeamForOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslinkExternalIdpGroupToTeamForOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistPendingInvitationsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationInvitation
}

// Status returns HTTPResponse.Status
func (r TeamslistPendingInvitationsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistPendingInvitationsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistMembersInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r TeamslistMembersInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistMembersInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveMembershipForUserInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveMembershipForUserInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveMembershipForUserInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetMembershipForUserInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMembership
}

// Status returns HTTPResponse.Status
func (r TeamsgetMembershipForUserInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetMembershipForUserInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateMembershipForUserInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMembership
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateMembershipForUserInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateMembershipForUserInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistProjectsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamProject
}

// Status returns HTTPResponse.Status
func (r TeamslistProjectsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistProjectsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveProjectInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveProjectInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveProjectInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscheckPermissionsForProjectInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamProject
}

// Status returns HTTPResponse.Status
func (r TeamscheckPermissionsForProjectInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscheckPermissionsForProjectInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateProjectPermissionsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateProjectPermissionsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateProjectPermissionsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistReposInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
}

// Status returns HTTPResponse.Status
func (r TeamslistReposInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistReposInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveRepoInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveRepoInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveRepoInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscheckPermissionsForRepoInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamRepository
}

// Status returns HTTPResponse.Status
func (r TeamscheckPermissionsForRepoInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscheckPermissionsForRepoInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateRepoPermissionsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateRepoPermissionsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateRepoPermissionsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistIdpGroupsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMapping
}

// Status returns HTTPResponse.Status
func (r TeamslistIdpGroupsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistIdpGroupsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMapping
}

// Status returns HTTPResponse.Status
func (r TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistChildInOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
}

// Status returns HTTPResponse.Status
func (r TeamslistChildInOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistChildInOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsdeleteCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *struct {
		DocumentationUrl *string   `json:"documentation_url,omitempty"`
		Errors           *[]string `json:"errors,omitempty"`
		Message          *string   `json:"message,omitempty"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsdeleteCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsdeleteCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsgetCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCard
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsgetCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsgetCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsupdateCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCard
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectsupdateCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsupdateCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsmoveCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
	JSON401      *BasicError
	JSON403      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Errors           *[]struct {
			Code     *string `json:"code,omitempty"`
			Field    *string `json:"field,omitempty"`
			Message  *string `json:"message,omitempty"`
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSON422 *ValidationError
	JSON503 *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Errors           *[]struct {
			Code    *string `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectsmoveCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsmoveCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsdeleteColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsdeleteColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsdeleteColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsgetColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectColumn
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsgetColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsgetColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsupdateColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectColumn
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsupdateColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsupdateColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistCardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProjectCard
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectslistCardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistCardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectscreateCardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProjectCard
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *interface{}
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Errors           *[]struct {
			Code    *string `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		} `json:"errors,omitempty"`
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ProjectscreateCardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectscreateCardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsmoveColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectsmoveColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsmoveColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsdeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *struct {
		DocumentationUrl *string   `json:"documentation_url,omitempty"`
		Errors           *[]string `json:"errors,omitempty"`
		Message          *string   `json:"message,omitempty"`
	}
	JSON404 *BasicError
	JSON410 *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsdeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsdeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectsgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON401      *BasicError
	JSON403      *struct {
		DocumentationUrl *string   `json:"documentation_url,omitempty"`
		Errors           *[]string `json:"errors,omitempty"`
		Message          *string   `json:"message,omitempty"`
	}
	JSON410 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectsupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistCollaboratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ProjectslistCollaboratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistCollaboratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsremoveCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ProjectsremoveCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsremoveCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsaddCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ProjectsaddCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsaddCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsgetPermissionForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectCollaboratorPermission
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ProjectsgetPermissionForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsgetPermissionForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistColumnsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ProjectColumn
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ProjectslistColumnsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistColumnsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectscreateColumnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ProjectColumn
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectscreateColumnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectscreateColumnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RateLimitgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RateLimitOverview
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r RateLimitgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RateLimitgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON307      *BasicError
	JSON403      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FullRepository
	JSON301      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FullRepository
	JSON307      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistArtifactsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Artifacts  []Artifact `json:"artifacts"`
		TotalCount int        `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistArtifactsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistArtifactsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Artifact
}

// Status returns HTTPResponse.Status
func (r ActionsgetArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdownloadArtifactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdownloadArtifactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdownloadArtifactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetActionsCacheUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsCacheUsageByRepository
}

// Status returns HTTPResponse.Status
func (r ActionsgetActionsCacheUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetActionsCacheUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetJobForWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Job
}

// Status returns HTTPResponse.Status
func (r ActionsgetJobForWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetJobForWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdownloadJobLogsForWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdownloadJobLogsForWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdownloadJobLogsForWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsreRunJobForWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionsreRunJobForWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsreRunJobForWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetGithubActionsPermissionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsRepositoryPermissions
}

// Status returns HTTPResponse.Status
func (r ActionsgetGithubActionsPermissionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetGithubActionsPermissionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetGithubActionsPermissionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetGithubActionsPermissionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetGithubActionsPermissionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowAccessToRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsWorkflowAccessToRepository
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowAccessToRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowAccessToRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetWorkflowAccessToRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetWorkflowAccessToRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetWorkflowAccessToRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetAllowedActionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SelectedActions
}

// Status returns HTTPResponse.Status
func (r ActionsgetAllowedActionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetAllowedActionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetAllowedActionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetAllowedActionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetAllowedActionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsGetDefaultWorkflowPermissions
}

// Status returns HTTPResponse.Status
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistSelfHostedRunnersForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Runners    []Runner `json:"runners"`
		TotalCount int      `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistSelfHostedRunnersForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistSelfHostedRunnersForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistRunnerApplicationsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RunnerApplication
}

// Status returns HTTPResponse.Status
func (r ActionslistRunnerApplicationsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistRunnerApplicationsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateRegistrationTokenForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r ActionscreateRegistrationTokenForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateRegistrationTokenForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateRemoveTokenForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AuthenticationToken
}

// Status returns HTTPResponse.Status
func (r ActionscreateRemoveTokenForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateRemoveTokenForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteSelfHostedRunnerFromRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteSelfHostedRunnerFromRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteSelfHostedRunnerFromRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Runner
}

// Status returns HTTPResponse.Status
func (r ActionsgetSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistLabelsForSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionslistLabelsForSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistLabelsForSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Labels     []RunnerLabel `json:"labels"`
		TotalCount int           `json:"total_count"`
	}
	JSON404 *BasicError
	JSON422 *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistWorkflowRunsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TotalCount   int           `json:"total_count"`
		WorkflowRuns []WorkflowRun `json:"workflow_runs"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistWorkflowRunsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistWorkflowRunsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetReviewsForRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]EnvironmentApprovals
}

// Status returns HTTPResponse.Status
func (r ActionsgetReviewsForRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetReviewsForRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsapproveWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionsapproveWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsapproveWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistWorkflowRunArtifactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Artifacts  []Artifact `json:"artifacts"`
		TotalCount int        `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistWorkflowRunArtifactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistWorkflowRunArtifactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowRunAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRun
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowRunAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowRunAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistJobsForWorkflowRunAttemptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Jobs       []Job `json:"jobs"`
		TotalCount int   `json:"total_count"`
	}
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionslistJobsForWorkflowRunAttemptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistJobsForWorkflowRunAttemptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdownloadWorkflowRunAttemptLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdownloadWorkflowRunAttemptLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdownloadWorkflowRunAttemptLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscancelWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON409      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionscancelWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscancelWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistJobsForWorkflowRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Jobs       []Job `json:"jobs"`
		TotalCount int   `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistJobsForWorkflowRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistJobsForWorkflowRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteWorkflowRunLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteWorkflowRunLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteWorkflowRunLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdownloadWorkflowRunLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdownloadWorkflowRunLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdownloadWorkflowRunLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetPendingDeploymentsForRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PendingDeployment
}

// Status returns HTTPResponse.Status
func (r ActionsgetPendingDeploymentsForRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetPendingDeploymentsForRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsreviewPendingDeploymentsForRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Deployment
}

// Status returns HTTPResponse.Status
func (r ActionsreviewPendingDeploymentsForRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsreviewPendingDeploymentsForRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsreRunWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ActionsreRunWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsreRunWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsreRunWorkflowFailedJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
}

// Status returns HTTPResponse.Status
func (r ActionsreRunWorkflowFailedJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsreRunWorkflowFailedJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowRunUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowRunUsage
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowRunUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowRunUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistRepoSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []ActionsSecret `json:"secrets"`
		TotalCount int             `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistRepoSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistRepoSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetRepoPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsPublicKey
}

// Status returns HTTPResponse.Status
func (r ActionsgetRepoPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetRepoPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsSecret
}

// Status returns HTTPResponse.Status
func (r ActionsgetRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateOrUpdateRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ActionscreateOrUpdateRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateOrUpdateRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistRepoWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TotalCount int        `json:"total_count"`
		Workflows  []Workflow `json:"workflows"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistRepoWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistRepoWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Workflow
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdisableWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdisableWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdisableWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateWorkflowDispatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionscreateWorkflowDispatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateWorkflowDispatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsenableWorkflowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsenableWorkflowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsenableWorkflowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistWorkflowRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		TotalCount   int           `json:"total_count"`
		WorkflowRuns []WorkflowRun `json:"workflow_runs"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistWorkflowRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistWorkflowRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetWorkflowUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowUsage
}

// Status returns HTTPResponse.Status
func (r ActionsgetWorkflowUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetWorkflowUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistAssigneesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistAssigneesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistAssigneesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuescheckUserCanBeAssignedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuescheckUserCanBeAssignedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuescheckUserCanBeAssignedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistAutolinksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Autolink
}

// Status returns HTTPResponse.Status
func (r ReposlistAutolinksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistAutolinksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateAutolinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Autolink
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateAutolinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateAutolinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteAutolinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteAutolinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteAutolinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAutolinkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Autolink
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetAutolinkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAutolinkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdisableAutomatedSecurityFixesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdisableAutomatedSecurityFixesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdisableAutomatedSecurityFixesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposenableAutomatedSecurityFixesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposenableAutomatedSecurityFixesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposenableAutomatedSecurityFixesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistBranchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ShortBranch
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistBranchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistBranchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchWithProtection
	JSON301      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchProtection
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranch
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ReposupdateBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteAdminBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteAdminBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteAdminBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAdminBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchAdminEnforced
}

// Status returns HTTPResponse.Status
func (r ReposgetAdminBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAdminBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepossetAdminBranchProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchAdminEnforced
}

// Status returns HTTPResponse.Status
func (r RepossetAdminBranchProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepossetAdminBranchProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeletePullRequestReviewProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeletePullRequestReviewProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeletePullRequestReviewProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetPullRequestReviewProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchPullRequestReview
}

// Status returns HTTPResponse.Status
func (r ReposgetPullRequestReviewProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetPullRequestReviewProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdatePullRequestReviewProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchPullRequestReview
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposupdatePullRequestReviewProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdatePullRequestReviewProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteCommitSignatureProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteCommitSignatureProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteCommitSignatureProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCommitSignatureProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchAdminEnforced
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCommitSignatureProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommitSignatureProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateCommitSignatureProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProtectedBranchAdminEnforced
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposcreateCommitSignatureProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateCommitSignatureProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveStatusCheckProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposremoveStatusCheckProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveStatusCheckProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetStatusChecksProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusCheckPolicy
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetStatusChecksProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetStatusChecksProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateStatusCheckProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StatusCheckPolicy
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposupdateStatusCheckProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateStatusCheckProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveStatusCheckContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposremoveStatusCheckContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveStatusCheckContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAllStatusCheckContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetAllStatusCheckContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAllStatusCheckContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposaddStatusCheckContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposaddStatusCheckContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposaddStatusCheckContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepossetStatusCheckContextsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r RepossetStatusCheckContextsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepossetStatusCheckContextsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BranchRestrictionPolicy
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveAppAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposremoveAppAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveAppAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAppsWithAccessToProtectedBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetAppsWithAccessToProtectedBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAppsWithAccessToProtectedBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposaddAppAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposaddAppAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposaddAppAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepossetAppAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Integration
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r RepossetAppAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepossetAppAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveTeamAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposremoveTeamAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveTeamAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetTeamsWithAccessToProtectedBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetTeamsWithAccessToProtectedBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetTeamsWithAccessToProtectedBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposaddTeamAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposaddTeamAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposaddTeamAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepossetTeamAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r RepossetTeamAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepossetTeamAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveUserAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposremoveUserAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveUserAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetUsersWithAccessToProtectedBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetUsersWithAccessToProtectedBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetUsersWithAccessToProtectedBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposaddUserAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposaddUserAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposaddUserAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepossetUserAccessRestrictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r RepossetUserAccessRestrictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepossetUserAccessRestrictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposrenameBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BranchWithProtection
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposrenameBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposrenameBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckscreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CheckRun
}

// Status returns HTTPResponse.Status
func (r CheckscreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckscreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChecksgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckRun
}

// Status returns HTTPResponse.Status
func (r ChecksgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChecksgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChecksupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckRun
}

// Status returns HTTPResponse.Status
func (r ChecksupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChecksupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckslistAnnotationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CheckAnnotation
}

// Status returns HTTPResponse.Status
func (r CheckslistAnnotationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckslistAnnotationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChecksrerequestRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *BasicError
}

// Status returns HTTPResponse.Status
func (r ChecksrerequestRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChecksrerequestRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckscreateSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckSuite
	JSON201      *CheckSuite
}

// Status returns HTTPResponse.Status
func (r CheckscreateSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckscreateSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckssetSuitesPreferencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckSuitePreference
}

// Status returns HTTPResponse.Status
func (r CheckssetSuitesPreferencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckssetSuitesPreferencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChecksgetSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckSuite
}

// Status returns HTTPResponse.Status
func (r ChecksgetSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChecksgetSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckslistForSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CheckRuns  []CheckRun `json:"check_runs"`
		TotalCount int        `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckslistForSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckslistForSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChecksrerequestSuiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ChecksrerequestSuiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChecksrerequestSuiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninglistAlertsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeScanningAlertItems
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninglistAlertsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninglistAlertsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninggetAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeScanningAlert
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninggetAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninggetAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanningupdateAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeScanningAlert
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanningupdateAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanningupdateAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninglistAlertInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeScanningAlertInstance
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninglistAlertInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninglistAlertInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninglistRecentAnalysesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeScanningAnalysis
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninglistRecentAnalysesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninglistRecentAnalysesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanningdeleteAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeScanningAnalysisDeletion
	JSON400      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanningdeleteAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanningdeleteAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninggetAnalysisResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeScanningAnalysis
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninggetAnalysisResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninggetAnalysisResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninguploadSarifResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CodeScanningSarifsReceipt
	JSON403      *BasicError
	JSON404      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninguploadSarifResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninguploadSarifResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodeScanninggetSarifResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeScanningSarifsStatus
	JSON403      *BasicError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CodeScanninggetSarifResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodeScanninggetSarifResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcodeownersErrorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodeownersErrors
}

// Status returns HTTPResponse.Status
func (r ReposcodeownersErrorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcodeownersErrorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistInRepositoryForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Codespaces []Codespace `json:"codespaces"`
		TotalCount int         `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespaceslistInRepositoryForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistInRepositoryForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescreateWithRepoForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Codespace
	JSON202      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacescreateWithRepoForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescreateWithRepoForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Devcontainers []struct {
			Name *string `json:"name,omitempty"`
			Path string  `json:"path"`
		} `json:"devcontainers"`
		TotalCount int `json:"total_count"`
	}
	JSON400 *BasicError
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesrepoMachinesForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Machines   []CodespaceMachine `json:"machines"`
		TotalCount int                `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesrepoMachinesForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesrepoMachinesForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistRepoSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []RepoCodespacesSecret `json:"secrets"`
		TotalCount int                    `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r CodespaceslistRepoSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistRepoSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetRepoPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodespacesPublicKey
}

// Status returns HTTPResponse.Status
func (r CodespacesgetRepoPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetRepoPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesdeleteRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CodespacesdeleteRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesdeleteRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepoCodespacesSecret
}

// Status returns HTTPResponse.Status
func (r CodespacesgetRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescreateOrUpdateRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r CodespacescreateOrUpdateRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescreateOrUpdateRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistCollaboratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Collaborator
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistCollaboratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistCollaboratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposremoveCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposremoveCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposremoveCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcheckCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposcheckCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcheckCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposaddCollaboratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RepositoryInvitation
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposaddCollaboratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposaddCollaboratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCollaboratorPermissionLevelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryCollaboratorPermission
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCollaboratorPermissionLevelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCollaboratorPermissionLevelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistCommitCommentsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CommitComment
}

// Status returns HTTPResponse.Status
func (r ReposlistCommitCommentsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistCommitCommentsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposupdateCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReactionslistForCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Commit
	JSON400      *BasicError
	JSON404      *BasicError
	JSON409      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistBranchesForHeadCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BranchShort
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposlistBranchesForHeadCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistBranchesForHeadCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistCommentsForCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CommitComment
}

// Status returns HTTPResponse.Status
func (r ReposlistCommentsForCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistCommentsForCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateCommitCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CommitComment
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateCommitCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateCommitCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistPullRequestsAssociatedWithCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PullRequestSimple
}

// Status returns HTTPResponse.Status
func (r ReposlistPullRequestsAssociatedWithCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistPullRequestsAssociatedWithCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Commit
	JSON404      *BasicError
	JSON422      *ValidationError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckslistForRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CheckRuns  []CheckRun `json:"check_runs"`
		TotalCount int        `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckslistForRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckslistForRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckslistSuitesForRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CheckSuites []CheckSuite `json:"check_suites"`
		TotalCount  int          `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r CheckslistSuitesForRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckslistSuitesForRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCombinedStatusForRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CombinedCommitStatus
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetCombinedStatusForRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCombinedStatusForRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistCommitStatusesForRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Status
	JSON301      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistCommitStatusesForRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistCommitStatusesForRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCommunityProfileMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommunityProfile
}

// Status returns HTTPResponse.Status
func (r ReposgetCommunityProfileMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommunityProfileMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcompareCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CommitComparison
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposcompareCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcompareCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileCommit
	JSON404      *BasicError
	JSON409      *BasicError
	JSON422      *ValidationError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReposdeleteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateOrUpdateFileContentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FileCommit
	JSON201      *FileCommit
	JSON404      *BasicError
	JSON409      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateOrUpdateFileContentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateOrUpdateFileContentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistContributorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Contributor
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistContributorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistContributorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotlistRepoSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []DependabotSecret `json:"secrets"`
		TotalCount int                `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r DependabotlistRepoSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotlistRepoSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotgetRepoPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DependabotPublicKey
}

// Status returns HTTPResponse.Status
func (r DependabotgetRepoPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotgetRepoPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotdeleteRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DependabotdeleteRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotdeleteRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotgetRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DependabotSecret
}

// Status returns HTTPResponse.Status
func (r DependabotgetRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotgetRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependabotcreateOrUpdateRepoSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r DependabotcreateOrUpdateRepoSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependabotcreateOrUpdateRepoSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DependencyGraphdiffRangeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DependencyGraphDiff
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r DependencyGraphdiffRangeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DependencyGraphdiffRangeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistDeploymentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Deployment
}

// Status returns HTTPResponse.Status
func (r ReposlistDeploymentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistDeploymentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Deployment
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
	}
	JSON422 *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ReposdeleteDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetDeploymentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Deployment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetDeploymentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetDeploymentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistDeploymentStatusesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DeploymentStatus
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistDeploymentStatusesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistDeploymentStatusesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DeploymentStatus
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetDeploymentStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeploymentStatus
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetDeploymentStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetDeploymentStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateDispatchEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateDispatchEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateDispatchEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAllEnvironmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Environments *[]Environment `json:"environments,omitempty"`

		// The number of environments in this repository
		TotalCount *int `json:"total_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReposgetAllEnvironmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAllEnvironmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteAnEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteAnEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteAnEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
}

// Status returns HTTPResponse.Status
func (r ReposgetEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateOrUpdateEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON422      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposcreateOrUpdateEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateOrUpdateEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistRepoEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistRepoEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistRepoEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistForksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON400      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistForksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistForksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateForkResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *FullRepository
	JSON400      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateForkResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateForkResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitcreateBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ShortBlob
	JSON403      *BasicError
	JSON404      *BasicError
	JSON409      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitcreateBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitcreateBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitgetBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blob
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitgetBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitgetBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitcreateCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GitCommit
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitcreateCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitcreateCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitgetCommitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitCommit
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GitgetCommitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitgetCommitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitlistMatchingRefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GitRef
}

// Status returns HTTPResponse.Status
func (r GitlistMatchingRefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitlistMatchingRefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitgetRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRef
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GitgetRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitgetRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitcreateRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GitRef
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitcreateRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitcreateRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitdeleteRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitdeleteRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitdeleteRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitupdateRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitRef
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitupdateRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitupdateRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitcreateTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GitTag
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitcreateTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitcreateTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitgetTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitTag
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r GitgetTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitgetTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitcreateTreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GitTree
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitcreateTreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitcreateTreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GitgetTreeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitTree
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GitgetTreeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GitgetTreeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Hook
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Hook
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Hook
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Hook
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposupdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetWebhookConfigForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r ReposgetWebhookConfigForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetWebhookConfigForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateWebhookConfigForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookConfig
}

// Status returns HTTPResponse.Status
func (r ReposupdateWebhookConfigForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateWebhookConfigForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistWebhookDeliveriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]HookDeliveryItem
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposlistWebhookDeliveriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistWebhookDeliveriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HookDelivery
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposgetWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposredeliverWebhookDeliveryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposredeliverWebhookDeliveryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposredeliverWebhookDeliveryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepospingWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r RepospingWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepospingWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepostestPushWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r RepostestPushWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepostestPushWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationscancelImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MigrationscancelImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationscancelImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetImportStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Import
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsgetImportStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetImportStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsupdateImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Import
}

// Status returns HTTPResponse.Status
func (r MigrationsupdateImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsupdateImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsstartImportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Import
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r MigrationsstartImportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsstartImportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetCommitAuthorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PorterAuthor
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsgetCommitAuthorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetCommitAuthorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsmapCommitAuthorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PorterAuthor
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r MigrationsmapCommitAuthorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsmapCommitAuthorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetLargeFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PorterLargeFile
}

// Status returns HTTPResponse.Status
func (r MigrationsgetLargeFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetLargeFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationssetLfsPreferenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Import
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r MigrationssetLfsPreferenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationssetLfsPreferenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetRepoInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Installation
	JSON301      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsgetRepoInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetRepoInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsremoveRestrictionsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InteractionsremoveRestrictionsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsremoveRestrictionsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsgetRestrictionsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r InteractionsgetRestrictionsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsgetRestrictionsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionssetRestrictionsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InteractionLimitResponse
}

// Status returns HTTPResponse.Status
func (r InteractionssetRestrictionsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionssetRestrictionsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistInvitationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RepositoryInvitation
}

// Status returns HTTPResponse.Status
func (r ReposlistInvitationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistInvitationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositoryInvitation
}

// Status returns HTTPResponse.Status
func (r ReposupdateInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Issue
	JSON301      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssueslistForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuescreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Issue
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuescreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuescreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistCommentsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IssueComment
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssueslistCommentsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistCommentsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesdeleteCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IssuesdeleteCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesdeleteCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesgetCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesgetCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesgetCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesupdateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueComment
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuesupdateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesupdateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForIssueCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReactionslistForIssueCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForIssueCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForIssueCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForIssueCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForIssueCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForIssueCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForIssueCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForIssueCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistEventsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IssueEvent
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssueslistEventsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistEventsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesgetEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueEvent
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesgetEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesgetEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issue
	JSON301      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issue
	JSON301      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationError
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IssuesupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesremoveAssigneesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issue
}

// Status returns HTTPResponse.Status
func (r IssuesremoveAssigneesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesremoveAssigneesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesaddAssigneesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Issue
}

// Status returns HTTPResponse.Status
func (r IssuesaddAssigneesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesaddAssigneesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IssueComment
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuescreateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IssueComment
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuescreateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuescreateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]IssueEventForIssue
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesremoveAllLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesremoveAllLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesremoveAllLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistLabelsOnIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistLabelsOnIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistLabelsOnIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesaddLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
	JSON410      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuesaddLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesaddLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuessetLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
	JSON410      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuessetLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuessetLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesremoveLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesremoveLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesremoveLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesunlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesunlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesunlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssueslockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReactionslistForIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistEventsForTimelineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TimelineIssueEvents
	JSON404      *BasicError
	JSON410      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistEventsForTimelineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistEventsForTimelineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistDeployKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DeployKey
}

// Status returns HTTPResponse.Status
func (r ReposlistDeployKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistDeployKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateDeployKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DeployKey
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateDeployKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateDeployKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteDeployKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteDeployKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteDeployKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetDeployKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeployKey
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetDeployKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetDeployKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistLabelsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistLabelsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistLabelsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuescreateLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Label
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuescreateLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuescreateLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesdeleteLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IssuesdeleteLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesdeleteLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesgetLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Label
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesgetLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesgetLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesupdateLabelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Label
}

// Status returns HTTPResponse.Status
func (r IssuesupdateLabelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesupdateLabelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistLanguagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Language
}

// Status returns HTTPResponse.Status
func (r ReposlistLanguagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistLanguagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdisableLfsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdisableLfsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdisableLfsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposenableLfsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ReposenableLfsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposenableLfsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LicensesgetForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LicenseContent
}

// Status returns HTTPResponse.Status
func (r LicensesgetForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LicensesgetForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposmergeUpstreamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MergedUpstream
}

// Status returns HTTPResponse.Status
func (r ReposmergeUpstreamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposmergeUpstreamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposmergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Commit
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposmergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposmergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistMilestonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Milestone
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistMilestonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistMilestonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuescreateMilestoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Milestone
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r IssuescreateMilestoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuescreateMilestoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesdeleteMilestoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesdeleteMilestoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesdeleteMilestoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesgetMilestoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Milestone
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssuesgetMilestoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesgetMilestoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesupdateMilestoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Milestone
}

// Status returns HTTPResponse.Status
func (r IssuesupdateMilestoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesupdateMilestoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistLabelsForMilestoneResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Label
}

// Status returns HTTPResponse.Status
func (r IssueslistLabelsForMilestoneResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistLabelsForMilestoneResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistRepoNotificationsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Thread
}

// Status returns HTTPResponse.Status
func (r ActivitylistRepoNotificationsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistRepoNotificationsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitymarkRepoNotificationsAsReadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
		Url     *string `json:"url,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ActivitymarkRepoNotificationsAsReadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitymarkRepoNotificationsAsReadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeletePagesSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposdeletePagesSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeletePagesSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetPagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Page
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetPagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetPagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreatePagesSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Page
	JSON409      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreatePagesSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreatePagesSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateInformationAboutPagesSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposupdateInformationAboutPagesSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateInformationAboutPagesSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistPagesBuildsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PageBuild
}

// Status returns HTTPResponse.Status
func (r ReposlistPagesBuildsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistPagesBuildsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposrequestPagesBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PageBuildStatus
}

// Status returns HTTPResponse.Status
func (r ReposrequestPagesBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposrequestPagesBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetLatestPagesBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageBuild
}

// Status returns HTTPResponse.Status
func (r ReposgetLatestPagesBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetLatestPagesBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetPagesBuildResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PageBuild
}

// Status returns HTTPResponse.Status
func (r ReposgetPagesBuildResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetPagesBuildResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetPagesHealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PagesHealthCheck
	JSON202      *EmptyObject
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetPagesHealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetPagesHealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Project
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectslistForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectscreateForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON410      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectscreateForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectscreateForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PullRequestSimple
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullscreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequest
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullscreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullscreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistReviewCommentsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PullRequestReviewComment
}

// Status returns HTTPResponse.Status
func (r PullslistReviewCommentsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistReviewCommentsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsdeleteReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullsdeleteReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsdeleteReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsgetReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReviewComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullsgetReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsgetReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsupdateReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReviewComment
}

// Status returns HTTPResponse.Status
func (r PullsupdateReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsupdateReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForPullRequestReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReactionslistForPullRequestReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForPullRequestReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForPullRequestReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForPullRequestReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForPullRequestReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForPullRequestCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForPullRequestCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForPullRequestCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsgetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullsgetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsgetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsupdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequest
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullsupdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsupdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescreateWithPrForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Codespace
	JSON202      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacescreateWithPrForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescreateWithPrForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistReviewCommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PullRequestReviewComment
}

// Status returns HTTPResponse.Status
func (r PullslistReviewCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistReviewCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullscreateReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequestReviewComment
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullscreateReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullscreateReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullscreateReplyForReviewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequestReviewComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullscreateReplyForReviewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullscreateReplyForReviewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistCommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Commit
}

// Status returns HTTPResponse.Status
func (r PullslistCommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistCommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]DiffEntry
	JSON422      *ValidationError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullslistFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullscheckIfMergedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PullscheckIfMergedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullscheckIfMergedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsmergeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestMergeResult
	JSON403      *BasicError
	JSON404      *BasicError
	JSON405      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON409 *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON422 *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullsmergeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsmergeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsremoveRequestedReviewersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestSimple
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullsremoveRequestedReviewersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsremoveRequestedReviewersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistRequestedReviewersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReviewRequest
}

// Status returns HTTPResponse.Status
func (r PullslistRequestedReviewersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistRequestedReviewersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsrequestReviewersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PullRequestSimple
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullsrequestReviewersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsrequestReviewersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PullRequestReview
}

// Status returns HTTPResponse.Status
func (r PullslistReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullscreateReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON403      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r PullscreateReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullscreateReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsdeletePendingReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r PullsdeletePendingReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsdeletePendingReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsgetReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullsgetReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsgetReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsupdateReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r PullsupdateReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsupdateReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullslistCommentsForReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ReviewComment
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PullslistCommentsForReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullslistCommentsForReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsdismissReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r PullsdismissReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsdismissReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullssubmitReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PullRequestReview
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r PullssubmitReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullssubmitReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PullsupdateBranchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *struct {
		Message *string `json:"message,omitempty"`
		Url     *string `json:"url,omitempty"`
	}
	JSON403 *BasicError
	JSON422 *ValidationError
}

// Status returns HTTPResponse.Status
func (r PullsupdateBranchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PullsupdateBranchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetReadmeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentFile
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposgetReadmeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetReadmeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetReadmeInDirectoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContentFile
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposgetReadmeInDirectoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetReadmeInDirectoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistReleasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Release
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistReleasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistReleasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Release
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteReleaseAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteReleaseAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteReleaseAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetReleaseAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReleaseAsset
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetReleaseAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetReleaseAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateReleaseAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReleaseAsset
}

// Status returns HTTPResponse.Status
func (r ReposupdateReleaseAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateReleaseAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgenerateReleaseNotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReleaseNotesContent
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgenerateReleaseNotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgenerateReleaseNotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetLatestReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
}

// Status returns HTTPResponse.Status
func (r ReposgetLatestReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetLatestReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetReleaseByTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetReleaseByTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetReleaseByTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdeleteReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposupdateReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Release
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposupdateReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposupdateReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistReleaseAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ReleaseAsset
}

// Status returns HTTPResponse.Status
func (r ReposlistReleaseAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistReleaseAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposuploadReleaseAssetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ReleaseAsset
}

// Status returns HTTPResponse.Status
func (r ReposuploadReleaseAssetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposuploadReleaseAssetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReactionslistForReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reaction
	JSON201      *Reaction
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionsdeleteForReleaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReactionsdeleteForReleaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionsdeleteForReleaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanninglistAlertsForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SecretScanningAlert
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanninglistAlertsForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanninglistAlertsForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanninggetAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecretScanningAlert
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanninggetAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanninggetAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanningupdateAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecretScanningAlert
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanningupdateAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanningupdateAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SecretScanninglistLocationsForAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SecretScanningLocation
	JSON503      *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SecretScanninglistLocationsForAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SecretScanninglistLocationsForAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistStargazersForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ActivitylistStargazersForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistStargazersForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCodeFrequencyStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeFrequencyStat
	JSON202      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ReposgetCodeFrequencyStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCodeFrequencyStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetCommitActivityStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CommitActivity
	JSON202      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ReposgetCommitActivityStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetCommitActivityStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetContributorsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ContributorActivity
	JSON202      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r ReposgetContributorsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetContributorsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetParticipationStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ParticipationStats
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetParticipationStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetParticipationStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetPunchCardStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CodeFrequencyStat
}

// Status returns HTTPResponse.Status
func (r ReposgetPunchCardStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetPunchCardStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateCommitStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Status
}

// Status returns HTTPResponse.Status
func (r ReposcreateCommitStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateCommitStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistWatchersForRepoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r ActivitylistWatchersForRepoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistWatchersForRepoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitydeleteRepoSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActivitydeleteRepoSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitydeleteRepoSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitygetRepoSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositorySubscription
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitygetRepoSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitygetRepoSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitysetRepoSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RepositorySubscription
}

// Status returns HTTPResponse.Status
func (r ActivitysetRepoSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitysetRepoSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Tag
}

// Status returns HTTPResponse.Status
func (r ReposlistTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistTagProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TagProtection
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistTagProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistTagProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateTagProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TagProtection
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposcreateTagProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateTagProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeleteTagProtectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeleteTagProtectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeleteTagProtectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdownloadTarballArchiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdownloadTarballArchiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdownloadTarballArchiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
}

// Status returns HTTPResponse.Status
func (r ReposlistTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetAllTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Topic
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetAllTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetAllTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposreplaceAllTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Topic
	JSON404      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ReposreplaceAllTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposreplaceAllTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetClonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CloneTraffic
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetClonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetClonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetTopPathsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ContentTraffic
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetTopPathsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetTopPathsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetTopReferrersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ReferrerTraffic
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetTopReferrersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetTopReferrersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposgetViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ViewTraffic
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposgetViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposgetViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RepostransferResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *MinimalRepository
}

// Status returns HTTPResponse.Status
func (r RepostransferResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RepostransferResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdisableVulnerabilityAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdisableVulnerabilityAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdisableVulnerabilityAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcheckVulnerabilityAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposcheckVulnerabilityAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcheckVulnerabilityAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposenableVulnerabilityAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposenableVulnerabilityAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposenableVulnerabilityAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdownloadZipballArchiveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReposdownloadZipballArchiveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdownloadZipballArchiveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateUsingTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
}

// Status returns HTTPResponse.Status
func (r ReposcreateUsingTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateUsingTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistPublicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposlistPublicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistPublicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionslistEnvironmentSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []ActionsSecret `json:"secrets"`
		TotalCount int             `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r ActionslistEnvironmentSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionslistEnvironmentSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetEnvironmentPublicKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsPublicKey
}

// Status returns HTTPResponse.Status
func (r ActionsgetEnvironmentPublicKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetEnvironmentPublicKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsdeleteEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ActionsdeleteEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsdeleteEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionsgetEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsSecret
}

// Status returns HTTPResponse.Status
func (r ActionsgetEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionsgetEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActionscreateOrUpdateEnvironmentSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EmptyObject
}

// Status returns HTTPResponse.Status
func (r ActionscreateOrUpdateEnvironmentSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActionscreateOrUpdateEnvironmentSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistProvisionedGroupsEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimGroupListEnterprise
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistProvisionedGroupsEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistProvisionedGroupsEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ScimEnterpriseGroup
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmindeleteScimGroupFromEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmindeleteScimGroupFromEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmindeleteScimGroupFromEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseGroup
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminupdateAttributeForEnterpriseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseGroup
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminupdateAttributeForEnterpriseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminupdateAttributeForEnterpriseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseGroup
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimUserListEnterprise
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminprovisionAndInviteEnterpriseUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ScimEnterpriseUser
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminprovisionAndInviteEnterpriseUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminprovisionAndInviteEnterpriseUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmindeleteUserFromEnterpriseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmindeleteUserFromEnterpriseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmindeleteUserFromEnterpriseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseUser
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminupdateAttributeForEnterpriseUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseUser
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminupdateAttributeForEnterpriseUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminupdateAttributeForEnterpriseUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScimEnterpriseUser
}

// Status returns HTTPResponse.Status
func (r EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimlistProvisionedIdentitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ScimError
	JSON403      *ScimError
	JSON404      *ScimError
	JSON429      *ScimError
}

// Status returns HTTPResponse.Status
func (r ScimlistProvisionedIdentitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimlistProvisionedIdentitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimprovisionAndInviteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ScimError
	JSON403      *ScimError
	JSON404      *ScimError
	JSON409      *ScimError
	JSON500      *ScimError
}

// Status returns HTTPResponse.Status
func (r ScimprovisionAndInviteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimprovisionAndInviteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimdeleteUserFromOrgResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ScimError
	JSON404      *ScimError
}

// Status returns HTTPResponse.Status
func (r ScimdeleteUserFromOrgResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimdeleteUserFromOrgResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimgetProvisioningInformationForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ScimError
	JSON404      *ScimError
}

// Status returns HTTPResponse.Status
func (r ScimgetProvisioningInformationForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimgetProvisioningInformationForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimupdateAttributeForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ScimError
	JSON403      *ScimError
	JSON404      *ScimError
	JSON429      *BasicError
}

// Status returns HTTPResponse.Status
func (r ScimupdateAttributeForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimupdateAttributeForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScimsetInformationForProvisionedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ScimError
	JSON404      *ScimError
}

// Status returns HTTPResponse.Status
func (r ScimsetInformationForProvisionedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScimsetInformationForProvisionedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchcodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                   `json:"incomplete_results"`
		Items             []CodeSearchResultItem `json:"items"`
		TotalCount        int                    `json:"total_count"`
	}
	JSON403 *BasicError
	JSON422 *ValidationError
	JSON503 *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchcodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchcodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchcommitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                     `json:"incomplete_results"`
		Items             []CommitSearchResultItem `json:"items"`
		TotalCount        int                      `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchcommitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchcommitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchissuesAndPullRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                    `json:"incomplete_results"`
		Items             []IssueSearchResultItem `json:"items"`
		TotalCount        int                     `json:"total_count"`
	}
	JSON403 *BasicError
	JSON422 *ValidationError
	JSON503 *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchissuesAndPullRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchissuesAndPullRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchlabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                    `json:"incomplete_results"`
		Items             []LabelSearchResultItem `json:"items"`
		TotalCount        int                     `json:"total_count"`
	}
	JSON403 *BasicError
	JSON404 *BasicError
	JSON422 *ValidationError
}

// Status returns HTTPResponse.Status
func (r SearchlabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchlabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchreposResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                   `json:"incomplete_results"`
		Items             []RepoSearchResultItem `json:"items"`
		TotalCount        int                    `json:"total_count"`
	}
	JSON422 *ValidationError
	JSON503 *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchreposResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchreposResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchtopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                    `json:"incomplete_results"`
		Items             []TopicSearchResultItem `json:"items"`
		TotalCount        int                     `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchtopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchtopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchusersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IncompleteResults bool                   `json:"incomplete_results"`
		Items             []UserSearchResultItem `json:"items"`
		TotalCount        int                    `json:"total_count"`
	}
	JSON422 *ValidationError
	JSON503 *struct {
		Code             *string `json:"code,omitempty"`
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SearchusersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchusersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamFull
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamsgetLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamFull
	JSON201      *TeamFull
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamsupdateLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistDiscussionsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamslistDiscussionsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistDiscussionsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamscreateDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamsgetDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussion
}

// Status returns HTTPResponse.Status
func (r TeamsupdateDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistDiscussionCommentsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamslistDiscussionCommentsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistDiscussionCommentsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamscreateDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsdeleteDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsdeleteDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsdeleteDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamsgetDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsupdateDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamDiscussionComment
}

// Status returns HTTPResponse.Status
func (r TeamsupdateDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsupdateDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForTeamDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionslistForTeamDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForTeamDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForTeamDiscussionCommentLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForTeamDiscussionCommentLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForTeamDiscussionCommentLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionslistForTeamDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionslistForTeamDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionslistForTeamDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReactionscreateForTeamDiscussionLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Reaction
}

// Status returns HTTPResponse.Status
func (r ReactionscreateForTeamDiscussionLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReactionscreateForTeamDiscussionLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistPendingInvitationsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationInvitation
}

// Status returns HTTPResponse.Status
func (r TeamslistPendingInvitationsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistPendingInvitationsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistMembersLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistMembersLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistMembersLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveMemberLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveMemberLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveMemberLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetMemberLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsgetMemberLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetMemberLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddMemberLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamsaddMemberLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddMemberLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveMembershipForUserLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveMembershipForUserLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveMembershipForUserLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsgetMembershipForUserLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMembership
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamsgetMembershipForUserLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsgetMembershipForUserLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateMembershipForUserLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamMembership
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateMembershipForUserLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateMembershipForUserLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistProjectsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamProject
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistProjectsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistProjectsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveProjectLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamsremoveProjectLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveProjectLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscheckPermissionsForProjectLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamProject
}

// Status returns HTTPResponse.Status
func (r TeamscheckPermissionsForProjectLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscheckPermissionsForProjectLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateProjectPermissionsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *struct {
		DocumentationUrl *string `json:"documentation_url,omitempty"`
		Message          *string `json:"message,omitempty"`
	}
	JSON404 *BasicError
	JSON422 *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateProjectPermissionsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateProjectPermissionsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistReposLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistReposLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistReposLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsremoveRepoLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TeamsremoveRepoLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsremoveRepoLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscheckPermissionsForRepoLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamRepository
}

// Status returns HTTPResponse.Status
func (r TeamscheckPermissionsForRepoLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscheckPermissionsForRepoLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamsaddOrUpdateRepoPermissionsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamsaddOrUpdateRepoPermissionsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamsaddOrUpdateRepoPermissionsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistIdpGroupsForLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMapping
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistIdpGroupsForLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistIdpGroupsForLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMapping
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistChildLegacyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Team
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r TeamslistChildLegacyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistChildLegacyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersgetAuthenticatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersgetAuthenticatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersgetAuthenticatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersupdateAuthenticatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrivateUser
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersupdateAuthenticatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersupdateAuthenticatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistBlockedByAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistBlockedByAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistBlockedByAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersunblockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersunblockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersunblockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserscheckBlockedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserscheckBlockedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserscheckBlockedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersblockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersblockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersblockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Codespaces []Codespace `json:"codespaces"`
		TotalCount int         `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespaceslistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescreateForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Codespace
	JSON202      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacescreateForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescreateForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistSecretsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Secrets    []CodespacesSecret `json:"secrets"`
		TotalCount int                `json:"total_count"`
	}
}

// Status returns HTTPResponse.Status
func (r CodespaceslistSecretsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistSecretsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetPublicKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodespacesUserPublicKey
}

// Status returns HTTPResponse.Status
func (r CodespacesgetPublicKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetPublicKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesdeleteSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CodespacesdeleteSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesdeleteSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodespacesSecret
}

// Status returns HTTPResponse.Status
func (r CodespacesgetSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescreateOrUpdateSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *map[string]interface{}
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r CodespacescreateOrUpdateSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescreateOrUpdateSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories []MinimalRepository `json:"repositories"`
		TotalCount   int                 `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacessetRepositoriesForSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacessetRepositoriesForSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacessetRepositoriesForSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesaddRepositoryForSecretForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesaddRepositoryForSecretForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesaddRepositoryForSecretForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesdeleteForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *map[string]interface{}
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesdeleteForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesdeleteForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesgetForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesupdateForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesupdateForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesupdateForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesexportForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CodespaceExportDetails
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesexportForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesexportForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesgetExportDetailsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CodespaceExportDetails
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesgetExportDetailsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesgetExportDetailsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacescodespaceMachinesForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Machines   []CodespaceMachine `json:"machines"`
		TotalCount int                `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
	JSON404 *BasicError
	JSON500 *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacescodespaceMachinesForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacescodespaceMachinesForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesstartForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Codespace
	JSON400      *BasicError
	JSON401      *BasicError
	JSON402      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON409      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesstartForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesstartForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CodespacesstopForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Codespace
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON500      *BasicError
}

// Status returns HTTPResponse.Status
func (r CodespacesstopForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CodespacesstopForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Email
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersdeleteEmailForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersdeleteEmailForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersdeleteEmailForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistEmailsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Email
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistEmailsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistEmailsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersaddEmailForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *[]Email
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersaddEmailForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersaddEmailForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistFollowersForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistFollowersForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistFollowersForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistFollowedByAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistFollowedByAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistFollowedByAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersunfollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersunfollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersunfollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserscheckPersonIsFollowedByAuthenticatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserscheckPersonIsFollowedByAuthenticatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserscheckPersonIsFollowedByAuthenticatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersfollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersfollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersfollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistGpgKeysForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GpgKey
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistGpgKeysForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistGpgKeysForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserscreateGpgKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GpgKey
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UserscreateGpgKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserscreateGpgKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersdeleteGpgKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersdeleteGpgKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersdeleteGpgKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersgetGpgKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GpgKey
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersgetGpgKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersgetGpgKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistInstallationsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Installations []Installation `json:"installations"`
		TotalCount    int            `json:"total_count"`
	}
	JSON401 *BasicError
	JSON403 *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistInstallationsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistInstallationsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistInstallationReposForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Repositories        []Repository `json:"repositories"`
		RepositorySelection *string      `json:"repository_selection,omitempty"`
		TotalCount          int          `json:"total_count"`
	}
	JSON403 *BasicError
	JSON404 *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistInstallationReposForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistInstallationReposForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsremoveRepoFromInstallationForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsremoveRepoFromInstallationForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsremoveRepoFromInstallationForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsaddRepoToInstallationForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppsaddRepoToInstallationForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsaddRepoToInstallationForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsremoveRestrictionsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InteractionsremoveRestrictionsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsremoveRestrictionsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionsgetRestrictionsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r InteractionsgetRestrictionsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionsgetRestrictionsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InteractionssetRestrictionsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InteractionLimitResponse
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r InteractionssetRestrictionsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InteractionssetRestrictionsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssueslistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Issue
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r IssueslistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssueslistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistPublicSshKeysForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Key
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistPublicSshKeysForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistPublicSshKeysForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserscreatePublicSshKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Key
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UserscreatePublicSshKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserscreatePublicSshKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersdeletePublicSshKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersdeletePublicSshKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersdeletePublicSshKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersgetPublicSshKeyForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Key
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersgetPublicSshKeyForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersgetPublicSshKeyForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistSubscriptionsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserMarketplacePurchase
	JSON401      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistSubscriptionsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistSubscriptionsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppslistSubscriptionsForAuthenticatedUserStubbedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]UserMarketplacePurchase
	JSON401      *BasicError
}

// Status returns HTTPResponse.Status
func (r AppslistSubscriptionsForAuthenticatedUserStubbedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppslistSubscriptionsForAuthenticatedUserStubbedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistMembershipsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrgMembership
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgslistMembershipsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistMembershipsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsgetMembershipForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgMembership
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgsgetMembershipForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsgetMembershipForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgsupdateMembershipForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrgMembership
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r OrgsupdateMembershipForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgsupdateMembershipForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationslistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Migration
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationslistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationslistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsstartForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Migration
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r MigrationsstartForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsstartForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetStatusForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Migration
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsgetStatusForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetStatusForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsdeleteArchiveForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsdeleteArchiveForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsdeleteArchiveForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsgetArchiveForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsgetArchiveForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsgetArchiveForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationsunlockRepoForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationsunlockRepoForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationsunlockRepoForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MigrationslistReposForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r MigrationslistReposForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MigrationslistReposForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationSimple
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r OrgslistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackageslistPackagesForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r PackageslistPackagesForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackageslistPackagesForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageVersion
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageVersionForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageVersionForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageVersionForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageVersionForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageVersion
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageVersionForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageVersionForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageVersionForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageVersionForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageVersionForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectscreateForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationErrorSimple
}

// Status returns HTTPResponse.Status
func (r ProjectscreateForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectscreateForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistPublicEmailsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Email
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UserslistPublicEmailsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistPublicEmailsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Repository
	JSON401      *BasicError
	JSON403      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposlistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposcreateForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Repository
	JSON400      *BasicError
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ReposcreateForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposcreateForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistInvitationsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]RepositoryInvitation
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposlistInvitationsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistInvitationsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposdeclineInvitationForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
	JSON409      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposdeclineInvitationForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposdeclineInvitationForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposacceptInvitationForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *BasicError
	JSON404      *BasicError
	JSON409      *BasicError
}

// Status returns HTTPResponse.Status
func (r ReposacceptInvitationForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposacceptInvitationForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistReposStarredByAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Repository
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitylistReposStarredByAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistReposStarredByAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivityunstarRepoForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivityunstarRepoForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivityunstarRepoForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitycheckRepoIsStarredByAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitycheckRepoIsStarredByAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitycheckRepoIsStarredByAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitystarRepoForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitystarRepoForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitystarRepoForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistWatchedReposForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r ActivitylistWatchedReposForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistWatchedReposForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TeamslistForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]TeamFull
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r TeamslistForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TeamslistForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r UserslistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersgetByUsernameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r UsersgetByUsernameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersgetByUsernameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistEventsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistEventsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistEventsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistOrgEventsForAuthenticatedUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistOrgEventsForAuthenticatedUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistOrgEventsForAuthenticatedUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistPublicEventsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistPublicEventsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistPublicEventsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistFollowersForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r UserslistFollowersForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistFollowersForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistFollowingForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]SimpleUser
}

// Status returns HTTPResponse.Status
func (r UserslistFollowingForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistFollowingForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserscheckFollowingForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserscheckFollowingForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserscheckFollowingForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GistslistForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BaseGist
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r GistslistForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GistslistForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistGpgKeysForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GpgKey
}

// Status returns HTTPResponse.Status
func (r UserslistGpgKeysForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistGpgKeysForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersgetContextForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Hovercard
	JSON404      *BasicError
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r UsersgetContextForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersgetContextForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AppsgetUserInstallationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Installation
}

// Status returns HTTPResponse.Status
func (r AppsgetUserInstallationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AppsgetUserInstallationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserslistPublicKeysForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]KeySimple
}

// Status returns HTTPResponse.Status
func (r UserslistPublicKeysForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserslistPublicKeysForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type OrgslistForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OrganizationSimple
}

// Status returns HTTPResponse.Status
func (r OrgslistForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r OrgslistForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackageslistPackagesForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
	JSON401      *BasicError
	JSON403      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackageslistPackagesForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackageslistPackagesForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetAllPackageVersionsForPackageOwnedByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageVersion
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesgetAllPackageVersionsForPackageOwnedByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetAllPackageVersionsForPackageOwnedByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesdeletePackageVersionForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesdeletePackageVersionForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesdeletePackageVersionForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesgetPackageVersionForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageVersion
}

// Status returns HTTPResponse.Status
func (r PackagesgetPackageVersionForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesgetPackageVersionForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PackagesrestorePackageVersionForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *BasicError
	JSON403      *BasicError
	JSON404      *BasicError
}

// Status returns HTTPResponse.Status
func (r PackagesrestorePackageVersionForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PackagesrestorePackageVersionForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectslistForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Project
	JSON422      *ValidationError
}

// Status returns HTTPResponse.Status
func (r ProjectslistForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectslistForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistReceivedEventsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistReceivedEventsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistReceivedEventsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistReceivedPublicEventsForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Event
}

// Status returns HTTPResponse.Status
func (r ActivitylistReceivedPublicEventsForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistReceivedPublicEventsForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReposlistForUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
}

// Status returns HTTPResponse.Status
func (r ReposlistForUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReposlistForUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubActionsBillingUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionsBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubActionsBillingUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubActionsBillingUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetGithubPackagesBillingUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackagesBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetGithubPackagesBillingUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetGithubPackagesBillingUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BillinggetSharedStorageBillingUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CombinedBillingUsage
}

// Status returns HTTPResponse.Status
func (r BillinggetSharedStorageBillingUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BillinggetSharedStorageBillingUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistReposStarredByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r ActivitylistReposStarredByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistReposStarredByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ActivitylistReposWatchedByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]MinimalRepository
}

// Status returns HTTPResponse.Status
func (r ActivitylistReposWatchedByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ActivitylistReposWatchedByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MetagetZenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MetagetZenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MetagetZenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// MetarootWithResponse request returning *MetarootResponse
func (c *ClientWithResponses) MetarootWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetarootResponse, error) {
	rsp, err := c.Metaroot(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetarootResponse(rsp)
}

// AppsgetAuthenticatedWithResponse request returning *AppsgetAuthenticatedResponse
func (c *ClientWithResponses) AppsgetAuthenticatedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsgetAuthenticatedResponse, error) {
	rsp, err := c.AppsgetAuthenticated(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetAuthenticatedResponse(rsp)
}

// AppscreateFromManifestWithResponse request returning *AppscreateFromManifestResponse
func (c *ClientWithResponses) AppscreateFromManifestWithResponse(ctx context.Context, code string, reqEditors ...RequestEditorFn) (*AppscreateFromManifestResponse, error) {
	rsp, err := c.AppscreateFromManifest(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppscreateFromManifestResponse(rsp)
}

// AppsgetWebhookConfigForAppWithResponse request returning *AppsgetWebhookConfigForAppResponse
func (c *ClientWithResponses) AppsgetWebhookConfigForAppWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsgetWebhookConfigForAppResponse, error) {
	rsp, err := c.AppsgetWebhookConfigForApp(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetWebhookConfigForAppResponse(rsp)
}

// AppsupdateWebhookConfigForAppWithBodyWithResponse request with arbitrary body returning *AppsupdateWebhookConfigForAppResponse
func (c *ClientWithResponses) AppsupdateWebhookConfigForAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsupdateWebhookConfigForAppResponse, error) {
	rsp, err := c.AppsupdateWebhookConfigForAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsupdateWebhookConfigForAppResponse(rsp)
}

func (c *ClientWithResponses) AppsupdateWebhookConfigForAppWithResponse(ctx context.Context, body AppsupdateWebhookConfigForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsupdateWebhookConfigForAppResponse, error) {
	rsp, err := c.AppsupdateWebhookConfigForApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsupdateWebhookConfigForAppResponse(rsp)
}

// AppslistWebhookDeliveriesWithResponse request returning *AppslistWebhookDeliveriesResponse
func (c *ClientWithResponses) AppslistWebhookDeliveriesWithResponse(ctx context.Context, params *AppslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*AppslistWebhookDeliveriesResponse, error) {
	rsp, err := c.AppslistWebhookDeliveries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistWebhookDeliveriesResponse(rsp)
}

// AppsgetWebhookDeliveryWithResponse request returning *AppsgetWebhookDeliveryResponse
func (c *ClientWithResponses) AppsgetWebhookDeliveryWithResponse(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*AppsgetWebhookDeliveryResponse, error) {
	rsp, err := c.AppsgetWebhookDelivery(ctx, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetWebhookDeliveryResponse(rsp)
}

// AppsredeliverWebhookDeliveryWithResponse request returning *AppsredeliverWebhookDeliveryResponse
func (c *ClientWithResponses) AppsredeliverWebhookDeliveryWithResponse(ctx context.Context, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*AppsredeliverWebhookDeliveryResponse, error) {
	rsp, err := c.AppsredeliverWebhookDelivery(ctx, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsredeliverWebhookDeliveryResponse(rsp)
}

// AppslistInstallationsWithResponse request returning *AppslistInstallationsResponse
func (c *ClientWithResponses) AppslistInstallationsWithResponse(ctx context.Context, params *AppslistInstallationsParams, reqEditors ...RequestEditorFn) (*AppslistInstallationsResponse, error) {
	rsp, err := c.AppslistInstallations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistInstallationsResponse(rsp)
}

// AppsdeleteInstallationWithResponse request returning *AppsdeleteInstallationResponse
func (c *ClientWithResponses) AppsdeleteInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsdeleteInstallationResponse, error) {
	rsp, err := c.AppsdeleteInstallation(ctx, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsdeleteInstallationResponse(rsp)
}

// AppsgetInstallationWithResponse request returning *AppsgetInstallationResponse
func (c *ClientWithResponses) AppsgetInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsgetInstallationResponse, error) {
	rsp, err := c.AppsgetInstallation(ctx, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetInstallationResponse(rsp)
}

// AppscreateInstallationAccessTokenWithBodyWithResponse request with arbitrary body returning *AppscreateInstallationAccessTokenResponse
func (c *ClientWithResponses) AppscreateInstallationAccessTokenWithBodyWithResponse(ctx context.Context, installationId InstallationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppscreateInstallationAccessTokenResponse, error) {
	rsp, err := c.AppscreateInstallationAccessTokenWithBody(ctx, installationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppscreateInstallationAccessTokenResponse(rsp)
}

func (c *ClientWithResponses) AppscreateInstallationAccessTokenWithResponse(ctx context.Context, installationId InstallationId, body AppscreateInstallationAccessTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppscreateInstallationAccessTokenResponse, error) {
	rsp, err := c.AppscreateInstallationAccessToken(ctx, installationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppscreateInstallationAccessTokenResponse(rsp)
}

// AppsunsuspendInstallationWithResponse request returning *AppsunsuspendInstallationResponse
func (c *ClientWithResponses) AppsunsuspendInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppsunsuspendInstallationResponse, error) {
	rsp, err := c.AppsunsuspendInstallation(ctx, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsunsuspendInstallationResponse(rsp)
}

// AppssuspendInstallationWithResponse request returning *AppssuspendInstallationResponse
func (c *ClientWithResponses) AppssuspendInstallationWithResponse(ctx context.Context, installationId InstallationId, reqEditors ...RequestEditorFn) (*AppssuspendInstallationResponse, error) {
	rsp, err := c.AppssuspendInstallation(ctx, installationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppssuspendInstallationResponse(rsp)
}

// OauthAuthorizationslistGrantsWithResponse request returning *OauthAuthorizationslistGrantsResponse
func (c *ClientWithResponses) OauthAuthorizationslistGrantsWithResponse(ctx context.Context, params *OauthAuthorizationslistGrantsParams, reqEditors ...RequestEditorFn) (*OauthAuthorizationslistGrantsResponse, error) {
	rsp, err := c.OauthAuthorizationslistGrants(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationslistGrantsResponse(rsp)
}

// OauthAuthorizationsdeleteGrantWithResponse request returning *OauthAuthorizationsdeleteGrantResponse
func (c *ClientWithResponses) OauthAuthorizationsdeleteGrantWithResponse(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsdeleteGrantResponse, error) {
	rsp, err := c.OauthAuthorizationsdeleteGrant(ctx, grantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsdeleteGrantResponse(rsp)
}

// OauthAuthorizationsgetGrantWithResponse request returning *OauthAuthorizationsgetGrantResponse
func (c *ClientWithResponses) OauthAuthorizationsgetGrantWithResponse(ctx context.Context, grantId GrantId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetGrantResponse, error) {
	rsp, err := c.OauthAuthorizationsgetGrant(ctx, grantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetGrantResponse(rsp)
}

// AppsdeleteAuthorizationWithBodyWithResponse request with arbitrary body returning *AppsdeleteAuthorizationResponse
func (c *ClientWithResponses) AppsdeleteAuthorizationWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsdeleteAuthorizationResponse, error) {
	rsp, err := c.AppsdeleteAuthorizationWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsdeleteAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) AppsdeleteAuthorizationWithResponse(ctx context.Context, clientId ClientId, body AppsdeleteAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsdeleteAuthorizationResponse, error) {
	rsp, err := c.AppsdeleteAuthorization(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsdeleteAuthorizationResponse(rsp)
}

// AppsdeleteTokenWithBodyWithResponse request with arbitrary body returning *AppsdeleteTokenResponse
func (c *ClientWithResponses) AppsdeleteTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsdeleteTokenResponse, error) {
	rsp, err := c.AppsdeleteTokenWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsdeleteTokenResponse(rsp)
}

func (c *ClientWithResponses) AppsdeleteTokenWithResponse(ctx context.Context, clientId ClientId, body AppsdeleteTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsdeleteTokenResponse, error) {
	rsp, err := c.AppsdeleteToken(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsdeleteTokenResponse(rsp)
}

// AppsresetTokenWithBodyWithResponse request with arbitrary body returning *AppsresetTokenResponse
func (c *ClientWithResponses) AppsresetTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsresetTokenResponse, error) {
	rsp, err := c.AppsresetTokenWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsresetTokenResponse(rsp)
}

func (c *ClientWithResponses) AppsresetTokenWithResponse(ctx context.Context, clientId ClientId, body AppsresetTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsresetTokenResponse, error) {
	rsp, err := c.AppsresetToken(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsresetTokenResponse(rsp)
}

// AppscheckTokenWithBodyWithResponse request with arbitrary body returning *AppscheckTokenResponse
func (c *ClientWithResponses) AppscheckTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppscheckTokenResponse, error) {
	rsp, err := c.AppscheckTokenWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppscheckTokenResponse(rsp)
}

func (c *ClientWithResponses) AppscheckTokenWithResponse(ctx context.Context, clientId ClientId, body AppscheckTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppscheckTokenResponse, error) {
	rsp, err := c.AppscheckToken(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppscheckTokenResponse(rsp)
}

// AppsscopeTokenWithBodyWithResponse request with arbitrary body returning *AppsscopeTokenResponse
func (c *ClientWithResponses) AppsscopeTokenWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AppsscopeTokenResponse, error) {
	rsp, err := c.AppsscopeTokenWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsscopeTokenResponse(rsp)
}

func (c *ClientWithResponses) AppsscopeTokenWithResponse(ctx context.Context, clientId ClientId, body AppsscopeTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*AppsscopeTokenResponse, error) {
	rsp, err := c.AppsscopeToken(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsscopeTokenResponse(rsp)
}

// AppsgetBySlugWithResponse request returning *AppsgetBySlugResponse
func (c *ClientWithResponses) AppsgetBySlugWithResponse(ctx context.Context, appSlug AppSlug, reqEditors ...RequestEditorFn) (*AppsgetBySlugResponse, error) {
	rsp, err := c.AppsgetBySlug(ctx, appSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetBySlugResponse(rsp)
}

// OauthAuthorizationslistAuthorizationsWithResponse request returning *OauthAuthorizationslistAuthorizationsResponse
func (c *ClientWithResponses) OauthAuthorizationslistAuthorizationsWithResponse(ctx context.Context, params *OauthAuthorizationslistAuthorizationsParams, reqEditors ...RequestEditorFn) (*OauthAuthorizationslistAuthorizationsResponse, error) {
	rsp, err := c.OauthAuthorizationslistAuthorizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationslistAuthorizationsResponse(rsp)
}

// OauthAuthorizationscreateAuthorizationWithBodyWithResponse request with arbitrary body returning *OauthAuthorizationscreateAuthorizationResponse
func (c *ClientWithResponses) OauthAuthorizationscreateAuthorizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationscreateAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationscreateAuthorizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationscreateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) OauthAuthorizationscreateAuthorizationWithResponse(ctx context.Context, body OauthAuthorizationscreateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationscreateAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationscreateAuthorization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationscreateAuthorizationResponse(rsp)
}

// OauthAuthorizationsgetOrCreateAuthorizationForAppWithBodyWithResponse request with arbitrary body returning *OauthAuthorizationsgetOrCreateAuthorizationForAppResponse
func (c *ClientWithResponses) OauthAuthorizationsgetOrCreateAuthorizationForAppWithBodyWithResponse(ctx context.Context, clientId ClientId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppResponse, error) {
	rsp, err := c.OauthAuthorizationsgetOrCreateAuthorizationForAppWithBody(ctx, clientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetOrCreateAuthorizationForAppResponse(rsp)
}

func (c *ClientWithResponses) OauthAuthorizationsgetOrCreateAuthorizationForAppWithResponse(ctx context.Context, clientId ClientId, body OauthAuthorizationsgetOrCreateAuthorizationForAppJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppResponse, error) {
	rsp, err := c.OauthAuthorizationsgetOrCreateAuthorizationForApp(ctx, clientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetOrCreateAuthorizationForAppResponse(rsp)
}

// OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBodyWithResponse request with arbitrary body returning *OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse
func (c *ClientWithResponses) OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBodyWithResponse(ctx context.Context, clientId ClientId, fingerprint string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	rsp, err := c.OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithBody(ctx, clientId, fingerprint, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse(rsp)
}

func (c *ClientWithResponses) OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithResponse(ctx context.Context, clientId ClientId, fingerprint string, body OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	rsp, err := c.OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprint(ctx, clientId, fingerprint, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse(rsp)
}

// OauthAuthorizationsdeleteAuthorizationWithResponse request returning *OauthAuthorizationsdeleteAuthorizationResponse
func (c *ClientWithResponses) OauthAuthorizationsdeleteAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsdeleteAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationsdeleteAuthorization(ctx, authorizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsdeleteAuthorizationResponse(rsp)
}

// OauthAuthorizationsgetAuthorizationWithResponse request returning *OauthAuthorizationsgetAuthorizationResponse
func (c *ClientWithResponses) OauthAuthorizationsgetAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, reqEditors ...RequestEditorFn) (*OauthAuthorizationsgetAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationsgetAuthorization(ctx, authorizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsgetAuthorizationResponse(rsp)
}

// OauthAuthorizationsupdateAuthorizationWithBodyWithResponse request with arbitrary body returning *OauthAuthorizationsupdateAuthorizationResponse
func (c *ClientWithResponses) OauthAuthorizationsupdateAuthorizationWithBodyWithResponse(ctx context.Context, authorizationId AuthorizationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OauthAuthorizationsupdateAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationsupdateAuthorizationWithBody(ctx, authorizationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsupdateAuthorizationResponse(rsp)
}

func (c *ClientWithResponses) OauthAuthorizationsupdateAuthorizationWithResponse(ctx context.Context, authorizationId AuthorizationId, body OauthAuthorizationsupdateAuthorizationJSONRequestBody, reqEditors ...RequestEditorFn) (*OauthAuthorizationsupdateAuthorizationResponse, error) {
	rsp, err := c.OauthAuthorizationsupdateAuthorization(ctx, authorizationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOauthAuthorizationsupdateAuthorizationResponse(rsp)
}

// CodesOfConductgetAllCodesOfConductWithResponse request returning *CodesOfConductgetAllCodesOfConductResponse
func (c *ClientWithResponses) CodesOfConductgetAllCodesOfConductWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CodesOfConductgetAllCodesOfConductResponse, error) {
	rsp, err := c.CodesOfConductgetAllCodesOfConduct(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodesOfConductgetAllCodesOfConductResponse(rsp)
}

// CodesOfConductgetConductCodeWithResponse request returning *CodesOfConductgetConductCodeResponse
func (c *ClientWithResponses) CodesOfConductgetConductCodeWithResponse(ctx context.Context, key string, reqEditors ...RequestEditorFn) (*CodesOfConductgetConductCodeResponse, error) {
	rsp, err := c.CodesOfConductgetConductCode(ctx, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodesOfConductgetConductCodeResponse(rsp)
}

// EmojisgetWithResponse request returning *EmojisgetResponse
func (c *ClientWithResponses) EmojisgetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EmojisgetResponse, error) {
	rsp, err := c.Emojisget(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmojisgetResponse(rsp)
}

// EnterpriseAdmingetServerStatisticsWithResponse request returning *EnterpriseAdmingetServerStatisticsResponse
func (c *ClientWithResponses) EnterpriseAdmingetServerStatisticsWithResponse(ctx context.Context, enterpriseOrOrg EnterpriseOrOrg, params *EnterpriseAdmingetServerStatisticsParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetServerStatisticsResponse, error) {
	rsp, err := c.EnterpriseAdmingetServerStatistics(ctx, enterpriseOrOrg, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetServerStatisticsResponse(rsp)
}

// ActionsgetActionsCacheUsageForEnterpriseWithResponse request returning *ActionsgetActionsCacheUsageForEnterpriseResponse
func (c *ClientWithResponses) ActionsgetActionsCacheUsageForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageForEnterpriseResponse, error) {
	rsp, err := c.ActionsgetActionsCacheUsageForEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetActionsCacheUsageForEnterpriseResponse(rsp)
}

// EnterpriseAdmingetGithubActionsPermissionsEnterpriseWithResponse request returning *EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmingetGithubActionsPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmingetGithubActionsPermissionsEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse(rsp)
}

// EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetGithubActionsPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetGithubActionsPermissionsEnterprise(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse(rsp)
}

// EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse request returning *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(rsp)
}

// EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterprise(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(rsp)
}

// EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseWithResponse request returning *EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterprise(ctx, enterprise, orgId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse(rsp)
}

// EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseWithResponse request returning *EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminenableSelectedOrganizationGithubActionsEnterprise(ctx, enterprise, orgId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse(rsp)
}

// EnterpriseAdmingetAllowedActionsEnterpriseWithResponse request returning *EnterpriseAdmingetAllowedActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmingetAllowedActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetAllowedActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmingetAllowedActionsEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetAllowedActionsEnterpriseResponse(rsp)
}

// EnterpriseAdminsetAllowedActionsEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetAllowedActionsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetAllowedActionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetAllowedActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetAllowedActionsEnterpriseWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetAllowedActionsEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetAllowedActionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminsetAllowedActionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetAllowedActionsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetAllowedActionsEnterprise(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetAllowedActionsEnterpriseResponse(rsp)
}

// ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse request returning *ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse
func (c *ClientWithResponses) ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error) {
	rsp, err := c.ActionsgetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse(rsp)
}

// ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBodyWithResponse request with arbitrary body returning *ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse
func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsEnterprise(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse(rsp)
}

// EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseWithResponse request returning *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistSelfHostedRunnerGroupsForEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse(rsp)
}

// EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmincreateSelfHostedRunnerGroupForEnterprise(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseWithResponse request returning *EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterprise(ctx, enterprise, runnerGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse(rsp)
}

// EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseWithResponse request returning *EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmingetSelfHostedRunnerGroupForEnterprise(ctx, enterprise, runnerGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithBody(ctx, enterprise, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminupdateSelfHostedRunnerGroupForEnterprise(ctx, enterprise, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse request returning *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, enterprise, runnerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp)
}

// EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithBody(ctx, enterprise, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, enterprise, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp)
}

// EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse request returning *EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, enterprise, runnerGroupId, orgId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp)
}

// EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse request returning *EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, orgId OrgId, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterprise(ctx, enterprise, runnerGroupId, orgId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp)
}

// EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseWithResponse request returning *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, params *EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistSelfHostedRunnersInGroupForEnterprise(ctx, enterprise, runnerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithBody(ctx, enterprise, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, body EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetSelfHostedRunnersInGroupForEnterprise(ctx, enterprise, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseWithResponse request returning *EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterprise(ctx, enterprise, runnerGroupId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseWithResponse request returning *EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminaddSelfHostedRunnerToGroupForEnterprise(ctx, enterprise, runnerGroupId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse(rsp)
}

// EnterpriseAdminlistSelfHostedRunnersForEnterpriseWithResponse request returning *EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistSelfHostedRunnersForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistSelfHostedRunnersForEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistSelfHostedRunnersForEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse(rsp)
}

// EnterpriseAdminlistRunnerApplicationsForEnterpriseWithResponse request returning *EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistRunnerApplicationsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistRunnerApplicationsForEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistRunnerApplicationsForEnterpriseResponse(rsp)
}

// EnterpriseAdmincreateRegistrationTokenForEnterpriseWithResponse request returning *EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmincreateRegistrationTokenForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmincreateRegistrationTokenForEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmincreateRegistrationTokenForEnterpriseResponse(rsp)
}

// EnterpriseAdmincreateRemoveTokenForEnterpriseWithResponse request returning *EnterpriseAdmincreateRemoveTokenForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmincreateRemoveTokenForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*EnterpriseAdmincreateRemoveTokenForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmincreateRemoveTokenForEnterprise(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmincreateRemoveTokenForEnterpriseResponse(rsp)
}

// EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseWithResponse request returning *EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmindeleteSelfHostedRunnerFromEnterprise(ctx, enterprise, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse(rsp)
}

// EnterpriseAdmingetSelfHostedRunnerForEnterpriseWithResponse request returning *EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmingetSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmingetSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithResponse request returning *EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseWithResponse request returning *EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithBody(ctx, enterprise, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBodyWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithBody(ctx, enterprise, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, body EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseWithResponse request returning *EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterprise(ctx, enterprise, runnerId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse(rsp)
}

// EnterpriseAdmingetAuditLogWithResponse request returning *EnterpriseAdmingetAuditLogResponse
func (c *ClientWithResponses) EnterpriseAdmingetAuditLogWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdmingetAuditLogParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetAuditLogResponse, error) {
	rsp, err := c.EnterpriseAdmingetAuditLog(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetAuditLogResponse(rsp)
}

// SecretScanninglistAlertsForEnterpriseWithResponse request returning *SecretScanninglistAlertsForEnterpriseResponse
func (c *ClientWithResponses) SecretScanninglistAlertsForEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *SecretScanninglistAlertsForEnterpriseParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForEnterpriseResponse, error) {
	rsp, err := c.SecretScanninglistAlertsForEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanninglistAlertsForEnterpriseResponse(rsp)
}

// BillinggetGithubActionsBillingGheWithResponse request returning *BillinggetGithubActionsBillingGheResponse
func (c *ClientWithResponses) BillinggetGithubActionsBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingGheResponse, error) {
	rsp, err := c.BillinggetGithubActionsBillingGhe(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubActionsBillingGheResponse(rsp)
}

// BillinggetGithubAdvancedSecurityBillingGheWithResponse request returning *BillinggetGithubAdvancedSecurityBillingGheResponse
func (c *ClientWithResponses) BillinggetGithubAdvancedSecurityBillingGheWithResponse(ctx context.Context, enterprise Enterprise, params *BillinggetGithubAdvancedSecurityBillingGheParams, reqEditors ...RequestEditorFn) (*BillinggetGithubAdvancedSecurityBillingGheResponse, error) {
	rsp, err := c.BillinggetGithubAdvancedSecurityBillingGhe(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubAdvancedSecurityBillingGheResponse(rsp)
}

// BillinggetGithubPackagesBillingGheWithResponse request returning *BillinggetGithubPackagesBillingGheResponse
func (c *ClientWithResponses) BillinggetGithubPackagesBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingGheResponse, error) {
	rsp, err := c.BillinggetGithubPackagesBillingGhe(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubPackagesBillingGheResponse(rsp)
}

// BillinggetSharedStorageBillingGheWithResponse request returning *BillinggetSharedStorageBillingGheResponse
func (c *ClientWithResponses) BillinggetSharedStorageBillingGheWithResponse(ctx context.Context, enterprise Enterprise, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingGheResponse, error) {
	rsp, err := c.BillinggetSharedStorageBillingGhe(ctx, enterprise, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetSharedStorageBillingGheResponse(rsp)
}

// ActivitylistPublicEventsWithResponse request returning *ActivitylistPublicEventsResponse
func (c *ClientWithResponses) ActivitylistPublicEventsWithResponse(ctx context.Context, params *ActivitylistPublicEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsResponse, error) {
	rsp, err := c.ActivitylistPublicEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistPublicEventsResponse(rsp)
}

// ActivitygetFeedsWithResponse request returning *ActivitygetFeedsResponse
func (c *ClientWithResponses) ActivitygetFeedsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ActivitygetFeedsResponse, error) {
	rsp, err := c.ActivitygetFeeds(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitygetFeedsResponse(rsp)
}

// GistslistWithResponse request returning *GistslistResponse
func (c *ClientWithResponses) GistslistWithResponse(ctx context.Context, params *GistslistParams, reqEditors ...RequestEditorFn) (*GistslistResponse, error) {
	rsp, err := c.Gistslist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistResponse(rsp)
}

// GistscreateWithBodyWithResponse request with arbitrary body returning *GistscreateResponse
func (c *ClientWithResponses) GistscreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistscreateResponse, error) {
	rsp, err := c.GistscreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistscreateResponse(rsp)
}

func (c *ClientWithResponses) GistscreateWithResponse(ctx context.Context, body GistscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*GistscreateResponse, error) {
	rsp, err := c.Gistscreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistscreateResponse(rsp)
}

// GistslistPublicWithResponse request returning *GistslistPublicResponse
func (c *ClientWithResponses) GistslistPublicWithResponse(ctx context.Context, params *GistslistPublicParams, reqEditors ...RequestEditorFn) (*GistslistPublicResponse, error) {
	rsp, err := c.GistslistPublic(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistPublicResponse(rsp)
}

// GistslistStarredWithResponse request returning *GistslistStarredResponse
func (c *ClientWithResponses) GistslistStarredWithResponse(ctx context.Context, params *GistslistStarredParams, reqEditors ...RequestEditorFn) (*GistslistStarredResponse, error) {
	rsp, err := c.GistslistStarred(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistStarredResponse(rsp)
}

// GistsdeleteWithResponse request returning *GistsdeleteResponse
func (c *ClientWithResponses) GistsdeleteWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsdeleteResponse, error) {
	rsp, err := c.Gistsdelete(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsdeleteResponse(rsp)
}

// GistsgetWithResponse request returning *GistsgetResponse
func (c *ClientWithResponses) GistsgetWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsgetResponse, error) {
	rsp, err := c.Gistsget(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsgetResponse(rsp)
}

// GistsupdateWithBodyWithResponse request with arbitrary body returning *GistsupdateResponse
func (c *ClientWithResponses) GistsupdateWithBodyWithResponse(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistsupdateResponse, error) {
	rsp, err := c.GistsupdateWithBody(ctx, gistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsupdateResponse(rsp)
}

func (c *ClientWithResponses) GistsupdateWithResponse(ctx context.Context, gistId GistId, body GistsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*GistsupdateResponse, error) {
	rsp, err := c.Gistsupdate(ctx, gistId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsupdateResponse(rsp)
}

// GistslistCommentsWithResponse request returning *GistslistCommentsResponse
func (c *ClientWithResponses) GistslistCommentsWithResponse(ctx context.Context, gistId GistId, params *GistslistCommentsParams, reqEditors ...RequestEditorFn) (*GistslistCommentsResponse, error) {
	rsp, err := c.GistslistComments(ctx, gistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistCommentsResponse(rsp)
}

// GistscreateCommentWithBodyWithResponse request with arbitrary body returning *GistscreateCommentResponse
func (c *ClientWithResponses) GistscreateCommentWithBodyWithResponse(ctx context.Context, gistId GistId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistscreateCommentResponse, error) {
	rsp, err := c.GistscreateCommentWithBody(ctx, gistId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistscreateCommentResponse(rsp)
}

func (c *ClientWithResponses) GistscreateCommentWithResponse(ctx context.Context, gistId GistId, body GistscreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*GistscreateCommentResponse, error) {
	rsp, err := c.GistscreateComment(ctx, gistId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistscreateCommentResponse(rsp)
}

// GistsdeleteCommentWithResponse request returning *GistsdeleteCommentResponse
func (c *ClientWithResponses) GistsdeleteCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*GistsdeleteCommentResponse, error) {
	rsp, err := c.GistsdeleteComment(ctx, gistId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsdeleteCommentResponse(rsp)
}

// GistsgetCommentWithResponse request returning *GistsgetCommentResponse
func (c *ClientWithResponses) GistsgetCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, reqEditors ...RequestEditorFn) (*GistsgetCommentResponse, error) {
	rsp, err := c.GistsgetComment(ctx, gistId, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsgetCommentResponse(rsp)
}

// GistsupdateCommentWithBodyWithResponse request with arbitrary body returning *GistsupdateCommentResponse
func (c *ClientWithResponses) GistsupdateCommentWithBodyWithResponse(ctx context.Context, gistId GistId, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GistsupdateCommentResponse, error) {
	rsp, err := c.GistsupdateCommentWithBody(ctx, gistId, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsupdateCommentResponse(rsp)
}

func (c *ClientWithResponses) GistsupdateCommentWithResponse(ctx context.Context, gistId GistId, commentId CommentId, body GistsupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*GistsupdateCommentResponse, error) {
	rsp, err := c.GistsupdateComment(ctx, gistId, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsupdateCommentResponse(rsp)
}

// GistslistCommitsWithResponse request returning *GistslistCommitsResponse
func (c *ClientWithResponses) GistslistCommitsWithResponse(ctx context.Context, gistId GistId, params *GistslistCommitsParams, reqEditors ...RequestEditorFn) (*GistslistCommitsResponse, error) {
	rsp, err := c.GistslistCommits(ctx, gistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistCommitsResponse(rsp)
}

// GistslistForksWithResponse request returning *GistslistForksResponse
func (c *ClientWithResponses) GistslistForksWithResponse(ctx context.Context, gistId GistId, params *GistslistForksParams, reqEditors ...RequestEditorFn) (*GistslistForksResponse, error) {
	rsp, err := c.GistslistForks(ctx, gistId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistForksResponse(rsp)
}

// GistsforkWithResponse request returning *GistsforkResponse
func (c *ClientWithResponses) GistsforkWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsforkResponse, error) {
	rsp, err := c.Gistsfork(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsforkResponse(rsp)
}

// GistsunstarWithResponse request returning *GistsunstarResponse
func (c *ClientWithResponses) GistsunstarWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsunstarResponse, error) {
	rsp, err := c.Gistsunstar(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsunstarResponse(rsp)
}

// GistscheckIsStarredWithResponse request returning *GistscheckIsStarredResponse
func (c *ClientWithResponses) GistscheckIsStarredWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistscheckIsStarredResponse, error) {
	rsp, err := c.GistscheckIsStarred(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistscheckIsStarredResponse(rsp)
}

// GistsstarWithResponse request returning *GistsstarResponse
func (c *ClientWithResponses) GistsstarWithResponse(ctx context.Context, gistId GistId, reqEditors ...RequestEditorFn) (*GistsstarResponse, error) {
	rsp, err := c.Gistsstar(ctx, gistId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsstarResponse(rsp)
}

// GistsgetRevisionWithResponse request returning *GistsgetRevisionResponse
func (c *ClientWithResponses) GistsgetRevisionWithResponse(ctx context.Context, gistId GistId, sha string, reqEditors ...RequestEditorFn) (*GistsgetRevisionResponse, error) {
	rsp, err := c.GistsgetRevision(ctx, gistId, sha, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistsgetRevisionResponse(rsp)
}

// GitignoregetAllTemplatesWithResponse request returning *GitignoregetAllTemplatesResponse
func (c *ClientWithResponses) GitignoregetAllTemplatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GitignoregetAllTemplatesResponse, error) {
	rsp, err := c.GitignoregetAllTemplates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitignoregetAllTemplatesResponse(rsp)
}

// GitignoregetTemplateWithResponse request returning *GitignoregetTemplateResponse
func (c *ClientWithResponses) GitignoregetTemplateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GitignoregetTemplateResponse, error) {
	rsp, err := c.GitignoregetTemplate(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitignoregetTemplateResponse(rsp)
}

// AppslistReposAccessibleToInstallationWithResponse request returning *AppslistReposAccessibleToInstallationResponse
func (c *ClientWithResponses) AppslistReposAccessibleToInstallationWithResponse(ctx context.Context, params *AppslistReposAccessibleToInstallationParams, reqEditors ...RequestEditorFn) (*AppslistReposAccessibleToInstallationResponse, error) {
	rsp, err := c.AppslistReposAccessibleToInstallation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistReposAccessibleToInstallationResponse(rsp)
}

// AppsrevokeInstallationAccessTokenWithResponse request returning *AppsrevokeInstallationAccessTokenResponse
func (c *ClientWithResponses) AppsrevokeInstallationAccessTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*AppsrevokeInstallationAccessTokenResponse, error) {
	rsp, err := c.AppsrevokeInstallationAccessToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsrevokeInstallationAccessTokenResponse(rsp)
}

// IssueslistWithResponse request returning *IssueslistResponse
func (c *ClientWithResponses) IssueslistWithResponse(ctx context.Context, params *IssueslistParams, reqEditors ...RequestEditorFn) (*IssueslistResponse, error) {
	rsp, err := c.Issueslist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistResponse(rsp)
}

// LicensesgetAllCommonlyUsedWithResponse request returning *LicensesgetAllCommonlyUsedResponse
func (c *ClientWithResponses) LicensesgetAllCommonlyUsedWithResponse(ctx context.Context, params *LicensesgetAllCommonlyUsedParams, reqEditors ...RequestEditorFn) (*LicensesgetAllCommonlyUsedResponse, error) {
	rsp, err := c.LicensesgetAllCommonlyUsed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLicensesgetAllCommonlyUsedResponse(rsp)
}

// LicensesgetWithResponse request returning *LicensesgetResponse
func (c *ClientWithResponses) LicensesgetWithResponse(ctx context.Context, license string, reqEditors ...RequestEditorFn) (*LicensesgetResponse, error) {
	rsp, err := c.Licensesget(ctx, license, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLicensesgetResponse(rsp)
}

// MarkdownrenderWithBodyWithResponse request with arbitrary body returning *MarkdownrenderResponse
func (c *ClientWithResponses) MarkdownrenderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkdownrenderResponse, error) {
	rsp, err := c.MarkdownrenderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkdownrenderResponse(rsp)
}

func (c *ClientWithResponses) MarkdownrenderWithResponse(ctx context.Context, body MarkdownrenderJSONRequestBody, reqEditors ...RequestEditorFn) (*MarkdownrenderResponse, error) {
	rsp, err := c.Markdownrender(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkdownrenderResponse(rsp)
}

// MarkdownrenderRawWithBodyWithResponse request with arbitrary body returning *MarkdownrenderRawResponse
func (c *ClientWithResponses) MarkdownrenderRawWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MarkdownrenderRawResponse, error) {
	rsp, err := c.MarkdownrenderRawWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMarkdownrenderRawResponse(rsp)
}

// AppsgetSubscriptionPlanForAccountWithResponse request returning *AppsgetSubscriptionPlanForAccountResponse
func (c *ClientWithResponses) AppsgetSubscriptionPlanForAccountWithResponse(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*AppsgetSubscriptionPlanForAccountResponse, error) {
	rsp, err := c.AppsgetSubscriptionPlanForAccount(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetSubscriptionPlanForAccountResponse(rsp)
}

// AppslistPlansWithResponse request returning *AppslistPlansResponse
func (c *ClientWithResponses) AppslistPlansWithResponse(ctx context.Context, params *AppslistPlansParams, reqEditors ...RequestEditorFn) (*AppslistPlansResponse, error) {
	rsp, err := c.AppslistPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistPlansResponse(rsp)
}

// AppslistAccountsForPlanWithResponse request returning *AppslistAccountsForPlanResponse
func (c *ClientWithResponses) AppslistAccountsForPlanWithResponse(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanParams, reqEditors ...RequestEditorFn) (*AppslistAccountsForPlanResponse, error) {
	rsp, err := c.AppslistAccountsForPlan(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistAccountsForPlanResponse(rsp)
}

// AppsgetSubscriptionPlanForAccountStubbedWithResponse request returning *AppsgetSubscriptionPlanForAccountStubbedResponse
func (c *ClientWithResponses) AppsgetSubscriptionPlanForAccountStubbedWithResponse(ctx context.Context, accountId AccountId, reqEditors ...RequestEditorFn) (*AppsgetSubscriptionPlanForAccountStubbedResponse, error) {
	rsp, err := c.AppsgetSubscriptionPlanForAccountStubbed(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetSubscriptionPlanForAccountStubbedResponse(rsp)
}

// AppslistPlansStubbedWithResponse request returning *AppslistPlansStubbedResponse
func (c *ClientWithResponses) AppslistPlansStubbedWithResponse(ctx context.Context, params *AppslistPlansStubbedParams, reqEditors ...RequestEditorFn) (*AppslistPlansStubbedResponse, error) {
	rsp, err := c.AppslistPlansStubbed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistPlansStubbedResponse(rsp)
}

// AppslistAccountsForPlanStubbedWithResponse request returning *AppslistAccountsForPlanStubbedResponse
func (c *ClientWithResponses) AppslistAccountsForPlanStubbedWithResponse(ctx context.Context, planId PlanId, params *AppslistAccountsForPlanStubbedParams, reqEditors ...RequestEditorFn) (*AppslistAccountsForPlanStubbedResponse, error) {
	rsp, err := c.AppslistAccountsForPlanStubbed(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistAccountsForPlanStubbedResponse(rsp)
}

// MetagetWithResponse request returning *MetagetResponse
func (c *ClientWithResponses) MetagetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetagetResponse, error) {
	rsp, err := c.Metaget(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetagetResponse(rsp)
}

// ActivitylistPublicEventsForRepoNetworkWithResponse request returning *ActivitylistPublicEventsForRepoNetworkResponse
func (c *ClientWithResponses) ActivitylistPublicEventsForRepoNetworkWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistPublicEventsForRepoNetworkParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsForRepoNetworkResponse, error) {
	rsp, err := c.ActivitylistPublicEventsForRepoNetwork(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistPublicEventsForRepoNetworkResponse(rsp)
}

// ActivitylistNotificationsForAuthenticatedUserWithResponse request returning *ActivitylistNotificationsForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistNotificationsForAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistNotificationsForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistNotificationsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistNotificationsForAuthenticatedUserResponse(rsp)
}

// ActivitymarkNotificationsAsReadWithBodyWithResponse request with arbitrary body returning *ActivitymarkNotificationsAsReadResponse
func (c *ClientWithResponses) ActivitymarkNotificationsAsReadWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitymarkNotificationsAsReadResponse, error) {
	rsp, err := c.ActivitymarkNotificationsAsReadWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitymarkNotificationsAsReadResponse(rsp)
}

func (c *ClientWithResponses) ActivitymarkNotificationsAsReadWithResponse(ctx context.Context, body ActivitymarkNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitymarkNotificationsAsReadResponse, error) {
	rsp, err := c.ActivitymarkNotificationsAsRead(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitymarkNotificationsAsReadResponse(rsp)
}

// ActivitygetThreadWithResponse request returning *ActivitygetThreadResponse
func (c *ClientWithResponses) ActivitygetThreadWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitygetThreadResponse, error) {
	rsp, err := c.ActivitygetThread(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitygetThreadResponse(rsp)
}

// ActivitymarkThreadAsReadWithResponse request returning *ActivitymarkThreadAsReadResponse
func (c *ClientWithResponses) ActivitymarkThreadAsReadWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitymarkThreadAsReadResponse, error) {
	rsp, err := c.ActivitymarkThreadAsRead(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitymarkThreadAsReadResponse(rsp)
}

// ActivitydeleteThreadSubscriptionWithResponse request returning *ActivitydeleteThreadSubscriptionResponse
func (c *ClientWithResponses) ActivitydeleteThreadSubscriptionWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitydeleteThreadSubscriptionResponse, error) {
	rsp, err := c.ActivitydeleteThreadSubscription(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitydeleteThreadSubscriptionResponse(rsp)
}

// ActivitygetThreadSubscriptionForAuthenticatedUserWithResponse request returning *ActivitygetThreadSubscriptionForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitygetThreadSubscriptionForAuthenticatedUserWithResponse(ctx context.Context, threadId ThreadId, reqEditors ...RequestEditorFn) (*ActivitygetThreadSubscriptionForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitygetThreadSubscriptionForAuthenticatedUser(ctx, threadId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitygetThreadSubscriptionForAuthenticatedUserResponse(rsp)
}

// ActivitysetThreadSubscriptionWithBodyWithResponse request with arbitrary body returning *ActivitysetThreadSubscriptionResponse
func (c *ClientWithResponses) ActivitysetThreadSubscriptionWithBodyWithResponse(ctx context.Context, threadId ThreadId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitysetThreadSubscriptionResponse, error) {
	rsp, err := c.ActivitysetThreadSubscriptionWithBody(ctx, threadId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitysetThreadSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) ActivitysetThreadSubscriptionWithResponse(ctx context.Context, threadId ThreadId, body ActivitysetThreadSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitysetThreadSubscriptionResponse, error) {
	rsp, err := c.ActivitysetThreadSubscription(ctx, threadId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitysetThreadSubscriptionResponse(rsp)
}

// MetagetOctocatWithResponse request returning *MetagetOctocatResponse
func (c *ClientWithResponses) MetagetOctocatWithResponse(ctx context.Context, params *MetagetOctocatParams, reqEditors ...RequestEditorFn) (*MetagetOctocatResponse, error) {
	rsp, err := c.MetagetOctocat(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetagetOctocatResponse(rsp)
}

// OrgslistWithResponse request returning *OrgslistResponse
func (c *ClientWithResponses) OrgslistWithResponse(ctx context.Context, params *OrgslistParams, reqEditors ...RequestEditorFn) (*OrgslistResponse, error) {
	rsp, err := c.Orgslist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistResponse(rsp)
}

// OrgslistCustomRolesWithResponse request returning *OrgslistCustomRolesResponse
func (c *ClientWithResponses) OrgslistCustomRolesWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*OrgslistCustomRolesResponse, error) {
	rsp, err := c.OrgslistCustomRoles(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistCustomRolesResponse(rsp)
}

// OrgsgetWithResponse request returning *OrgsgetResponse
func (c *ClientWithResponses) OrgsgetWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgsgetResponse, error) {
	rsp, err := c.Orgsget(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetResponse(rsp)
}

// OrgsupdateWithBodyWithResponse request with arbitrary body returning *OrgsupdateResponse
func (c *ClientWithResponses) OrgsupdateWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateResponse, error) {
	rsp, err := c.OrgsupdateWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateResponse(rsp)
}

func (c *ClientWithResponses) OrgsupdateWithResponse(ctx context.Context, org Org, body OrgsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateResponse, error) {
	rsp, err := c.Orgsupdate(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateResponse(rsp)
}

// ActionsgetActionsCacheUsageForOrgWithResponse request returning *ActionsgetActionsCacheUsageForOrgResponse
func (c *ClientWithResponses) ActionsgetActionsCacheUsageForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageForOrgResponse, error) {
	rsp, err := c.ActionsgetActionsCacheUsageForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetActionsCacheUsageForOrgResponse(rsp)
}

// ActionsgetActionsCacheUsageByRepoForOrgWithResponse request returning *ActionsgetActionsCacheUsageByRepoForOrgResponse
func (c *ClientWithResponses) ActionsgetActionsCacheUsageByRepoForOrgWithResponse(ctx context.Context, org Org, params *ActionsgetActionsCacheUsageByRepoForOrgParams, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageByRepoForOrgResponse, error) {
	rsp, err := c.ActionsgetActionsCacheUsageByRepoForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetActionsCacheUsageByRepoForOrgResponse(rsp)
}

// ActionsgetGithubActionsPermissionsOrganizationWithResponse request returning *ActionsgetGithubActionsPermissionsOrganizationResponse
func (c *ClientWithResponses) ActionsgetGithubActionsPermissionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionsgetGithubActionsPermissionsOrganization(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetGithubActionsPermissionsOrganizationResponse(rsp)
}

// ActionssetGithubActionsPermissionsOrganizationWithBodyWithResponse request with arbitrary body returning *ActionssetGithubActionsPermissionsOrganizationResponse
func (c *ClientWithResponses) ActionssetGithubActionsPermissionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionssetGithubActionsPermissionsOrganizationWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsPermissionsOrganizationResponse(rsp)
}

func (c *ClientWithResponses) ActionssetGithubActionsPermissionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetGithubActionsPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionssetGithubActionsPermissionsOrganization(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsPermissionsOrganizationResponse(rsp)
}

// ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse request returning *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse
func (c *ClientWithResponses) ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse(ctx context.Context, org Org, params *ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationParams, reqEditors ...RequestEditorFn) (*ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	rsp, err := c.ActionslistSelectedRepositoriesEnabledGithubActionsOrganization(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse(rsp)
}

// ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBodyWithResponse request with arbitrary body returning *ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse
func (c *ClientWithResponses) ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	rsp, err := c.ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(rsp)
}

func (c *ClientWithResponses) ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	rsp, err := c.ActionssetSelectedRepositoriesEnabledGithubActionsOrganization(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(rsp)
}

// ActionsdisableSelectedRepositoryGithubActionsOrganizationWithResponse request returning *ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse
func (c *ClientWithResponses) ActionsdisableSelectedRepositoryGithubActionsOrganizationWithResponse(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	rsp, err := c.ActionsdisableSelectedRepositoryGithubActionsOrganization(ctx, org, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdisableSelectedRepositoryGithubActionsOrganizationResponse(rsp)
}

// ActionsenableSelectedRepositoryGithubActionsOrganizationWithResponse request returning *ActionsenableSelectedRepositoryGithubActionsOrganizationResponse
func (c *ClientWithResponses) ActionsenableSelectedRepositoryGithubActionsOrganizationWithResponse(ctx context.Context, org Org, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsenableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	rsp, err := c.ActionsenableSelectedRepositoryGithubActionsOrganization(ctx, org, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsenableSelectedRepositoryGithubActionsOrganizationResponse(rsp)
}

// ActionsgetAllowedActionsOrganizationWithResponse request returning *ActionsgetAllowedActionsOrganizationResponse
func (c *ClientWithResponses) ActionsgetAllowedActionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetAllowedActionsOrganizationResponse, error) {
	rsp, err := c.ActionsgetAllowedActionsOrganization(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetAllowedActionsOrganizationResponse(rsp)
}

// ActionssetAllowedActionsOrganizationWithBodyWithResponse request with arbitrary body returning *ActionssetAllowedActionsOrganizationResponse
func (c *ClientWithResponses) ActionssetAllowedActionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsOrganizationResponse, error) {
	rsp, err := c.ActionssetAllowedActionsOrganizationWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetAllowedActionsOrganizationResponse(rsp)
}

func (c *ClientWithResponses) ActionssetAllowedActionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetAllowedActionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsOrganizationResponse, error) {
	rsp, err := c.ActionssetAllowedActionsOrganization(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetAllowedActionsOrganizationResponse(rsp)
}

// ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse request returning *ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse
func (c *ClientWithResponses) ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionsgetGithubActionsDefaultWorkflowPermissionsOrganization(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse(rsp)
}

// ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBodyWithResponse request with arbitrary body returning *ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse
func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse(rsp)
}

func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse(ctx context.Context, org Org, body ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsOrganization(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse(rsp)
}

// ActionslistSelfHostedRunnerGroupsForOrgWithResponse request returning *ActionslistSelfHostedRunnerGroupsForOrgResponse
func (c *ClientWithResponses) ActionslistSelfHostedRunnerGroupsForOrgWithResponse(ctx context.Context, org Org, params *ActionslistSelfHostedRunnerGroupsForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnerGroupsForOrgResponse, error) {
	rsp, err := c.ActionslistSelfHostedRunnerGroupsForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelfHostedRunnerGroupsForOrgResponse(rsp)
}

// ActionscreateSelfHostedRunnerGroupForOrgWithBodyWithResponse request with arbitrary body returning *ActionscreateSelfHostedRunnerGroupForOrgResponse
func (c *ClientWithResponses) ActionscreateSelfHostedRunnerGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateSelfHostedRunnerGroupForOrgResponse, error) {
	rsp, err := c.ActionscreateSelfHostedRunnerGroupForOrgWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateSelfHostedRunnerGroupForOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionscreateSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, body ActionscreateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateSelfHostedRunnerGroupForOrgResponse, error) {
	rsp, err := c.ActionscreateSelfHostedRunnerGroupForOrg(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateSelfHostedRunnerGroupForOrgResponse(rsp)
}

// ActionsdeleteSelfHostedRunnerGroupFromOrgWithResponse request returning *ActionsdeleteSelfHostedRunnerGroupFromOrgResponse
func (c *ClientWithResponses) ActionsdeleteSelfHostedRunnerGroupFromOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerGroupFromOrgResponse, error) {
	rsp, err := c.ActionsdeleteSelfHostedRunnerGroupFromOrg(ctx, org, runnerGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteSelfHostedRunnerGroupFromOrgResponse(rsp)
}

// ActionsgetSelfHostedRunnerGroupForOrgWithResponse request returning *ActionsgetSelfHostedRunnerGroupForOrgResponse
func (c *ClientWithResponses) ActionsgetSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerGroupForOrgResponse, error) {
	rsp, err := c.ActionsgetSelfHostedRunnerGroupForOrg(ctx, org, runnerGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetSelfHostedRunnerGroupForOrgResponse(rsp)
}

// ActionsupdateSelfHostedRunnerGroupForOrgWithBodyWithResponse request with arbitrary body returning *ActionsupdateSelfHostedRunnerGroupForOrgResponse
func (c *ClientWithResponses) ActionsupdateSelfHostedRunnerGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsupdateSelfHostedRunnerGroupForOrgResponse, error) {
	rsp, err := c.ActionsupdateSelfHostedRunnerGroupForOrgWithBody(ctx, org, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsupdateSelfHostedRunnerGroupForOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionsupdateSelfHostedRunnerGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionsupdateSelfHostedRunnerGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsupdateSelfHostedRunnerGroupForOrgResponse, error) {
	rsp, err := c.ActionsupdateSelfHostedRunnerGroupForOrg(ctx, org, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsupdateSelfHostedRunnerGroupForOrgResponse(rsp)
}

// ActionslistRepoAccessToSelfHostedRunnerGroupInOrgWithResponse request returning *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse
func (c *ClientWithResponses) ActionslistRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistRepoAccessToSelfHostedRunnerGroupInOrgParams, reqEditors ...RequestEditorFn) (*ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	rsp, err := c.ActionslistRepoAccessToSelfHostedRunnerGroupInOrg(ctx, org, runnerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp)
}

// ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBodyWithResponse request with arbitrary body returning *ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse
func (c *ClientWithResponses) ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	rsp, err := c.ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithBody(ctx, org, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetRepoAccessToSelfHostedRunnerGroupInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	rsp, err := c.ActionssetRepoAccessToSelfHostedRunnerGroupInOrg(ctx, org, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp)
}

// ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgWithResponse request returning *ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse
func (c *ClientWithResponses) ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	rsp, err := c.ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrg(ctx, org, runnerGroupId, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp)
}

// ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgWithResponse request returning *ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse
func (c *ClientWithResponses) ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	rsp, err := c.ActionsaddRepoAccessToSelfHostedRunnerGroupInOrg(ctx, org, runnerGroupId, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp)
}

// ActionslistSelfHostedRunnersInGroupForOrgWithResponse request returning *ActionslistSelfHostedRunnersInGroupForOrgResponse
func (c *ClientWithResponses) ActionslistSelfHostedRunnersInGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, params *ActionslistSelfHostedRunnersInGroupForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersInGroupForOrgResponse, error) {
	rsp, err := c.ActionslistSelfHostedRunnersInGroupForOrg(ctx, org, runnerGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelfHostedRunnersInGroupForOrgResponse(rsp)
}

// ActionssetSelfHostedRunnersInGroupForOrgWithBodyWithResponse request with arbitrary body returning *ActionssetSelfHostedRunnersInGroupForOrgResponse
func (c *ClientWithResponses) ActionssetSelfHostedRunnersInGroupForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelfHostedRunnersInGroupForOrgResponse, error) {
	rsp, err := c.ActionssetSelfHostedRunnersInGroupForOrgWithBody(ctx, org, runnerGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelfHostedRunnersInGroupForOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionssetSelfHostedRunnersInGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, body ActionssetSelfHostedRunnersInGroupForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelfHostedRunnersInGroupForOrgResponse, error) {
	rsp, err := c.ActionssetSelfHostedRunnersInGroupForOrg(ctx, org, runnerGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelfHostedRunnersInGroupForOrgResponse(rsp)
}

// ActionsremoveSelfHostedRunnerFromGroupForOrgWithResponse request returning *ActionsremoveSelfHostedRunnerFromGroupForOrgResponse
func (c *ClientWithResponses) ActionsremoveSelfHostedRunnerFromGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveSelfHostedRunnerFromGroupForOrgResponse, error) {
	rsp, err := c.ActionsremoveSelfHostedRunnerFromGroupForOrg(ctx, org, runnerGroupId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveSelfHostedRunnerFromGroupForOrgResponse(rsp)
}

// ActionsaddSelfHostedRunnerToGroupForOrgWithResponse request returning *ActionsaddSelfHostedRunnerToGroupForOrgResponse
func (c *ClientWithResponses) ActionsaddSelfHostedRunnerToGroupForOrgWithResponse(ctx context.Context, org Org, runnerGroupId RunnerGroupId, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsaddSelfHostedRunnerToGroupForOrgResponse, error) {
	rsp, err := c.ActionsaddSelfHostedRunnerToGroupForOrg(ctx, org, runnerGroupId, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddSelfHostedRunnerToGroupForOrgResponse(rsp)
}

// ActionslistSelfHostedRunnersForOrgWithResponse request returning *ActionslistSelfHostedRunnersForOrgResponse
func (c *ClientWithResponses) ActionslistSelfHostedRunnersForOrgWithResponse(ctx context.Context, org Org, params *ActionslistSelfHostedRunnersForOrgParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersForOrgResponse, error) {
	rsp, err := c.ActionslistSelfHostedRunnersForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelfHostedRunnersForOrgResponse(rsp)
}

// ActionslistRunnerApplicationsForOrgWithResponse request returning *ActionslistRunnerApplicationsForOrgResponse
func (c *ClientWithResponses) ActionslistRunnerApplicationsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionslistRunnerApplicationsForOrgResponse, error) {
	rsp, err := c.ActionslistRunnerApplicationsForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistRunnerApplicationsForOrgResponse(rsp)
}

// ActionscreateRegistrationTokenForOrgWithResponse request returning *ActionscreateRegistrationTokenForOrgResponse
func (c *ClientWithResponses) ActionscreateRegistrationTokenForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionscreateRegistrationTokenForOrgResponse, error) {
	rsp, err := c.ActionscreateRegistrationTokenForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateRegistrationTokenForOrgResponse(rsp)
}

// ActionscreateRemoveTokenForOrgWithResponse request returning *ActionscreateRemoveTokenForOrgResponse
func (c *ClientWithResponses) ActionscreateRemoveTokenForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionscreateRemoveTokenForOrgResponse, error) {
	rsp, err := c.ActionscreateRemoveTokenForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateRemoveTokenForOrgResponse(rsp)
}

// ActionsdeleteSelfHostedRunnerFromOrgWithResponse request returning *ActionsdeleteSelfHostedRunnerFromOrgResponse
func (c *ClientWithResponses) ActionsdeleteSelfHostedRunnerFromOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerFromOrgResponse, error) {
	rsp, err := c.ActionsdeleteSelfHostedRunnerFromOrg(ctx, org, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteSelfHostedRunnerFromOrgResponse(rsp)
}

// ActionsgetSelfHostedRunnerForOrgWithResponse request returning *ActionsgetSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionsgetSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionsgetSelfHostedRunnerForOrg(ctx, org, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetSelfHostedRunnerForOrgResponse(rsp)
}

// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgWithResponse request returning *ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrg(ctx, org, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse(rsp)
}

// ActionslistLabelsForSelfHostedRunnerForOrgWithResponse request returning *ActionslistLabelsForSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionslistLabelsForSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionslistLabelsForSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionslistLabelsForSelfHostedRunnerForOrg(ctx, org, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistLabelsForSelfHostedRunnerForOrgResponse(rsp)
}

// ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBodyWithResponse request with arbitrary body returning *ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithBody(ctx, org, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionsaddCustomLabelsToSelfHostedRunnerForOrg(ctx, org, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse(rsp)
}

// ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBodyWithResponse request with arbitrary body returning *ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBodyWithResponse(ctx context.Context, org Org, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionssetCustomLabelsForSelfHostedRunnerForOrgWithBody(ctx, org, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetCustomLabelsForSelfHostedRunnerForOrgResponse(rsp)
}

func (c *ClientWithResponses) ActionssetCustomLabelsForSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionssetCustomLabelsForSelfHostedRunnerForOrg(ctx, org, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetCustomLabelsForSelfHostedRunnerForOrgResponse(rsp)
}

// ActionsremoveCustomLabelFromSelfHostedRunnerForOrgWithResponse request returning *ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse
func (c *ClientWithResponses) ActionsremoveCustomLabelFromSelfHostedRunnerForOrgWithResponse(ctx context.Context, org Org, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse, error) {
	rsp, err := c.ActionsremoveCustomLabelFromSelfHostedRunnerForOrg(ctx, org, runnerId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse(rsp)
}

// ActionslistOrgSecretsWithResponse request returning *ActionslistOrgSecretsResponse
func (c *ClientWithResponses) ActionslistOrgSecretsWithResponse(ctx context.Context, org Org, params *ActionslistOrgSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistOrgSecretsResponse, error) {
	rsp, err := c.ActionslistOrgSecrets(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistOrgSecretsResponse(rsp)
}

// ActionsgetOrgPublicKeyWithResponse request returning *ActionsgetOrgPublicKeyResponse
func (c *ClientWithResponses) ActionsgetOrgPublicKeyWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*ActionsgetOrgPublicKeyResponse, error) {
	rsp, err := c.ActionsgetOrgPublicKey(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetOrgPublicKeyResponse(rsp)
}

// ActionsdeleteOrgSecretWithResponse request returning *ActionsdeleteOrgSecretResponse
func (c *ClientWithResponses) ActionsdeleteOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteOrgSecretResponse, error) {
	rsp, err := c.ActionsdeleteOrgSecret(ctx, org, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteOrgSecretResponse(rsp)
}

// ActionsgetOrgSecretWithResponse request returning *ActionsgetOrgSecretResponse
func (c *ClientWithResponses) ActionsgetOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetOrgSecretResponse, error) {
	rsp, err := c.ActionsgetOrgSecret(ctx, org, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetOrgSecretResponse(rsp)
}

// ActionscreateOrUpdateOrgSecretWithBodyWithResponse request with arbitrary body returning *ActionscreateOrUpdateOrgSecretResponse
func (c *ClientWithResponses) ActionscreateOrUpdateOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateOrgSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateOrgSecretWithBody(ctx, org, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateOrgSecretResponse(rsp)
}

func (c *ClientWithResponses) ActionscreateOrUpdateOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body ActionscreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateOrgSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateOrgSecret(ctx, org, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateOrgSecretResponse(rsp)
}

// ActionslistSelectedReposForOrgSecretWithResponse request returning *ActionslistSelectedReposForOrgSecretResponse
func (c *ClientWithResponses) ActionslistSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, params *ActionslistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*ActionslistSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.ActionslistSelectedReposForOrgSecret(ctx, org, secretName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelectedReposForOrgSecretResponse(rsp)
}

// ActionssetSelectedReposForOrgSecretWithBodyWithResponse request with arbitrary body returning *ActionssetSelectedReposForOrgSecretResponse
func (c *ClientWithResponses) ActionssetSelectedReposForOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.ActionssetSelectedReposForOrgSecretWithBody(ctx, org, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelectedReposForOrgSecretResponse(rsp)
}

func (c *ClientWithResponses) ActionssetSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body ActionssetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.ActionssetSelectedReposForOrgSecret(ctx, org, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetSelectedReposForOrgSecretResponse(rsp)
}

// ActionsremoveSelectedRepoFromOrgSecretWithResponse request returning *ActionsremoveSelectedRepoFromOrgSecretResponse
func (c *ClientWithResponses) ActionsremoveSelectedRepoFromOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*ActionsremoveSelectedRepoFromOrgSecretResponse, error) {
	rsp, err := c.ActionsremoveSelectedRepoFromOrgSecret(ctx, org, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveSelectedRepoFromOrgSecretResponse(rsp)
}

// ActionsaddSelectedRepoToOrgSecretWithResponse request returning *ActionsaddSelectedRepoToOrgSecretResponse
func (c *ClientWithResponses) ActionsaddSelectedRepoToOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*ActionsaddSelectedRepoToOrgSecretResponse, error) {
	rsp, err := c.ActionsaddSelectedRepoToOrgSecret(ctx, org, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddSelectedRepoToOrgSecretResponse(rsp)
}

// OrgsgetAuditLogWithResponse request returning *OrgsgetAuditLogResponse
func (c *ClientWithResponses) OrgsgetAuditLogWithResponse(ctx context.Context, org Org, params *OrgsgetAuditLogParams, reqEditors ...RequestEditorFn) (*OrgsgetAuditLogResponse, error) {
	rsp, err := c.OrgsgetAuditLog(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetAuditLogResponse(rsp)
}

// OrgslistBlockedUsersWithResponse request returning *OrgslistBlockedUsersResponse
func (c *ClientWithResponses) OrgslistBlockedUsersWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgslistBlockedUsersResponse, error) {
	rsp, err := c.OrgslistBlockedUsers(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistBlockedUsersResponse(rsp)
}

// OrgsunblockUserWithResponse request returning *OrgsunblockUserResponse
func (c *ClientWithResponses) OrgsunblockUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsunblockUserResponse, error) {
	rsp, err := c.OrgsunblockUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsunblockUserResponse(rsp)
}

// OrgscheckBlockedUserWithResponse request returning *OrgscheckBlockedUserResponse
func (c *ClientWithResponses) OrgscheckBlockedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckBlockedUserResponse, error) {
	rsp, err := c.OrgscheckBlockedUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscheckBlockedUserResponse(rsp)
}

// OrgsblockUserWithResponse request returning *OrgsblockUserResponse
func (c *ClientWithResponses) OrgsblockUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsblockUserResponse, error) {
	rsp, err := c.OrgsblockUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsblockUserResponse(rsp)
}

// CodeScanninglistAlertsForOrgWithResponse request returning *CodeScanninglistAlertsForOrgResponse
func (c *ClientWithResponses) CodeScanninglistAlertsForOrgWithResponse(ctx context.Context, org Org, params *CodeScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertsForOrgResponse, error) {
	rsp, err := c.CodeScanninglistAlertsForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninglistAlertsForOrgResponse(rsp)
}

// OrgslistSamlSsoAuthorizationsWithResponse request returning *OrgslistSamlSsoAuthorizationsResponse
func (c *ClientWithResponses) OrgslistSamlSsoAuthorizationsWithResponse(ctx context.Context, org Org, params *OrgslistSamlSsoAuthorizationsParams, reqEditors ...RequestEditorFn) (*OrgslistSamlSsoAuthorizationsResponse, error) {
	rsp, err := c.OrgslistSamlSsoAuthorizations(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistSamlSsoAuthorizationsResponse(rsp)
}

// OrgsremoveSamlSsoAuthorizationWithResponse request returning *OrgsremoveSamlSsoAuthorizationResponse
func (c *ClientWithResponses) OrgsremoveSamlSsoAuthorizationWithResponse(ctx context.Context, org Org, credentialId int, reqEditors ...RequestEditorFn) (*OrgsremoveSamlSsoAuthorizationResponse, error) {
	rsp, err := c.OrgsremoveSamlSsoAuthorization(ctx, org, credentialId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsremoveSamlSsoAuthorizationResponse(rsp)
}

// DependabotlistOrgSecretsWithResponse request returning *DependabotlistOrgSecretsResponse
func (c *ClientWithResponses) DependabotlistOrgSecretsWithResponse(ctx context.Context, org Org, params *DependabotlistOrgSecretsParams, reqEditors ...RequestEditorFn) (*DependabotlistOrgSecretsResponse, error) {
	rsp, err := c.DependabotlistOrgSecrets(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotlistOrgSecretsResponse(rsp)
}

// DependabotgetOrgPublicKeyWithResponse request returning *DependabotgetOrgPublicKeyResponse
func (c *ClientWithResponses) DependabotgetOrgPublicKeyWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*DependabotgetOrgPublicKeyResponse, error) {
	rsp, err := c.DependabotgetOrgPublicKey(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotgetOrgPublicKeyResponse(rsp)
}

// DependabotdeleteOrgSecretWithResponse request returning *DependabotdeleteOrgSecretResponse
func (c *ClientWithResponses) DependabotdeleteOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotdeleteOrgSecretResponse, error) {
	rsp, err := c.DependabotdeleteOrgSecret(ctx, org, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotdeleteOrgSecretResponse(rsp)
}

// DependabotgetOrgSecretWithResponse request returning *DependabotgetOrgSecretResponse
func (c *ClientWithResponses) DependabotgetOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotgetOrgSecretResponse, error) {
	rsp, err := c.DependabotgetOrgSecret(ctx, org, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotgetOrgSecretResponse(rsp)
}

// DependabotcreateOrUpdateOrgSecretWithBodyWithResponse request with arbitrary body returning *DependabotcreateOrUpdateOrgSecretResponse
func (c *ClientWithResponses) DependabotcreateOrUpdateOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateOrgSecretResponse, error) {
	rsp, err := c.DependabotcreateOrUpdateOrgSecretWithBody(ctx, org, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotcreateOrUpdateOrgSecretResponse(rsp)
}

func (c *ClientWithResponses) DependabotcreateOrUpdateOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body DependabotcreateOrUpdateOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateOrgSecretResponse, error) {
	rsp, err := c.DependabotcreateOrUpdateOrgSecret(ctx, org, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotcreateOrUpdateOrgSecretResponse(rsp)
}

// DependabotlistSelectedReposForOrgSecretWithResponse request returning *DependabotlistSelectedReposForOrgSecretResponse
func (c *ClientWithResponses) DependabotlistSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, params *DependabotlistSelectedReposForOrgSecretParams, reqEditors ...RequestEditorFn) (*DependabotlistSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.DependabotlistSelectedReposForOrgSecret(ctx, org, secretName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotlistSelectedReposForOrgSecretResponse(rsp)
}

// DependabotsetSelectedReposForOrgSecretWithBodyWithResponse request with arbitrary body returning *DependabotsetSelectedReposForOrgSecretResponse
func (c *ClientWithResponses) DependabotsetSelectedReposForOrgSecretWithBodyWithResponse(ctx context.Context, org Org, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotsetSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.DependabotsetSelectedReposForOrgSecretWithBody(ctx, org, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotsetSelectedReposForOrgSecretResponse(rsp)
}

func (c *ClientWithResponses) DependabotsetSelectedReposForOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, body DependabotsetSelectedReposForOrgSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotsetSelectedReposForOrgSecretResponse, error) {
	rsp, err := c.DependabotsetSelectedReposForOrgSecret(ctx, org, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotsetSelectedReposForOrgSecretResponse(rsp)
}

// DependabotremoveSelectedRepoFromOrgSecretWithResponse request returning *DependabotremoveSelectedRepoFromOrgSecretResponse
func (c *ClientWithResponses) DependabotremoveSelectedRepoFromOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*DependabotremoveSelectedRepoFromOrgSecretResponse, error) {
	rsp, err := c.DependabotremoveSelectedRepoFromOrgSecret(ctx, org, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotremoveSelectedRepoFromOrgSecretResponse(rsp)
}

// DependabotaddSelectedRepoToOrgSecretWithResponse request returning *DependabotaddSelectedRepoToOrgSecretResponse
func (c *ClientWithResponses) DependabotaddSelectedRepoToOrgSecretWithResponse(ctx context.Context, org Org, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*DependabotaddSelectedRepoToOrgSecretResponse, error) {
	rsp, err := c.DependabotaddSelectedRepoToOrgSecret(ctx, org, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotaddSelectedRepoToOrgSecretResponse(rsp)
}

// ActivitylistPublicOrgEventsWithResponse request returning *ActivitylistPublicOrgEventsResponse
func (c *ClientWithResponses) ActivitylistPublicOrgEventsWithResponse(ctx context.Context, org Org, params *ActivitylistPublicOrgEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicOrgEventsResponse, error) {
	rsp, err := c.ActivitylistPublicOrgEvents(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistPublicOrgEventsResponse(rsp)
}

// TeamsexternalIdpGroupInfoForOrgWithResponse request returning *TeamsexternalIdpGroupInfoForOrgResponse
func (c *ClientWithResponses) TeamsexternalIdpGroupInfoForOrgWithResponse(ctx context.Context, org Org, groupId GroupId, reqEditors ...RequestEditorFn) (*TeamsexternalIdpGroupInfoForOrgResponse, error) {
	rsp, err := c.TeamsexternalIdpGroupInfoForOrg(ctx, org, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsexternalIdpGroupInfoForOrgResponse(rsp)
}

// TeamslistExternalIdpGroupsForOrgWithResponse request returning *TeamslistExternalIdpGroupsForOrgResponse
func (c *ClientWithResponses) TeamslistExternalIdpGroupsForOrgWithResponse(ctx context.Context, org Org, params *TeamslistExternalIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*TeamslistExternalIdpGroupsForOrgResponse, error) {
	rsp, err := c.TeamslistExternalIdpGroupsForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistExternalIdpGroupsForOrgResponse(rsp)
}

// OrgslistFailedInvitationsWithResponse request returning *OrgslistFailedInvitationsResponse
func (c *ClientWithResponses) OrgslistFailedInvitationsWithResponse(ctx context.Context, org Org, params *OrgslistFailedInvitationsParams, reqEditors ...RequestEditorFn) (*OrgslistFailedInvitationsResponse, error) {
	rsp, err := c.OrgslistFailedInvitations(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistFailedInvitationsResponse(rsp)
}

// OrgslistWebhooksWithResponse request returning *OrgslistWebhooksResponse
func (c *ClientWithResponses) OrgslistWebhooksWithResponse(ctx context.Context, org Org, params *OrgslistWebhooksParams, reqEditors ...RequestEditorFn) (*OrgslistWebhooksResponse, error) {
	rsp, err := c.OrgslistWebhooks(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistWebhooksResponse(rsp)
}

// OrgscreateWebhookWithBodyWithResponse request with arbitrary body returning *OrgscreateWebhookResponse
func (c *ClientWithResponses) OrgscreateWebhookWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgscreateWebhookResponse, error) {
	rsp, err := c.OrgscreateWebhookWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) OrgscreateWebhookWithResponse(ctx context.Context, org Org, body OrgscreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgscreateWebhookResponse, error) {
	rsp, err := c.OrgscreateWebhook(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscreateWebhookResponse(rsp)
}

// OrgsdeleteWebhookWithResponse request returning *OrgsdeleteWebhookResponse
func (c *ClientWithResponses) OrgsdeleteWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsdeleteWebhookResponse, error) {
	rsp, err := c.OrgsdeleteWebhook(ctx, org, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsdeleteWebhookResponse(rsp)
}

// OrgsgetWebhookWithResponse request returning *OrgsgetWebhookResponse
func (c *ClientWithResponses) OrgsgetWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookResponse, error) {
	rsp, err := c.OrgsgetWebhook(ctx, org, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetWebhookResponse(rsp)
}

// OrgsupdateWebhookWithBodyWithResponse request with arbitrary body returning *OrgsupdateWebhookResponse
func (c *ClientWithResponses) OrgsupdateWebhookWithBodyWithResponse(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookResponse, error) {
	rsp, err := c.OrgsupdateWebhookWithBody(ctx, org, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) OrgsupdateWebhookWithResponse(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookResponse, error) {
	rsp, err := c.OrgsupdateWebhook(ctx, org, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateWebhookResponse(rsp)
}

// OrgsgetWebhookConfigForOrgWithResponse request returning *OrgsgetWebhookConfigForOrgResponse
func (c *ClientWithResponses) OrgsgetWebhookConfigForOrgWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookConfigForOrgResponse, error) {
	rsp, err := c.OrgsgetWebhookConfigForOrg(ctx, org, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetWebhookConfigForOrgResponse(rsp)
}

// OrgsupdateWebhookConfigForOrgWithBodyWithResponse request with arbitrary body returning *OrgsupdateWebhookConfigForOrgResponse
func (c *ClientWithResponses) OrgsupdateWebhookConfigForOrgWithBodyWithResponse(ctx context.Context, org Org, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookConfigForOrgResponse, error) {
	rsp, err := c.OrgsupdateWebhookConfigForOrgWithBody(ctx, org, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateWebhookConfigForOrgResponse(rsp)
}

func (c *ClientWithResponses) OrgsupdateWebhookConfigForOrgWithResponse(ctx context.Context, org Org, hookId HookId, body OrgsupdateWebhookConfigForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateWebhookConfigForOrgResponse, error) {
	rsp, err := c.OrgsupdateWebhookConfigForOrg(ctx, org, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateWebhookConfigForOrgResponse(rsp)
}

// OrgslistWebhookDeliveriesWithResponse request returning *OrgslistWebhookDeliveriesResponse
func (c *ClientWithResponses) OrgslistWebhookDeliveriesWithResponse(ctx context.Context, org Org, hookId HookId, params *OrgslistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*OrgslistWebhookDeliveriesResponse, error) {
	rsp, err := c.OrgslistWebhookDeliveries(ctx, org, hookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistWebhookDeliveriesResponse(rsp)
}

// OrgsgetWebhookDeliveryWithResponse request returning *OrgsgetWebhookDeliveryResponse
func (c *ClientWithResponses) OrgsgetWebhookDeliveryWithResponse(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*OrgsgetWebhookDeliveryResponse, error) {
	rsp, err := c.OrgsgetWebhookDelivery(ctx, org, hookId, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetWebhookDeliveryResponse(rsp)
}

// OrgsredeliverWebhookDeliveryWithResponse request returning *OrgsredeliverWebhookDeliveryResponse
func (c *ClientWithResponses) OrgsredeliverWebhookDeliveryWithResponse(ctx context.Context, org Org, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*OrgsredeliverWebhookDeliveryResponse, error) {
	rsp, err := c.OrgsredeliverWebhookDelivery(ctx, org, hookId, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsredeliverWebhookDeliveryResponse(rsp)
}

// OrgspingWebhookWithResponse request returning *OrgspingWebhookResponse
func (c *ClientWithResponses) OrgspingWebhookWithResponse(ctx context.Context, org Org, hookId HookId, reqEditors ...RequestEditorFn) (*OrgspingWebhookResponse, error) {
	rsp, err := c.OrgspingWebhook(ctx, org, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgspingWebhookResponse(rsp)
}

// AppsgetOrgInstallationWithResponse request returning *AppsgetOrgInstallationResponse
func (c *ClientWithResponses) AppsgetOrgInstallationWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*AppsgetOrgInstallationResponse, error) {
	rsp, err := c.AppsgetOrgInstallation(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetOrgInstallationResponse(rsp)
}

// OrgslistAppInstallationsWithResponse request returning *OrgslistAppInstallationsResponse
func (c *ClientWithResponses) OrgslistAppInstallationsWithResponse(ctx context.Context, org Org, params *OrgslistAppInstallationsParams, reqEditors ...RequestEditorFn) (*OrgslistAppInstallationsResponse, error) {
	rsp, err := c.OrgslistAppInstallations(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistAppInstallationsResponse(rsp)
}

// InteractionsremoveRestrictionsForOrgWithResponse request returning *InteractionsremoveRestrictionsForOrgResponse
func (c *ClientWithResponses) InteractionsremoveRestrictionsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForOrgResponse, error) {
	rsp, err := c.InteractionsremoveRestrictionsForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsremoveRestrictionsForOrgResponse(rsp)
}

// InteractionsgetRestrictionsForOrgWithResponse request returning *InteractionsgetRestrictionsForOrgResponse
func (c *ClientWithResponses) InteractionsgetRestrictionsForOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForOrgResponse, error) {
	rsp, err := c.InteractionsgetRestrictionsForOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsgetRestrictionsForOrgResponse(rsp)
}

// InteractionssetRestrictionsForOrgWithBodyWithResponse request with arbitrary body returning *InteractionssetRestrictionsForOrgResponse
func (c *ClientWithResponses) InteractionssetRestrictionsForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForOrgResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForOrgWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForOrgResponse(rsp)
}

func (c *ClientWithResponses) InteractionssetRestrictionsForOrgWithResponse(ctx context.Context, org Org, body InteractionssetRestrictionsForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForOrgResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForOrg(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForOrgResponse(rsp)
}

// OrgslistPendingInvitationsWithResponse request returning *OrgslistPendingInvitationsResponse
func (c *ClientWithResponses) OrgslistPendingInvitationsWithResponse(ctx context.Context, org Org, params *OrgslistPendingInvitationsParams, reqEditors ...RequestEditorFn) (*OrgslistPendingInvitationsResponse, error) {
	rsp, err := c.OrgslistPendingInvitations(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistPendingInvitationsResponse(rsp)
}

// OrgscreateInvitationWithBodyWithResponse request with arbitrary body returning *OrgscreateInvitationResponse
func (c *ClientWithResponses) OrgscreateInvitationWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgscreateInvitationResponse, error) {
	rsp, err := c.OrgscreateInvitationWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscreateInvitationResponse(rsp)
}

func (c *ClientWithResponses) OrgscreateInvitationWithResponse(ctx context.Context, org Org, body OrgscreateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgscreateInvitationResponse, error) {
	rsp, err := c.OrgscreateInvitation(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscreateInvitationResponse(rsp)
}

// OrgscancelInvitationWithResponse request returning *OrgscancelInvitationResponse
func (c *ClientWithResponses) OrgscancelInvitationWithResponse(ctx context.Context, org Org, invitationId InvitationId, reqEditors ...RequestEditorFn) (*OrgscancelInvitationResponse, error) {
	rsp, err := c.OrgscancelInvitation(ctx, org, invitationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscancelInvitationResponse(rsp)
}

// OrgslistInvitationTeamsWithResponse request returning *OrgslistInvitationTeamsResponse
func (c *ClientWithResponses) OrgslistInvitationTeamsWithResponse(ctx context.Context, org Org, invitationId InvitationId, params *OrgslistInvitationTeamsParams, reqEditors ...RequestEditorFn) (*OrgslistInvitationTeamsResponse, error) {
	rsp, err := c.OrgslistInvitationTeams(ctx, org, invitationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistInvitationTeamsResponse(rsp)
}

// IssueslistForOrgWithResponse request returning *IssueslistForOrgResponse
func (c *ClientWithResponses) IssueslistForOrgWithResponse(ctx context.Context, org Org, params *IssueslistForOrgParams, reqEditors ...RequestEditorFn) (*IssueslistForOrgResponse, error) {
	rsp, err := c.IssueslistForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistForOrgResponse(rsp)
}

// OrgslistMembersWithResponse request returning *OrgslistMembersResponse
func (c *ClientWithResponses) OrgslistMembersWithResponse(ctx context.Context, org Org, params *OrgslistMembersParams, reqEditors ...RequestEditorFn) (*OrgslistMembersResponse, error) {
	rsp, err := c.OrgslistMembers(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistMembersResponse(rsp)
}

// OrgsremoveMemberWithResponse request returning *OrgsremoveMemberResponse
func (c *ClientWithResponses) OrgsremoveMemberWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveMemberResponse, error) {
	rsp, err := c.OrgsremoveMember(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsremoveMemberResponse(rsp)
}

// OrgscheckMembershipForUserWithResponse request returning *OrgscheckMembershipForUserResponse
func (c *ClientWithResponses) OrgscheckMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckMembershipForUserResponse, error) {
	rsp, err := c.OrgscheckMembershipForUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscheckMembershipForUserResponse(rsp)
}

// OrgsremoveMembershipForUserWithResponse request returning *OrgsremoveMembershipForUserResponse
func (c *ClientWithResponses) OrgsremoveMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveMembershipForUserResponse, error) {
	rsp, err := c.OrgsremoveMembershipForUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsremoveMembershipForUserResponse(rsp)
}

// OrgsgetMembershipForUserWithResponse request returning *OrgsgetMembershipForUserResponse
func (c *ClientWithResponses) OrgsgetMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsgetMembershipForUserResponse, error) {
	rsp, err := c.OrgsgetMembershipForUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetMembershipForUserResponse(rsp)
}

// OrgssetMembershipForUserWithBodyWithResponse request with arbitrary body returning *OrgssetMembershipForUserResponse
func (c *ClientWithResponses) OrgssetMembershipForUserWithBodyWithResponse(ctx context.Context, org Org, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgssetMembershipForUserResponse, error) {
	rsp, err := c.OrgssetMembershipForUserWithBody(ctx, org, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgssetMembershipForUserResponse(rsp)
}

func (c *ClientWithResponses) OrgssetMembershipForUserWithResponse(ctx context.Context, org Org, username Username, body OrgssetMembershipForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgssetMembershipForUserResponse, error) {
	rsp, err := c.OrgssetMembershipForUser(ctx, org, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgssetMembershipForUserResponse(rsp)
}

// MigrationslistForOrgWithResponse request returning *MigrationslistForOrgResponse
func (c *ClientWithResponses) MigrationslistForOrgWithResponse(ctx context.Context, org Org, params *MigrationslistForOrgParams, reqEditors ...RequestEditorFn) (*MigrationslistForOrgResponse, error) {
	rsp, err := c.MigrationslistForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationslistForOrgResponse(rsp)
}

// MigrationsstartForOrgWithBodyWithResponse request with arbitrary body returning *MigrationsstartForOrgResponse
func (c *ClientWithResponses) MigrationsstartForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartForOrgResponse, error) {
	rsp, err := c.MigrationsstartForOrgWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartForOrgResponse(rsp)
}

func (c *ClientWithResponses) MigrationsstartForOrgWithResponse(ctx context.Context, org Org, body MigrationsstartForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartForOrgResponse, error) {
	rsp, err := c.MigrationsstartForOrg(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartForOrgResponse(rsp)
}

// MigrationsgetStatusForOrgWithResponse request returning *MigrationsgetStatusForOrgResponse
func (c *ClientWithResponses) MigrationsgetStatusForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, params *MigrationsgetStatusForOrgParams, reqEditors ...RequestEditorFn) (*MigrationsgetStatusForOrgResponse, error) {
	rsp, err := c.MigrationsgetStatusForOrg(ctx, org, migrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetStatusForOrgResponse(rsp)
}

// MigrationsdeleteArchiveForOrgWithResponse request returning *MigrationsdeleteArchiveForOrgResponse
func (c *ClientWithResponses) MigrationsdeleteArchiveForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdeleteArchiveForOrgResponse, error) {
	rsp, err := c.MigrationsdeleteArchiveForOrg(ctx, org, migrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsdeleteArchiveForOrgResponse(rsp)
}

// MigrationsdownloadArchiveForOrgWithResponse request returning *MigrationsdownloadArchiveForOrgResponse
func (c *ClientWithResponses) MigrationsdownloadArchiveForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdownloadArchiveForOrgResponse, error) {
	rsp, err := c.MigrationsdownloadArchiveForOrg(ctx, org, migrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsdownloadArchiveForOrgResponse(rsp)
}

// MigrationsunlockRepoForOrgWithResponse request returning *MigrationsunlockRepoForOrgResponse
func (c *ClientWithResponses) MigrationsunlockRepoForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*MigrationsunlockRepoForOrgResponse, error) {
	rsp, err := c.MigrationsunlockRepoForOrg(ctx, org, migrationId, repoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsunlockRepoForOrgResponse(rsp)
}

// MigrationslistReposForOrgWithResponse request returning *MigrationslistReposForOrgResponse
func (c *ClientWithResponses) MigrationslistReposForOrgWithResponse(ctx context.Context, org Org, migrationId MigrationId, params *MigrationslistReposForOrgParams, reqEditors ...RequestEditorFn) (*MigrationslistReposForOrgResponse, error) {
	rsp, err := c.MigrationslistReposForOrg(ctx, org, migrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationslistReposForOrgResponse(rsp)
}

// OrgslistOutsideCollaboratorsWithResponse request returning *OrgslistOutsideCollaboratorsResponse
func (c *ClientWithResponses) OrgslistOutsideCollaboratorsWithResponse(ctx context.Context, org Org, params *OrgslistOutsideCollaboratorsParams, reqEditors ...RequestEditorFn) (*OrgslistOutsideCollaboratorsResponse, error) {
	rsp, err := c.OrgslistOutsideCollaborators(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistOutsideCollaboratorsResponse(rsp)
}

// OrgsremoveOutsideCollaboratorWithResponse request returning *OrgsremoveOutsideCollaboratorResponse
func (c *ClientWithResponses) OrgsremoveOutsideCollaboratorWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremoveOutsideCollaboratorResponse, error) {
	rsp, err := c.OrgsremoveOutsideCollaborator(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsremoveOutsideCollaboratorResponse(rsp)
}

// OrgsconvertMemberToOutsideCollaboratorWithResponse request returning *OrgsconvertMemberToOutsideCollaboratorResponse
func (c *ClientWithResponses) OrgsconvertMemberToOutsideCollaboratorWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsconvertMemberToOutsideCollaboratorResponse, error) {
	rsp, err := c.OrgsconvertMemberToOutsideCollaborator(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsconvertMemberToOutsideCollaboratorResponse(rsp)
}

// PackageslistPackagesForOrganizationWithResponse request returning *PackageslistPackagesForOrganizationResponse
func (c *ClientWithResponses) PackageslistPackagesForOrganizationWithResponse(ctx context.Context, org Org, params *PackageslistPackagesForOrganizationParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForOrganizationResponse, error) {
	rsp, err := c.PackageslistPackagesForOrganization(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackageslistPackagesForOrganizationResponse(rsp)
}

// PackagesdeletePackageForOrgWithResponse request returning *PackagesdeletePackageForOrgResponse
func (c *ClientWithResponses) PackagesdeletePackageForOrgWithResponse(ctx context.Context, org Org, packageType PackagesdeletePackageForOrgParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForOrgResponse, error) {
	rsp, err := c.PackagesdeletePackageForOrg(ctx, org, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageForOrgResponse(rsp)
}

// PackagesgetPackageForOrganizationWithResponse request returning *PackagesgetPackageForOrganizationResponse
func (c *ClientWithResponses) PackagesgetPackageForOrganizationWithResponse(ctx context.Context, org Org, packageType PackagesgetPackageForOrganizationParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForOrganizationResponse, error) {
	rsp, err := c.PackagesgetPackageForOrganization(ctx, org, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageForOrganizationResponse(rsp)
}

// PackagesrestorePackageForOrgWithResponse request returning *PackagesrestorePackageForOrgResponse
func (c *ClientWithResponses) PackagesrestorePackageForOrgWithResponse(ctx context.Context, org Org, packageType PackagesrestorePackageForOrgParamsPackageType, packageName PackageName, params *PackagesrestorePackageForOrgParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForOrgResponse, error) {
	rsp, err := c.PackagesrestorePackageForOrg(ctx, org, packageType, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageForOrgResponse(rsp)
}

// PackagesgetAllPackageVersionsForPackageOwnedByOrgWithResponse request returning *PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse
func (c *ClientWithResponses) PackagesgetAllPackageVersionsForPackageOwnedByOrgWithResponse(ctx context.Context, org Org, packageType PackagesgetAllPackageVersionsForPackageOwnedByOrgParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByOrgParams, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse, error) {
	rsp, err := c.PackagesgetAllPackageVersionsForPackageOwnedByOrg(ctx, org, packageType, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetAllPackageVersionsForPackageOwnedByOrgResponse(rsp)
}

// PackagesdeletePackageVersionForOrgWithResponse request returning *PackagesdeletePackageVersionForOrgResponse
func (c *ClientWithResponses) PackagesdeletePackageVersionForOrgWithResponse(ctx context.Context, org Org, packageType PackagesdeletePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForOrgResponse, error) {
	rsp, err := c.PackagesdeletePackageVersionForOrg(ctx, org, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageVersionForOrgResponse(rsp)
}

// PackagesgetPackageVersionForOrganizationWithResponse request returning *PackagesgetPackageVersionForOrganizationResponse
func (c *ClientWithResponses) PackagesgetPackageVersionForOrganizationWithResponse(ctx context.Context, org Org, packageType PackagesgetPackageVersionForOrganizationParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForOrganizationResponse, error) {
	rsp, err := c.PackagesgetPackageVersionForOrganization(ctx, org, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageVersionForOrganizationResponse(rsp)
}

// PackagesrestorePackageVersionForOrgWithResponse request returning *PackagesrestorePackageVersionForOrgResponse
func (c *ClientWithResponses) PackagesrestorePackageVersionForOrgWithResponse(ctx context.Context, org Org, packageType PackagesrestorePackageVersionForOrgParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForOrgResponse, error) {
	rsp, err := c.PackagesrestorePackageVersionForOrg(ctx, org, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageVersionForOrgResponse(rsp)
}

// ProjectslistForOrgWithResponse request returning *ProjectslistForOrgResponse
func (c *ClientWithResponses) ProjectslistForOrgWithResponse(ctx context.Context, org Org, params *ProjectslistForOrgParams, reqEditors ...RequestEditorFn) (*ProjectslistForOrgResponse, error) {
	rsp, err := c.ProjectslistForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistForOrgResponse(rsp)
}

// ProjectscreateForOrgWithBodyWithResponse request with arbitrary body returning *ProjectscreateForOrgResponse
func (c *ClientWithResponses) ProjectscreateForOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForOrgResponse, error) {
	rsp, err := c.ProjectscreateForOrgWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForOrgResponse(rsp)
}

func (c *ClientWithResponses) ProjectscreateForOrgWithResponse(ctx context.Context, org Org, body ProjectscreateForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForOrgResponse, error) {
	rsp, err := c.ProjectscreateForOrg(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForOrgResponse(rsp)
}

// OrgslistPublicMembersWithResponse request returning *OrgslistPublicMembersResponse
func (c *ClientWithResponses) OrgslistPublicMembersWithResponse(ctx context.Context, org Org, params *OrgslistPublicMembersParams, reqEditors ...RequestEditorFn) (*OrgslistPublicMembersResponse, error) {
	rsp, err := c.OrgslistPublicMembers(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistPublicMembersResponse(rsp)
}

// OrgsremovePublicMembershipForAuthenticatedUserWithResponse request returning *OrgsremovePublicMembershipForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgsremovePublicMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgsremovePublicMembershipForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgsremovePublicMembershipForAuthenticatedUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsremovePublicMembershipForAuthenticatedUserResponse(rsp)
}

// OrgscheckPublicMembershipForUserWithResponse request returning *OrgscheckPublicMembershipForUserResponse
func (c *ClientWithResponses) OrgscheckPublicMembershipForUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgscheckPublicMembershipForUserResponse, error) {
	rsp, err := c.OrgscheckPublicMembershipForUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgscheckPublicMembershipForUserResponse(rsp)
}

// OrgssetPublicMembershipForAuthenticatedUserWithResponse request returning *OrgssetPublicMembershipForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgssetPublicMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, username Username, reqEditors ...RequestEditorFn) (*OrgssetPublicMembershipForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgssetPublicMembershipForAuthenticatedUser(ctx, org, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgssetPublicMembershipForAuthenticatedUserResponse(rsp)
}

// ReposlistForOrgWithResponse request returning *ReposlistForOrgResponse
func (c *ClientWithResponses) ReposlistForOrgWithResponse(ctx context.Context, org Org, params *ReposlistForOrgParams, reqEditors ...RequestEditorFn) (*ReposlistForOrgResponse, error) {
	rsp, err := c.ReposlistForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistForOrgResponse(rsp)
}

// ReposcreateInOrgWithBodyWithResponse request with arbitrary body returning *ReposcreateInOrgResponse
func (c *ClientWithResponses) ReposcreateInOrgWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateInOrgResponse, error) {
	rsp, err := c.ReposcreateInOrgWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateInOrgResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateInOrgWithResponse(ctx context.Context, org Org, body ReposcreateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateInOrgResponse, error) {
	rsp, err := c.ReposcreateInOrg(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateInOrgResponse(rsp)
}

// SecretScanninglistAlertsForOrgWithResponse request returning *SecretScanninglistAlertsForOrgResponse
func (c *ClientWithResponses) SecretScanninglistAlertsForOrgWithResponse(ctx context.Context, org Org, params *SecretScanninglistAlertsForOrgParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForOrgResponse, error) {
	rsp, err := c.SecretScanninglistAlertsForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanninglistAlertsForOrgResponse(rsp)
}

// BillinggetGithubActionsBillingOrgWithResponse request returning *BillinggetGithubActionsBillingOrgResponse
func (c *ClientWithResponses) BillinggetGithubActionsBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingOrgResponse, error) {
	rsp, err := c.BillinggetGithubActionsBillingOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubActionsBillingOrgResponse(rsp)
}

// BillinggetGithubAdvancedSecurityBillingOrgWithResponse request returning *BillinggetGithubAdvancedSecurityBillingOrgResponse
func (c *ClientWithResponses) BillinggetGithubAdvancedSecurityBillingOrgWithResponse(ctx context.Context, org Org, params *BillinggetGithubAdvancedSecurityBillingOrgParams, reqEditors ...RequestEditorFn) (*BillinggetGithubAdvancedSecurityBillingOrgResponse, error) {
	rsp, err := c.BillinggetGithubAdvancedSecurityBillingOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubAdvancedSecurityBillingOrgResponse(rsp)
}

// BillinggetGithubPackagesBillingOrgWithResponse request returning *BillinggetGithubPackagesBillingOrgResponse
func (c *ClientWithResponses) BillinggetGithubPackagesBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingOrgResponse, error) {
	rsp, err := c.BillinggetGithubPackagesBillingOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubPackagesBillingOrgResponse(rsp)
}

// BillinggetSharedStorageBillingOrgWithResponse request returning *BillinggetSharedStorageBillingOrgResponse
func (c *ClientWithResponses) BillinggetSharedStorageBillingOrgWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingOrgResponse, error) {
	rsp, err := c.BillinggetSharedStorageBillingOrg(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetSharedStorageBillingOrgResponse(rsp)
}

// TeamslistIdpGroupsForOrgWithResponse request returning *TeamslistIdpGroupsForOrgResponse
func (c *ClientWithResponses) TeamslistIdpGroupsForOrgWithResponse(ctx context.Context, org Org, params *TeamslistIdpGroupsForOrgParams, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsForOrgResponse, error) {
	rsp, err := c.TeamslistIdpGroupsForOrg(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistIdpGroupsForOrgResponse(rsp)
}

// TeamslistWithResponse request returning *TeamslistResponse
func (c *ClientWithResponses) TeamslistWithResponse(ctx context.Context, org Org, params *TeamslistParams, reqEditors ...RequestEditorFn) (*TeamslistResponse, error) {
	rsp, err := c.Teamslist(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistResponse(rsp)
}

// TeamscreateWithBodyWithResponse request with arbitrary body returning *TeamscreateResponse
func (c *ClientWithResponses) TeamscreateWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateResponse, error) {
	rsp, err := c.TeamscreateWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateWithResponse(ctx context.Context, org Org, body TeamscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateResponse, error) {
	rsp, err := c.Teamscreate(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateResponse(rsp)
}

// TeamsdeleteInOrgWithResponse request returning *TeamsdeleteInOrgResponse
func (c *ClientWithResponses) TeamsdeleteInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsdeleteInOrgResponse, error) {
	rsp, err := c.TeamsdeleteInOrg(ctx, org, teamSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteInOrgResponse(rsp)
}

// TeamsgetByNameWithResponse request returning *TeamsgetByNameResponse
func (c *ClientWithResponses) TeamsgetByNameWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsgetByNameResponse, error) {
	rsp, err := c.TeamsgetByName(ctx, org, teamSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetByNameResponse(rsp)
}

// TeamsupdateInOrgWithBodyWithResponse request with arbitrary body returning *TeamsupdateInOrgResponse
func (c *ClientWithResponses) TeamsupdateInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateInOrgResponse, error) {
	rsp, err := c.TeamsupdateInOrgWithBody(ctx, org, teamSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamsupdateInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateInOrgResponse, error) {
	rsp, err := c.TeamsupdateInOrg(ctx, org, teamSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateInOrgResponse(rsp)
}

// TeamslistDiscussionsInOrgWithResponse request returning *TeamslistDiscussionsInOrgResponse
func (c *ClientWithResponses) TeamslistDiscussionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistDiscussionsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionsInOrgResponse, error) {
	rsp, err := c.TeamslistDiscussionsInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistDiscussionsInOrgResponse(rsp)
}

// TeamscreateDiscussionInOrgWithBodyWithResponse request with arbitrary body returning *TeamscreateDiscussionInOrgResponse
func (c *ClientWithResponses) TeamscreateDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionInOrgResponse, error) {
	rsp, err := c.TeamscreateDiscussionInOrgWithBody(ctx, org, teamSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionInOrgResponse, error) {
	rsp, err := c.TeamscreateDiscussionInOrg(ctx, org, teamSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionInOrgResponse(rsp)
}

// TeamsdeleteDiscussionInOrgWithResponse request returning *TeamsdeleteDiscussionInOrgResponse
func (c *ClientWithResponses) TeamsdeleteDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionInOrgResponse, error) {
	rsp, err := c.TeamsdeleteDiscussionInOrg(ctx, org, teamSlug, discussionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteDiscussionInOrgResponse(rsp)
}

// TeamsgetDiscussionInOrgWithResponse request returning *TeamsgetDiscussionInOrgResponse
func (c *ClientWithResponses) TeamsgetDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionInOrgResponse, error) {
	rsp, err := c.TeamsgetDiscussionInOrg(ctx, org, teamSlug, discussionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetDiscussionInOrgResponse(rsp)
}

// TeamsupdateDiscussionInOrgWithBodyWithResponse request with arbitrary body returning *TeamsupdateDiscussionInOrgResponse
func (c *ClientWithResponses) TeamsupdateDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionInOrgResponse, error) {
	rsp, err := c.TeamsupdateDiscussionInOrgWithBody(ctx, org, teamSlug, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamsupdateDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionInOrgResponse, error) {
	rsp, err := c.TeamsupdateDiscussionInOrg(ctx, org, teamSlug, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionInOrgResponse(rsp)
}

// TeamslistDiscussionCommentsInOrgWithResponse request returning *TeamslistDiscussionCommentsInOrgResponse
func (c *ClientWithResponses) TeamslistDiscussionCommentsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionCommentsInOrgResponse, error) {
	rsp, err := c.TeamslistDiscussionCommentsInOrg(ctx, org, teamSlug, discussionNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistDiscussionCommentsInOrgResponse(rsp)
}

// TeamscreateDiscussionCommentInOrgWithBodyWithResponse request with arbitrary body returning *TeamscreateDiscussionCommentInOrgResponse
func (c *ClientWithResponses) TeamscreateDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamscreateDiscussionCommentInOrgWithBody(ctx, org, teamSlug, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionCommentInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamscreateDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionCommentInOrgResponse(rsp)
}

// TeamsdeleteDiscussionCommentInOrgWithResponse request returning *TeamsdeleteDiscussionCommentInOrgResponse
func (c *ClientWithResponses) TeamsdeleteDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamsdeleteDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, commentNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteDiscussionCommentInOrgResponse(rsp)
}

// TeamsgetDiscussionCommentInOrgWithResponse request returning *TeamsgetDiscussionCommentInOrgResponse
func (c *ClientWithResponses) TeamsgetDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamsgetDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, commentNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetDiscussionCommentInOrgResponse(rsp)
}

// TeamsupdateDiscussionCommentInOrgWithBodyWithResponse request with arbitrary body returning *TeamsupdateDiscussionCommentInOrgResponse
func (c *ClientWithResponses) TeamsupdateDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamsupdateDiscussionCommentInOrgWithBody(ctx, org, teamSlug, discussionNumber, commentNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionCommentInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentInOrgResponse, error) {
	rsp, err := c.TeamsupdateDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, commentNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionCommentInOrgResponse(rsp)
}

// ReactionslistForTeamDiscussionCommentInOrgWithResponse request returning *ReactionslistForTeamDiscussionCommentInOrgResponse
func (c *ClientWithResponses) ReactionslistForTeamDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentInOrgParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionCommentInOrgResponse, error) {
	rsp, err := c.ReactionslistForTeamDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, commentNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForTeamDiscussionCommentInOrgResponse(rsp)
}

// ReactionscreateForTeamDiscussionCommentInOrgWithBodyWithResponse request with arbitrary body returning *ReactionscreateForTeamDiscussionCommentInOrgResponse
func (c *ClientWithResponses) ReactionscreateForTeamDiscussionCommentInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentInOrgResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionCommentInOrgWithBody(ctx, org, teamSlug, discussionNumber, commentNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionCommentInOrgResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForTeamDiscussionCommentInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentInOrgResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionCommentInOrg(ctx, org, teamSlug, discussionNumber, commentNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionCommentInOrgResponse(rsp)
}

// ReactionsdeleteForTeamDiscussionCommentWithResponse request returning *ReactionsdeleteForTeamDiscussionCommentResponse
func (c *ClientWithResponses) ReactionsdeleteForTeamDiscussionCommentWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, commentNumber CommentNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForTeamDiscussionCommentResponse, error) {
	rsp, err := c.ReactionsdeleteForTeamDiscussionComment(ctx, org, teamSlug, discussionNumber, commentNumber, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForTeamDiscussionCommentResponse(rsp)
}

// ReactionslistForTeamDiscussionInOrgWithResponse request returning *ReactionslistForTeamDiscussionInOrgResponse
func (c *ClientWithResponses) ReactionslistForTeamDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionInOrgParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionInOrgResponse, error) {
	rsp, err := c.ReactionslistForTeamDiscussionInOrg(ctx, org, teamSlug, discussionNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForTeamDiscussionInOrgResponse(rsp)
}

// ReactionscreateForTeamDiscussionInOrgWithBodyWithResponse request with arbitrary body returning *ReactionscreateForTeamDiscussionInOrgResponse
func (c *ClientWithResponses) ReactionscreateForTeamDiscussionInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionInOrgResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionInOrgWithBody(ctx, org, teamSlug, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionInOrgResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForTeamDiscussionInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionInOrgResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionInOrg(ctx, org, teamSlug, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionInOrgResponse(rsp)
}

// ReactionsdeleteForTeamDiscussionWithResponse request returning *ReactionsdeleteForTeamDiscussionResponse
func (c *ClientWithResponses) ReactionsdeleteForTeamDiscussionWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, discussionNumber DiscussionNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForTeamDiscussionResponse, error) {
	rsp, err := c.ReactionsdeleteForTeamDiscussion(ctx, org, teamSlug, discussionNumber, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForTeamDiscussionResponse(rsp)
}

// TeamsunlinkExternalIdpGroupFromTeamForOrgWithResponse request returning *TeamsunlinkExternalIdpGroupFromTeamForOrgResponse
func (c *ClientWithResponses) TeamsunlinkExternalIdpGroupFromTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamsunlinkExternalIdpGroupFromTeamForOrgResponse, error) {
	rsp, err := c.TeamsunlinkExternalIdpGroupFromTeamForOrg(ctx, org, teamSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsunlinkExternalIdpGroupFromTeamForOrgResponse(rsp)
}

// TeamslistLinkedExternalIdpGroupsToTeamForOrgWithResponse request returning *TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse
func (c *ClientWithResponses) TeamslistLinkedExternalIdpGroupsToTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse, error) {
	rsp, err := c.TeamslistLinkedExternalIdpGroupsToTeamForOrg(ctx, org, teamSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistLinkedExternalIdpGroupsToTeamForOrgResponse(rsp)
}

// TeamslinkExternalIdpGroupToTeamForOrgWithBodyWithResponse request with arbitrary body returning *TeamslinkExternalIdpGroupToTeamForOrgResponse
func (c *ClientWithResponses) TeamslinkExternalIdpGroupToTeamForOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamslinkExternalIdpGroupToTeamForOrgResponse, error) {
	rsp, err := c.TeamslinkExternalIdpGroupToTeamForOrgWithBody(ctx, org, teamSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslinkExternalIdpGroupToTeamForOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamslinkExternalIdpGroupToTeamForOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamslinkExternalIdpGroupToTeamForOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamslinkExternalIdpGroupToTeamForOrgResponse, error) {
	rsp, err := c.TeamslinkExternalIdpGroupToTeamForOrg(ctx, org, teamSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslinkExternalIdpGroupToTeamForOrgResponse(rsp)
}

// TeamslistPendingInvitationsInOrgWithResponse request returning *TeamslistPendingInvitationsInOrgResponse
func (c *ClientWithResponses) TeamslistPendingInvitationsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistPendingInvitationsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistPendingInvitationsInOrgResponse, error) {
	rsp, err := c.TeamslistPendingInvitationsInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistPendingInvitationsInOrgResponse(rsp)
}

// TeamslistMembersInOrgWithResponse request returning *TeamslistMembersInOrgResponse
func (c *ClientWithResponses) TeamslistMembersInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistMembersInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistMembersInOrgResponse, error) {
	rsp, err := c.TeamslistMembersInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistMembersInOrgResponse(rsp)
}

// TeamsremoveMembershipForUserInOrgWithResponse request returning *TeamsremoveMembershipForUserInOrgResponse
func (c *ClientWithResponses) TeamsremoveMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMembershipForUserInOrgResponse, error) {
	rsp, err := c.TeamsremoveMembershipForUserInOrg(ctx, org, teamSlug, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveMembershipForUserInOrgResponse(rsp)
}

// TeamsgetMembershipForUserInOrgWithResponse request returning *TeamsgetMembershipForUserInOrgResponse
func (c *ClientWithResponses) TeamsgetMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMembershipForUserInOrgResponse, error) {
	rsp, err := c.TeamsgetMembershipForUserInOrg(ctx, org, teamSlug, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetMembershipForUserInOrgResponse(rsp)
}

// TeamsaddOrUpdateMembershipForUserInOrgWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateMembershipForUserInOrgResponse
func (c *ClientWithResponses) TeamsaddOrUpdateMembershipForUserInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateMembershipForUserInOrgWithBody(ctx, org, teamSlug, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateMembershipForUserInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateMembershipForUserInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, username Username, body TeamsaddOrUpdateMembershipForUserInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateMembershipForUserInOrg(ctx, org, teamSlug, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateMembershipForUserInOrgResponse(rsp)
}

// TeamslistProjectsInOrgWithResponse request returning *TeamslistProjectsInOrgResponse
func (c *ClientWithResponses) TeamslistProjectsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistProjectsInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistProjectsInOrgResponse, error) {
	rsp, err := c.TeamslistProjectsInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistProjectsInOrgResponse(rsp)
}

// TeamsremoveProjectInOrgWithResponse request returning *TeamsremoveProjectInOrgResponse
func (c *ClientWithResponses) TeamsremoveProjectInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamsremoveProjectInOrgResponse, error) {
	rsp, err := c.TeamsremoveProjectInOrg(ctx, org, teamSlug, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveProjectInOrgResponse(rsp)
}

// TeamscheckPermissionsForProjectInOrgWithResponse request returning *TeamscheckPermissionsForProjectInOrgResponse
func (c *ClientWithResponses) TeamscheckPermissionsForProjectInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForProjectInOrgResponse, error) {
	rsp, err := c.TeamscheckPermissionsForProjectInOrg(ctx, org, teamSlug, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscheckPermissionsForProjectInOrgResponse(rsp)
}

// TeamsaddOrUpdateProjectPermissionsInOrgWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateProjectPermissionsInOrgResponse
func (c *ClientWithResponses) TeamsaddOrUpdateProjectPermissionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateProjectPermissionsInOrgWithBody(ctx, org, teamSlug, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateProjectPermissionsInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateProjectPermissionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateProjectPermissionsInOrg(ctx, org, teamSlug, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateProjectPermissionsInOrgResponse(rsp)
}

// TeamslistReposInOrgWithResponse request returning *TeamslistReposInOrgResponse
func (c *ClientWithResponses) TeamslistReposInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistReposInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistReposInOrgResponse, error) {
	rsp, err := c.TeamslistReposInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistReposInOrgResponse(rsp)
}

// TeamsremoveRepoInOrgWithResponse request returning *TeamsremoveRepoInOrgResponse
func (c *ClientWithResponses) TeamsremoveRepoInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamsremoveRepoInOrgResponse, error) {
	rsp, err := c.TeamsremoveRepoInOrg(ctx, org, teamSlug, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveRepoInOrgResponse(rsp)
}

// TeamscheckPermissionsForRepoInOrgWithResponse request returning *TeamscheckPermissionsForRepoInOrgResponse
func (c *ClientWithResponses) TeamscheckPermissionsForRepoInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForRepoInOrgResponse, error) {
	rsp, err := c.TeamscheckPermissionsForRepoInOrg(ctx, org, teamSlug, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscheckPermissionsForRepoInOrgResponse(rsp)
}

// TeamsaddOrUpdateRepoPermissionsInOrgWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateRepoPermissionsInOrgResponse
func (c *ClientWithResponses) TeamsaddOrUpdateRepoPermissionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateRepoPermissionsInOrgWithBody(ctx, org, teamSlug, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateRepoPermissionsInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateRepoPermissionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsInOrgResponse, error) {
	rsp, err := c.TeamsaddOrUpdateRepoPermissionsInOrg(ctx, org, teamSlug, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateRepoPermissionsInOrgResponse(rsp)
}

// TeamslistIdpGroupsInOrgWithResponse request returning *TeamslistIdpGroupsInOrgResponse
func (c *ClientWithResponses) TeamslistIdpGroupsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsInOrgResponse, error) {
	rsp, err := c.TeamslistIdpGroupsInOrg(ctx, org, teamSlug, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistIdpGroupsInOrgResponse(rsp)
}

// TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBodyWithResponse request with arbitrary body returning *TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse
func (c *ClientWithResponses) TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBodyWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	rsp, err := c.TeamscreateOrUpdateIdpGroupConnectionsInOrgWithBody(ctx, org, teamSlug, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateOrUpdateIdpGroupConnectionsInOrgResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateOrUpdateIdpGroupConnectionsInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, body TeamscreateOrUpdateIdpGroupConnectionsInOrgJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	rsp, err := c.TeamscreateOrUpdateIdpGroupConnectionsInOrg(ctx, org, teamSlug, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateOrUpdateIdpGroupConnectionsInOrgResponse(rsp)
}

// TeamslistChildInOrgWithResponse request returning *TeamslistChildInOrgResponse
func (c *ClientWithResponses) TeamslistChildInOrgWithResponse(ctx context.Context, org Org, teamSlug TeamSlug, params *TeamslistChildInOrgParams, reqEditors ...RequestEditorFn) (*TeamslistChildInOrgResponse, error) {
	rsp, err := c.TeamslistChildInOrg(ctx, org, teamSlug, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistChildInOrgResponse(rsp)
}

// ProjectsdeleteCardWithResponse request returning *ProjectsdeleteCardResponse
func (c *ClientWithResponses) ProjectsdeleteCardWithResponse(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*ProjectsdeleteCardResponse, error) {
	rsp, err := c.ProjectsdeleteCard(ctx, cardId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsdeleteCardResponse(rsp)
}

// ProjectsgetCardWithResponse request returning *ProjectsgetCardResponse
func (c *ClientWithResponses) ProjectsgetCardWithResponse(ctx context.Context, cardId CardId, reqEditors ...RequestEditorFn) (*ProjectsgetCardResponse, error) {
	rsp, err := c.ProjectsgetCard(ctx, cardId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsgetCardResponse(rsp)
}

// ProjectsupdateCardWithBodyWithResponse request with arbitrary body returning *ProjectsupdateCardResponse
func (c *ClientWithResponses) ProjectsupdateCardWithBodyWithResponse(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateCardResponse, error) {
	rsp, err := c.ProjectsupdateCardWithBody(ctx, cardId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateCardResponse(rsp)
}

func (c *ClientWithResponses) ProjectsupdateCardWithResponse(ctx context.Context, cardId CardId, body ProjectsupdateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateCardResponse, error) {
	rsp, err := c.ProjectsupdateCard(ctx, cardId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateCardResponse(rsp)
}

// ProjectsmoveCardWithBodyWithResponse request with arbitrary body returning *ProjectsmoveCardResponse
func (c *ClientWithResponses) ProjectsmoveCardWithBodyWithResponse(ctx context.Context, cardId CardId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsmoveCardResponse, error) {
	rsp, err := c.ProjectsmoveCardWithBody(ctx, cardId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsmoveCardResponse(rsp)
}

func (c *ClientWithResponses) ProjectsmoveCardWithResponse(ctx context.Context, cardId CardId, body ProjectsmoveCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsmoveCardResponse, error) {
	rsp, err := c.ProjectsmoveCard(ctx, cardId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsmoveCardResponse(rsp)
}

// ProjectsdeleteColumnWithResponse request returning *ProjectsdeleteColumnResponse
func (c *ClientWithResponses) ProjectsdeleteColumnWithResponse(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*ProjectsdeleteColumnResponse, error) {
	rsp, err := c.ProjectsdeleteColumn(ctx, columnId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsdeleteColumnResponse(rsp)
}

// ProjectsgetColumnWithResponse request returning *ProjectsgetColumnResponse
func (c *ClientWithResponses) ProjectsgetColumnWithResponse(ctx context.Context, columnId ColumnId, reqEditors ...RequestEditorFn) (*ProjectsgetColumnResponse, error) {
	rsp, err := c.ProjectsgetColumn(ctx, columnId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsgetColumnResponse(rsp)
}

// ProjectsupdateColumnWithBodyWithResponse request with arbitrary body returning *ProjectsupdateColumnResponse
func (c *ClientWithResponses) ProjectsupdateColumnWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateColumnResponse, error) {
	rsp, err := c.ProjectsupdateColumnWithBody(ctx, columnId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateColumnResponse(rsp)
}

func (c *ClientWithResponses) ProjectsupdateColumnWithResponse(ctx context.Context, columnId ColumnId, body ProjectsupdateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateColumnResponse, error) {
	rsp, err := c.ProjectsupdateColumn(ctx, columnId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateColumnResponse(rsp)
}

// ProjectslistCardsWithResponse request returning *ProjectslistCardsResponse
func (c *ClientWithResponses) ProjectslistCardsWithResponse(ctx context.Context, columnId ColumnId, params *ProjectslistCardsParams, reqEditors ...RequestEditorFn) (*ProjectslistCardsResponse, error) {
	rsp, err := c.ProjectslistCards(ctx, columnId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistCardsResponse(rsp)
}

// ProjectscreateCardWithBodyWithResponse request with arbitrary body returning *ProjectscreateCardResponse
func (c *ClientWithResponses) ProjectscreateCardWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateCardResponse, error) {
	rsp, err := c.ProjectscreateCardWithBody(ctx, columnId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateCardResponse(rsp)
}

func (c *ClientWithResponses) ProjectscreateCardWithResponse(ctx context.Context, columnId ColumnId, body ProjectscreateCardJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateCardResponse, error) {
	rsp, err := c.ProjectscreateCard(ctx, columnId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateCardResponse(rsp)
}

// ProjectsmoveColumnWithBodyWithResponse request with arbitrary body returning *ProjectsmoveColumnResponse
func (c *ClientWithResponses) ProjectsmoveColumnWithBodyWithResponse(ctx context.Context, columnId ColumnId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsmoveColumnResponse, error) {
	rsp, err := c.ProjectsmoveColumnWithBody(ctx, columnId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsmoveColumnResponse(rsp)
}

func (c *ClientWithResponses) ProjectsmoveColumnWithResponse(ctx context.Context, columnId ColumnId, body ProjectsmoveColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsmoveColumnResponse, error) {
	rsp, err := c.ProjectsmoveColumn(ctx, columnId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsmoveColumnResponse(rsp)
}

// ProjectsdeleteWithResponse request returning *ProjectsdeleteResponse
func (c *ClientWithResponses) ProjectsdeleteWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ProjectsdeleteResponse, error) {
	rsp, err := c.Projectsdelete(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsdeleteResponse(rsp)
}

// ProjectsgetWithResponse request returning *ProjectsgetResponse
func (c *ClientWithResponses) ProjectsgetWithResponse(ctx context.Context, projectId ProjectId, reqEditors ...RequestEditorFn) (*ProjectsgetResponse, error) {
	rsp, err := c.Projectsget(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsgetResponse(rsp)
}

// ProjectsupdateWithBodyWithResponse request with arbitrary body returning *ProjectsupdateResponse
func (c *ClientWithResponses) ProjectsupdateWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsupdateResponse, error) {
	rsp, err := c.ProjectsupdateWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateResponse(rsp)
}

func (c *ClientWithResponses) ProjectsupdateWithResponse(ctx context.Context, projectId ProjectId, body ProjectsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsupdateResponse, error) {
	rsp, err := c.Projectsupdate(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsupdateResponse(rsp)
}

// ProjectslistCollaboratorsWithResponse request returning *ProjectslistCollaboratorsResponse
func (c *ClientWithResponses) ProjectslistCollaboratorsWithResponse(ctx context.Context, projectId ProjectId, params *ProjectslistCollaboratorsParams, reqEditors ...RequestEditorFn) (*ProjectslistCollaboratorsResponse, error) {
	rsp, err := c.ProjectslistCollaborators(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistCollaboratorsResponse(rsp)
}

// ProjectsremoveCollaboratorWithResponse request returning *ProjectsremoveCollaboratorResponse
func (c *ClientWithResponses) ProjectsremoveCollaboratorWithResponse(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*ProjectsremoveCollaboratorResponse, error) {
	rsp, err := c.ProjectsremoveCollaborator(ctx, projectId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsremoveCollaboratorResponse(rsp)
}

// ProjectsaddCollaboratorWithBodyWithResponse request with arbitrary body returning *ProjectsaddCollaboratorResponse
func (c *ClientWithResponses) ProjectsaddCollaboratorWithBodyWithResponse(ctx context.Context, projectId ProjectId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectsaddCollaboratorResponse, error) {
	rsp, err := c.ProjectsaddCollaboratorWithBody(ctx, projectId, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsaddCollaboratorResponse(rsp)
}

func (c *ClientWithResponses) ProjectsaddCollaboratorWithResponse(ctx context.Context, projectId ProjectId, username Username, body ProjectsaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectsaddCollaboratorResponse, error) {
	rsp, err := c.ProjectsaddCollaborator(ctx, projectId, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsaddCollaboratorResponse(rsp)
}

// ProjectsgetPermissionForUserWithResponse request returning *ProjectsgetPermissionForUserResponse
func (c *ClientWithResponses) ProjectsgetPermissionForUserWithResponse(ctx context.Context, projectId ProjectId, username Username, reqEditors ...RequestEditorFn) (*ProjectsgetPermissionForUserResponse, error) {
	rsp, err := c.ProjectsgetPermissionForUser(ctx, projectId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsgetPermissionForUserResponse(rsp)
}

// ProjectslistColumnsWithResponse request returning *ProjectslistColumnsResponse
func (c *ClientWithResponses) ProjectslistColumnsWithResponse(ctx context.Context, projectId ProjectId, params *ProjectslistColumnsParams, reqEditors ...RequestEditorFn) (*ProjectslistColumnsResponse, error) {
	rsp, err := c.ProjectslistColumns(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistColumnsResponse(rsp)
}

// ProjectscreateColumnWithBodyWithResponse request with arbitrary body returning *ProjectscreateColumnResponse
func (c *ClientWithResponses) ProjectscreateColumnWithBodyWithResponse(ctx context.Context, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateColumnResponse, error) {
	rsp, err := c.ProjectscreateColumnWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateColumnResponse(rsp)
}

func (c *ClientWithResponses) ProjectscreateColumnWithResponse(ctx context.Context, projectId ProjectId, body ProjectscreateColumnJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateColumnResponse, error) {
	rsp, err := c.ProjectscreateColumn(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateColumnResponse(rsp)
}

// RateLimitgetWithResponse request returning *RateLimitgetResponse
func (c *ClientWithResponses) RateLimitgetWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RateLimitgetResponse, error) {
	rsp, err := c.RateLimitget(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRateLimitgetResponse(rsp)
}

// ReposdeleteWithResponse request returning *ReposdeleteResponse
func (c *ClientWithResponses) ReposdeleteWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdeleteResponse, error) {
	rsp, err := c.Reposdelete(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteResponse(rsp)
}

// ReposgetWithResponse request returning *ReposgetResponse
func (c *ClientWithResponses) ReposgetWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetResponse, error) {
	rsp, err := c.Reposget(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetResponse(rsp)
}

// ReposupdateWithBodyWithResponse request with arbitrary body returning *ReposupdateResponse
func (c *ClientWithResponses) ReposupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateResponse, error) {
	rsp, err := c.ReposupdateWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateResponse, error) {
	rsp, err := c.Reposupdate(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateResponse(rsp)
}

// ActionslistArtifactsForRepoWithResponse request returning *ActionslistArtifactsForRepoResponse
func (c *ClientWithResponses) ActionslistArtifactsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistArtifactsForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistArtifactsForRepoResponse, error) {
	rsp, err := c.ActionslistArtifactsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistArtifactsForRepoResponse(rsp)
}

// ActionsdeleteArtifactWithResponse request returning *ActionsdeleteArtifactResponse
func (c *ClientWithResponses) ActionsdeleteArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*ActionsdeleteArtifactResponse, error) {
	rsp, err := c.ActionsdeleteArtifact(ctx, owner, repo, artifactId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteArtifactResponse(rsp)
}

// ActionsgetArtifactWithResponse request returning *ActionsgetArtifactResponse
func (c *ClientWithResponses) ActionsgetArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, reqEditors ...RequestEditorFn) (*ActionsgetArtifactResponse, error) {
	rsp, err := c.ActionsgetArtifact(ctx, owner, repo, artifactId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetArtifactResponse(rsp)
}

// ActionsdownloadArtifactWithResponse request returning *ActionsdownloadArtifactResponse
func (c *ClientWithResponses) ActionsdownloadArtifactWithResponse(ctx context.Context, owner Owner, repo Repo, artifactId ArtifactId, archiveFormat string, reqEditors ...RequestEditorFn) (*ActionsdownloadArtifactResponse, error) {
	rsp, err := c.ActionsdownloadArtifact(ctx, owner, repo, artifactId, archiveFormat, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdownloadArtifactResponse(rsp)
}

// ActionsgetActionsCacheUsageWithResponse request returning *ActionsgetActionsCacheUsageResponse
func (c *ClientWithResponses) ActionsgetActionsCacheUsageWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetActionsCacheUsageResponse, error) {
	rsp, err := c.ActionsgetActionsCacheUsage(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetActionsCacheUsageResponse(rsp)
}

// ActionsgetJobForWorkflowRunWithResponse request returning *ActionsgetJobForWorkflowRunResponse
func (c *ClientWithResponses) ActionsgetJobForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*ActionsgetJobForWorkflowRunResponse, error) {
	rsp, err := c.ActionsgetJobForWorkflowRun(ctx, owner, repo, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetJobForWorkflowRunResponse(rsp)
}

// ActionsdownloadJobLogsForWorkflowRunWithResponse request returning *ActionsdownloadJobLogsForWorkflowRunResponse
func (c *ClientWithResponses) ActionsdownloadJobLogsForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, reqEditors ...RequestEditorFn) (*ActionsdownloadJobLogsForWorkflowRunResponse, error) {
	rsp, err := c.ActionsdownloadJobLogsForWorkflowRun(ctx, owner, repo, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdownloadJobLogsForWorkflowRunResponse(rsp)
}

// ActionsreRunJobForWorkflowRunWithBodyWithResponse request with arbitrary body returning *ActionsreRunJobForWorkflowRunResponse
func (c *ClientWithResponses) ActionsreRunJobForWorkflowRunWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunJobForWorkflowRunResponse, error) {
	rsp, err := c.ActionsreRunJobForWorkflowRunWithBody(ctx, owner, repo, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunJobForWorkflowRunResponse(rsp)
}

func (c *ClientWithResponses) ActionsreRunJobForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, jobId JobId, body ActionsreRunJobForWorkflowRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunJobForWorkflowRunResponse, error) {
	rsp, err := c.ActionsreRunJobForWorkflowRun(ctx, owner, repo, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunJobForWorkflowRunResponse(rsp)
}

// ActionsgetGithubActionsPermissionsRepositoryWithResponse request returning *ActionsgetGithubActionsPermissionsRepositoryResponse
func (c *ClientWithResponses) ActionsgetGithubActionsPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionsgetGithubActionsPermissionsRepository(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetGithubActionsPermissionsRepositoryResponse(rsp)
}

// ActionssetGithubActionsPermissionsRepositoryWithBodyWithResponse request with arbitrary body returning *ActionssetGithubActionsPermissionsRepositoryResponse
func (c *ClientWithResponses) ActionssetGithubActionsPermissionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionssetGithubActionsPermissionsRepositoryWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsPermissionsRepositoryResponse(rsp)
}

func (c *ClientWithResponses) ActionssetGithubActionsPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionssetGithubActionsPermissionsRepository(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsPermissionsRepositoryResponse(rsp)
}

// ActionsgetWorkflowAccessToRepositoryWithResponse request returning *ActionsgetWorkflowAccessToRepositoryResponse
func (c *ClientWithResponses) ActionsgetWorkflowAccessToRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowAccessToRepositoryResponse, error) {
	rsp, err := c.ActionsgetWorkflowAccessToRepository(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowAccessToRepositoryResponse(rsp)
}

// ActionssetWorkflowAccessToRepositoryWithBodyWithResponse request with arbitrary body returning *ActionssetWorkflowAccessToRepositoryResponse
func (c *ClientWithResponses) ActionssetWorkflowAccessToRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetWorkflowAccessToRepositoryResponse, error) {
	rsp, err := c.ActionssetWorkflowAccessToRepositoryWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetWorkflowAccessToRepositoryResponse(rsp)
}

func (c *ClientWithResponses) ActionssetWorkflowAccessToRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetWorkflowAccessToRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetWorkflowAccessToRepositoryResponse, error) {
	rsp, err := c.ActionssetWorkflowAccessToRepository(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetWorkflowAccessToRepositoryResponse(rsp)
}

// ActionsgetAllowedActionsRepositoryWithResponse request returning *ActionsgetAllowedActionsRepositoryResponse
func (c *ClientWithResponses) ActionsgetAllowedActionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetAllowedActionsRepositoryResponse, error) {
	rsp, err := c.ActionsgetAllowedActionsRepository(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetAllowedActionsRepositoryResponse(rsp)
}

// ActionssetAllowedActionsRepositoryWithBodyWithResponse request with arbitrary body returning *ActionssetAllowedActionsRepositoryResponse
func (c *ClientWithResponses) ActionssetAllowedActionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsRepositoryResponse, error) {
	rsp, err := c.ActionssetAllowedActionsRepositoryWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetAllowedActionsRepositoryResponse(rsp)
}

func (c *ClientWithResponses) ActionssetAllowedActionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetAllowedActionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetAllowedActionsRepositoryResponse, error) {
	rsp, err := c.ActionssetAllowedActionsRepository(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetAllowedActionsRepositoryResponse(rsp)
}

// ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse request returning *ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse
func (c *ClientWithResponses) ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionsgetGithubActionsDefaultWorkflowPermissionsRepository(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse(rsp)
}

// ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBodyWithResponse request with arbitrary body returning *ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse
func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse(rsp)
}

func (c *ClientWithResponses) ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse(ctx context.Context, owner Owner, repo Repo, body ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	rsp, err := c.ActionssetGithubActionsDefaultWorkflowPermissionsRepository(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse(rsp)
}

// ActionslistSelfHostedRunnersForRepoWithResponse request returning *ActionslistSelfHostedRunnersForRepoResponse
func (c *ClientWithResponses) ActionslistSelfHostedRunnersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistSelfHostedRunnersForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistSelfHostedRunnersForRepoResponse, error) {
	rsp, err := c.ActionslistSelfHostedRunnersForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistSelfHostedRunnersForRepoResponse(rsp)
}

// ActionslistRunnerApplicationsForRepoWithResponse request returning *ActionslistRunnerApplicationsForRepoResponse
func (c *ClientWithResponses) ActionslistRunnerApplicationsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionslistRunnerApplicationsForRepoResponse, error) {
	rsp, err := c.ActionslistRunnerApplicationsForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistRunnerApplicationsForRepoResponse(rsp)
}

// ActionscreateRegistrationTokenForRepoWithResponse request returning *ActionscreateRegistrationTokenForRepoResponse
func (c *ClientWithResponses) ActionscreateRegistrationTokenForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionscreateRegistrationTokenForRepoResponse, error) {
	rsp, err := c.ActionscreateRegistrationTokenForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateRegistrationTokenForRepoResponse(rsp)
}

// ActionscreateRemoveTokenForRepoWithResponse request returning *ActionscreateRemoveTokenForRepoResponse
func (c *ClientWithResponses) ActionscreateRemoveTokenForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionscreateRemoveTokenForRepoResponse, error) {
	rsp, err := c.ActionscreateRemoveTokenForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateRemoveTokenForRepoResponse(rsp)
}

// ActionsdeleteSelfHostedRunnerFromRepoWithResponse request returning *ActionsdeleteSelfHostedRunnerFromRepoResponse
func (c *ClientWithResponses) ActionsdeleteSelfHostedRunnerFromRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsdeleteSelfHostedRunnerFromRepoResponse, error) {
	rsp, err := c.ActionsdeleteSelfHostedRunnerFromRepo(ctx, owner, repo, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteSelfHostedRunnerFromRepoResponse(rsp)
}

// ActionsgetSelfHostedRunnerForRepoWithResponse request returning *ActionsgetSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionsgetSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsgetSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionsgetSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetSelfHostedRunnerForRepoResponse(rsp)
}

// ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoWithResponse request returning *ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse(rsp)
}

// ActionslistLabelsForSelfHostedRunnerForRepoWithResponse request returning *ActionslistLabelsForSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionslistLabelsForSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, reqEditors ...RequestEditorFn) (*ActionslistLabelsForSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionslistLabelsForSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistLabelsForSelfHostedRunnerForRepoResponse(rsp)
}

// ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBodyWithResponse request with arbitrary body returning *ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithBody(ctx, owner, repo, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse(rsp)
}

func (c *ClientWithResponses) ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionsaddCustomLabelsToSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionsaddCustomLabelsToSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse(rsp)
}

// ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBodyWithResponse request with arbitrary body returning *ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionssetCustomLabelsForSelfHostedRunnerForRepoWithBody(ctx, owner, repo, runnerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetCustomLabelsForSelfHostedRunnerForRepoResponse(rsp)
}

func (c *ClientWithResponses) ActionssetCustomLabelsForSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, body ActionssetCustomLabelsForSelfHostedRunnerForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionssetCustomLabelsForSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionssetCustomLabelsForSelfHostedRunnerForRepoResponse(rsp)
}

// ActionsremoveCustomLabelFromSelfHostedRunnerForRepoWithResponse request returning *ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse
func (c *ClientWithResponses) ActionsremoveCustomLabelFromSelfHostedRunnerForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, runnerId RunnerId, name RunnerLabelName, reqEditors ...RequestEditorFn) (*ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse, error) {
	rsp, err := c.ActionsremoveCustomLabelFromSelfHostedRunnerForRepo(ctx, owner, repo, runnerId, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse(rsp)
}

// ActionslistWorkflowRunsForRepoWithResponse request returning *ActionslistWorkflowRunsForRepoResponse
func (c *ClientWithResponses) ActionslistWorkflowRunsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistWorkflowRunsForRepoParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunsForRepoResponse, error) {
	rsp, err := c.ActionslistWorkflowRunsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistWorkflowRunsForRepoResponse(rsp)
}

// ActionsdeleteWorkflowRunWithResponse request returning *ActionsdeleteWorkflowRunResponse
func (c *ClientWithResponses) ActionsdeleteWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdeleteWorkflowRunResponse, error) {
	rsp, err := c.ActionsdeleteWorkflowRun(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteWorkflowRunResponse(rsp)
}

// ActionsgetWorkflowRunWithResponse request returning *ActionsgetWorkflowRunResponse
func (c *ClientWithResponses) ActionsgetWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionsgetWorkflowRunParams, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunResponse, error) {
	rsp, err := c.ActionsgetWorkflowRun(ctx, owner, repo, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowRunResponse(rsp)
}

// ActionsgetReviewsForRunWithResponse request returning *ActionsgetReviewsForRunResponse
func (c *ClientWithResponses) ActionsgetReviewsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetReviewsForRunResponse, error) {
	rsp, err := c.ActionsgetReviewsForRun(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetReviewsForRunResponse(rsp)
}

// ActionsapproveWorkflowRunWithResponse request returning *ActionsapproveWorkflowRunResponse
func (c *ClientWithResponses) ActionsapproveWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsapproveWorkflowRunResponse, error) {
	rsp, err := c.ActionsapproveWorkflowRun(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsapproveWorkflowRunResponse(rsp)
}

// ActionslistWorkflowRunArtifactsWithResponse request returning *ActionslistWorkflowRunArtifactsResponse
func (c *ClientWithResponses) ActionslistWorkflowRunArtifactsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistWorkflowRunArtifactsParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunArtifactsResponse, error) {
	rsp, err := c.ActionslistWorkflowRunArtifacts(ctx, owner, repo, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistWorkflowRunArtifactsResponse(rsp)
}

// ActionsgetWorkflowRunAttemptWithResponse request returning *ActionsgetWorkflowRunAttemptResponse
func (c *ClientWithResponses) ActionsgetWorkflowRunAttemptWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionsgetWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunAttemptResponse, error) {
	rsp, err := c.ActionsgetWorkflowRunAttempt(ctx, owner, repo, runId, attemptNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowRunAttemptResponse(rsp)
}

// ActionslistJobsForWorkflowRunAttemptWithResponse request returning *ActionslistJobsForWorkflowRunAttemptResponse
func (c *ClientWithResponses) ActionslistJobsForWorkflowRunAttemptWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, params *ActionslistJobsForWorkflowRunAttemptParams, reqEditors ...RequestEditorFn) (*ActionslistJobsForWorkflowRunAttemptResponse, error) {
	rsp, err := c.ActionslistJobsForWorkflowRunAttempt(ctx, owner, repo, runId, attemptNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistJobsForWorkflowRunAttemptResponse(rsp)
}

// ActionsdownloadWorkflowRunAttemptLogsWithResponse request returning *ActionsdownloadWorkflowRunAttemptLogsResponse
func (c *ClientWithResponses) ActionsdownloadWorkflowRunAttemptLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, attemptNumber AttemptNumber, reqEditors ...RequestEditorFn) (*ActionsdownloadWorkflowRunAttemptLogsResponse, error) {
	rsp, err := c.ActionsdownloadWorkflowRunAttemptLogs(ctx, owner, repo, runId, attemptNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdownloadWorkflowRunAttemptLogsResponse(rsp)
}

// ActionscancelWorkflowRunWithResponse request returning *ActionscancelWorkflowRunResponse
func (c *ClientWithResponses) ActionscancelWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionscancelWorkflowRunResponse, error) {
	rsp, err := c.ActionscancelWorkflowRun(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscancelWorkflowRunResponse(rsp)
}

// ActionslistJobsForWorkflowRunWithResponse request returning *ActionslistJobsForWorkflowRunResponse
func (c *ClientWithResponses) ActionslistJobsForWorkflowRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, params *ActionslistJobsForWorkflowRunParams, reqEditors ...RequestEditorFn) (*ActionslistJobsForWorkflowRunResponse, error) {
	rsp, err := c.ActionslistJobsForWorkflowRun(ctx, owner, repo, runId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistJobsForWorkflowRunResponse(rsp)
}

// ActionsdeleteWorkflowRunLogsWithResponse request returning *ActionsdeleteWorkflowRunLogsResponse
func (c *ClientWithResponses) ActionsdeleteWorkflowRunLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdeleteWorkflowRunLogsResponse, error) {
	rsp, err := c.ActionsdeleteWorkflowRunLogs(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteWorkflowRunLogsResponse(rsp)
}

// ActionsdownloadWorkflowRunLogsWithResponse request returning *ActionsdownloadWorkflowRunLogsResponse
func (c *ClientWithResponses) ActionsdownloadWorkflowRunLogsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsdownloadWorkflowRunLogsResponse, error) {
	rsp, err := c.ActionsdownloadWorkflowRunLogs(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdownloadWorkflowRunLogsResponse(rsp)
}

// ActionsgetPendingDeploymentsForRunWithResponse request returning *ActionsgetPendingDeploymentsForRunResponse
func (c *ClientWithResponses) ActionsgetPendingDeploymentsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetPendingDeploymentsForRunResponse, error) {
	rsp, err := c.ActionsgetPendingDeploymentsForRun(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetPendingDeploymentsForRunResponse(rsp)
}

// ActionsreviewPendingDeploymentsForRunWithBodyWithResponse request with arbitrary body returning *ActionsreviewPendingDeploymentsForRunResponse
func (c *ClientWithResponses) ActionsreviewPendingDeploymentsForRunWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreviewPendingDeploymentsForRunResponse, error) {
	rsp, err := c.ActionsreviewPendingDeploymentsForRunWithBody(ctx, owner, repo, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreviewPendingDeploymentsForRunResponse(rsp)
}

func (c *ClientWithResponses) ActionsreviewPendingDeploymentsForRunWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreviewPendingDeploymentsForRunJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreviewPendingDeploymentsForRunResponse, error) {
	rsp, err := c.ActionsreviewPendingDeploymentsForRun(ctx, owner, repo, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreviewPendingDeploymentsForRunResponse(rsp)
}

// ActionsreRunWorkflowWithBodyWithResponse request with arbitrary body returning *ActionsreRunWorkflowResponse
func (c *ClientWithResponses) ActionsreRunWorkflowWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowResponse, error) {
	rsp, err := c.ActionsreRunWorkflowWithBody(ctx, owner, repo, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunWorkflowResponse(rsp)
}

func (c *ClientWithResponses) ActionsreRunWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowResponse, error) {
	rsp, err := c.ActionsreRunWorkflow(ctx, owner, repo, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunWorkflowResponse(rsp)
}

// ActionsreRunWorkflowFailedJobsWithBodyWithResponse request with arbitrary body returning *ActionsreRunWorkflowFailedJobsResponse
func (c *ClientWithResponses) ActionsreRunWorkflowFailedJobsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowFailedJobsResponse, error) {
	rsp, err := c.ActionsreRunWorkflowFailedJobsWithBody(ctx, owner, repo, runId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunWorkflowFailedJobsResponse(rsp)
}

func (c *ClientWithResponses) ActionsreRunWorkflowFailedJobsWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, body ActionsreRunWorkflowFailedJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionsreRunWorkflowFailedJobsResponse, error) {
	rsp, err := c.ActionsreRunWorkflowFailedJobs(ctx, owner, repo, runId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsreRunWorkflowFailedJobsResponse(rsp)
}

// ActionsgetWorkflowRunUsageWithResponse request returning *ActionsgetWorkflowRunUsageResponse
func (c *ClientWithResponses) ActionsgetWorkflowRunUsageWithResponse(ctx context.Context, owner Owner, repo Repo, runId RunId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowRunUsageResponse, error) {
	rsp, err := c.ActionsgetWorkflowRunUsage(ctx, owner, repo, runId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowRunUsageResponse(rsp)
}

// ActionslistRepoSecretsWithResponse request returning *ActionslistRepoSecretsResponse
func (c *ClientWithResponses) ActionslistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistRepoSecretsResponse, error) {
	rsp, err := c.ActionslistRepoSecrets(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistRepoSecretsResponse(rsp)
}

// ActionsgetRepoPublicKeyWithResponse request returning *ActionsgetRepoPublicKeyResponse
func (c *ClientWithResponses) ActionsgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActionsgetRepoPublicKeyResponse, error) {
	rsp, err := c.ActionsgetRepoPublicKey(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetRepoPublicKeyResponse(rsp)
}

// ActionsdeleteRepoSecretWithResponse request returning *ActionsdeleteRepoSecretResponse
func (c *ClientWithResponses) ActionsdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteRepoSecretResponse, error) {
	rsp, err := c.ActionsdeleteRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteRepoSecretResponse(rsp)
}

// ActionsgetRepoSecretWithResponse request returning *ActionsgetRepoSecretResponse
func (c *ClientWithResponses) ActionsgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetRepoSecretResponse, error) {
	rsp, err := c.ActionsgetRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetRepoSecretResponse(rsp)
}

// ActionscreateOrUpdateRepoSecretWithBodyWithResponse request with arbitrary body returning *ActionscreateOrUpdateRepoSecretResponse
func (c *ClientWithResponses) ActionscreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateRepoSecretWithBody(ctx, owner, repo, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateRepoSecretResponse(rsp)
}

func (c *ClientWithResponses) ActionscreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body ActionscreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateRepoSecret(ctx, owner, repo, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateRepoSecretResponse(rsp)
}

// ActionslistRepoWorkflowsWithResponse request returning *ActionslistRepoWorkflowsResponse
func (c *ClientWithResponses) ActionslistRepoWorkflowsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActionslistRepoWorkflowsParams, reqEditors ...RequestEditorFn) (*ActionslistRepoWorkflowsResponse, error) {
	rsp, err := c.ActionslistRepoWorkflows(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistRepoWorkflowsResponse(rsp)
}

// ActionsgetWorkflowWithResponse request returning *ActionsgetWorkflowResponse
func (c *ClientWithResponses) ActionsgetWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowResponse, error) {
	rsp, err := c.ActionsgetWorkflow(ctx, owner, repo, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowResponse(rsp)
}

// ActionsdisableWorkflowWithResponse request returning *ActionsdisableWorkflowResponse
func (c *ClientWithResponses) ActionsdisableWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsdisableWorkflowResponse, error) {
	rsp, err := c.ActionsdisableWorkflow(ctx, owner, repo, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdisableWorkflowResponse(rsp)
}

// ActionscreateWorkflowDispatchWithBodyWithResponse request with arbitrary body returning *ActionscreateWorkflowDispatchResponse
func (c *ClientWithResponses) ActionscreateWorkflowDispatchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateWorkflowDispatchResponse, error) {
	rsp, err := c.ActionscreateWorkflowDispatchWithBody(ctx, owner, repo, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateWorkflowDispatchResponse(rsp)
}

func (c *ClientWithResponses) ActionscreateWorkflowDispatchWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, body ActionscreateWorkflowDispatchJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateWorkflowDispatchResponse, error) {
	rsp, err := c.ActionscreateWorkflowDispatch(ctx, owner, repo, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateWorkflowDispatchResponse(rsp)
}

// ActionsenableWorkflowWithResponse request returning *ActionsenableWorkflowResponse
func (c *ClientWithResponses) ActionsenableWorkflowWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsenableWorkflowResponse, error) {
	rsp, err := c.ActionsenableWorkflow(ctx, owner, repo, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsenableWorkflowResponse(rsp)
}

// ActionslistWorkflowRunsWithResponse request returning *ActionslistWorkflowRunsResponse
func (c *ClientWithResponses) ActionslistWorkflowRunsWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, params *ActionslistWorkflowRunsParams, reqEditors ...RequestEditorFn) (*ActionslistWorkflowRunsResponse, error) {
	rsp, err := c.ActionslistWorkflowRuns(ctx, owner, repo, workflowId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistWorkflowRunsResponse(rsp)
}

// ActionsgetWorkflowUsageWithResponse request returning *ActionsgetWorkflowUsageResponse
func (c *ClientWithResponses) ActionsgetWorkflowUsageWithResponse(ctx context.Context, owner Owner, repo Repo, workflowId WorkflowId, reqEditors ...RequestEditorFn) (*ActionsgetWorkflowUsageResponse, error) {
	rsp, err := c.ActionsgetWorkflowUsage(ctx, owner, repo, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetWorkflowUsageResponse(rsp)
}

// IssueslistAssigneesWithResponse request returning *IssueslistAssigneesResponse
func (c *ClientWithResponses) IssueslistAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistAssigneesParams, reqEditors ...RequestEditorFn) (*IssueslistAssigneesResponse, error) {
	rsp, err := c.IssueslistAssignees(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistAssigneesResponse(rsp)
}

// IssuescheckUserCanBeAssignedWithResponse request returning *IssuescheckUserCanBeAssignedResponse
func (c *ClientWithResponses) IssuescheckUserCanBeAssignedWithResponse(ctx context.Context, owner Owner, repo Repo, assignee string, reqEditors ...RequestEditorFn) (*IssuescheckUserCanBeAssignedResponse, error) {
	rsp, err := c.IssuescheckUserCanBeAssigned(ctx, owner, repo, assignee, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescheckUserCanBeAssignedResponse(rsp)
}

// ReposlistAutolinksWithResponse request returning *ReposlistAutolinksResponse
func (c *ClientWithResponses) ReposlistAutolinksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistAutolinksParams, reqEditors ...RequestEditorFn) (*ReposlistAutolinksResponse, error) {
	rsp, err := c.ReposlistAutolinks(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistAutolinksResponse(rsp)
}

// ReposcreateAutolinkWithBodyWithResponse request with arbitrary body returning *ReposcreateAutolinkResponse
func (c *ClientWithResponses) ReposcreateAutolinkWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateAutolinkResponse, error) {
	rsp, err := c.ReposcreateAutolinkWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateAutolinkResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateAutolinkJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateAutolinkResponse, error) {
	rsp, err := c.ReposcreateAutolink(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateAutolinkResponse(rsp)
}

// ReposdeleteAutolinkWithResponse request returning *ReposdeleteAutolinkResponse
func (c *ClientWithResponses) ReposdeleteAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*ReposdeleteAutolinkResponse, error) {
	rsp, err := c.ReposdeleteAutolink(ctx, owner, repo, autolinkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteAutolinkResponse(rsp)
}

// ReposgetAutolinkWithResponse request returning *ReposgetAutolinkResponse
func (c *ClientWithResponses) ReposgetAutolinkWithResponse(ctx context.Context, owner Owner, repo Repo, autolinkId AutolinkId, reqEditors ...RequestEditorFn) (*ReposgetAutolinkResponse, error) {
	rsp, err := c.ReposgetAutolink(ctx, owner, repo, autolinkId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAutolinkResponse(rsp)
}

// ReposdisableAutomatedSecurityFixesWithResponse request returning *ReposdisableAutomatedSecurityFixesResponse
func (c *ClientWithResponses) ReposdisableAutomatedSecurityFixesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableAutomatedSecurityFixesResponse, error) {
	rsp, err := c.ReposdisableAutomatedSecurityFixes(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdisableAutomatedSecurityFixesResponse(rsp)
}

// ReposenableAutomatedSecurityFixesWithResponse request returning *ReposenableAutomatedSecurityFixesResponse
func (c *ClientWithResponses) ReposenableAutomatedSecurityFixesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableAutomatedSecurityFixesResponse, error) {
	rsp, err := c.ReposenableAutomatedSecurityFixes(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposenableAutomatedSecurityFixesResponse(rsp)
}

// ReposlistBranchesWithResponse request returning *ReposlistBranchesResponse
func (c *ClientWithResponses) ReposlistBranchesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistBranchesParams, reqEditors ...RequestEditorFn) (*ReposlistBranchesResponse, error) {
	rsp, err := c.ReposlistBranches(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistBranchesResponse(rsp)
}

// ReposgetBranchWithResponse request returning *ReposgetBranchResponse
func (c *ClientWithResponses) ReposgetBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetBranchResponse, error) {
	rsp, err := c.ReposgetBranch(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetBranchResponse(rsp)
}

// ReposdeleteBranchProtectionWithResponse request returning *ReposdeleteBranchProtectionResponse
func (c *ClientWithResponses) ReposdeleteBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteBranchProtectionResponse, error) {
	rsp, err := c.ReposdeleteBranchProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteBranchProtectionResponse(rsp)
}

// ReposgetBranchProtectionWithResponse request returning *ReposgetBranchProtectionResponse
func (c *ClientWithResponses) ReposgetBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetBranchProtectionResponse, error) {
	rsp, err := c.ReposgetBranchProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetBranchProtectionResponse(rsp)
}

// ReposupdateBranchProtectionWithBodyWithResponse request with arbitrary body returning *ReposupdateBranchProtectionResponse
func (c *ClientWithResponses) ReposupdateBranchProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateBranchProtectionResponse, error) {
	rsp, err := c.ReposupdateBranchProtectionWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateBranchProtectionResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateBranchProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateBranchProtectionResponse, error) {
	rsp, err := c.ReposupdateBranchProtection(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateBranchProtectionResponse(rsp)
}

// ReposdeleteAdminBranchProtectionWithResponse request returning *ReposdeleteAdminBranchProtectionResponse
func (c *ClientWithResponses) ReposdeleteAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteAdminBranchProtectionResponse, error) {
	rsp, err := c.ReposdeleteAdminBranchProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteAdminBranchProtectionResponse(rsp)
}

// ReposgetAdminBranchProtectionWithResponse request returning *ReposgetAdminBranchProtectionResponse
func (c *ClientWithResponses) ReposgetAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAdminBranchProtectionResponse, error) {
	rsp, err := c.ReposgetAdminBranchProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAdminBranchProtectionResponse(rsp)
}

// RepossetAdminBranchProtectionWithResponse request returning *RepossetAdminBranchProtectionResponse
func (c *ClientWithResponses) RepossetAdminBranchProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*RepossetAdminBranchProtectionResponse, error) {
	rsp, err := c.RepossetAdminBranchProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetAdminBranchProtectionResponse(rsp)
}

// ReposdeletePullRequestReviewProtectionWithResponse request returning *ReposdeletePullRequestReviewProtectionResponse
func (c *ClientWithResponses) ReposdeletePullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeletePullRequestReviewProtectionResponse, error) {
	rsp, err := c.ReposdeletePullRequestReviewProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeletePullRequestReviewProtectionResponse(rsp)
}

// ReposgetPullRequestReviewProtectionWithResponse request returning *ReposgetPullRequestReviewProtectionResponse
func (c *ClientWithResponses) ReposgetPullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetPullRequestReviewProtectionResponse, error) {
	rsp, err := c.ReposgetPullRequestReviewProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetPullRequestReviewProtectionResponse(rsp)
}

// ReposupdatePullRequestReviewProtectionWithBodyWithResponse request with arbitrary body returning *ReposupdatePullRequestReviewProtectionResponse
func (c *ClientWithResponses) ReposupdatePullRequestReviewProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdatePullRequestReviewProtectionResponse, error) {
	rsp, err := c.ReposupdatePullRequestReviewProtectionWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdatePullRequestReviewProtectionResponse(rsp)
}

func (c *ClientWithResponses) ReposupdatePullRequestReviewProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdatePullRequestReviewProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdatePullRequestReviewProtectionResponse, error) {
	rsp, err := c.ReposupdatePullRequestReviewProtection(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdatePullRequestReviewProtectionResponse(rsp)
}

// ReposdeleteCommitSignatureProtectionWithResponse request returning *ReposdeleteCommitSignatureProtectionResponse
func (c *ClientWithResponses) ReposdeleteCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteCommitSignatureProtectionResponse, error) {
	rsp, err := c.ReposdeleteCommitSignatureProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteCommitSignatureProtectionResponse(rsp)
}

// ReposgetCommitSignatureProtectionWithResponse request returning *ReposgetCommitSignatureProtectionResponse
func (c *ClientWithResponses) ReposgetCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetCommitSignatureProtectionResponse, error) {
	rsp, err := c.ReposgetCommitSignatureProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommitSignatureProtectionResponse(rsp)
}

// ReposcreateCommitSignatureProtectionWithResponse request returning *ReposcreateCommitSignatureProtectionResponse
func (c *ClientWithResponses) ReposcreateCommitSignatureProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposcreateCommitSignatureProtectionResponse, error) {
	rsp, err := c.ReposcreateCommitSignatureProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateCommitSignatureProtectionResponse(rsp)
}

// ReposremoveStatusCheckProtectionWithResponse request returning *ReposremoveStatusCheckProtectionResponse
func (c *ClientWithResponses) ReposremoveStatusCheckProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckProtectionResponse, error) {
	rsp, err := c.ReposremoveStatusCheckProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveStatusCheckProtectionResponse(rsp)
}

// ReposgetStatusChecksProtectionWithResponse request returning *ReposgetStatusChecksProtectionResponse
func (c *ClientWithResponses) ReposgetStatusChecksProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetStatusChecksProtectionResponse, error) {
	rsp, err := c.ReposgetStatusChecksProtection(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetStatusChecksProtectionResponse(rsp)
}

// ReposupdateStatusCheckProtectionWithBodyWithResponse request with arbitrary body returning *ReposupdateStatusCheckProtectionResponse
func (c *ClientWithResponses) ReposupdateStatusCheckProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateStatusCheckProtectionResponse, error) {
	rsp, err := c.ReposupdateStatusCheckProtectionWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateStatusCheckProtectionResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateStatusCheckProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposupdateStatusCheckProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateStatusCheckProtectionResponse, error) {
	rsp, err := c.ReposupdateStatusCheckProtection(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateStatusCheckProtectionResponse(rsp)
}

// ReposremoveStatusCheckContextsWithBodyWithResponse request with arbitrary body returning *ReposremoveStatusCheckContextsResponse
func (c *ClientWithResponses) ReposremoveStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckContextsResponse, error) {
	rsp, err := c.ReposremoveStatusCheckContextsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveStatusCheckContextsResponse(rsp)
}

func (c *ClientWithResponses) ReposremoveStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveStatusCheckContextsResponse, error) {
	rsp, err := c.ReposremoveStatusCheckContexts(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveStatusCheckContextsResponse(rsp)
}

// ReposgetAllStatusCheckContextsWithResponse request returning *ReposgetAllStatusCheckContextsResponse
func (c *ClientWithResponses) ReposgetAllStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAllStatusCheckContextsResponse, error) {
	rsp, err := c.ReposgetAllStatusCheckContexts(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAllStatusCheckContextsResponse(rsp)
}

// ReposaddStatusCheckContextsWithBodyWithResponse request with arbitrary body returning *ReposaddStatusCheckContextsResponse
func (c *ClientWithResponses) ReposaddStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddStatusCheckContextsResponse, error) {
	rsp, err := c.ReposaddStatusCheckContextsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddStatusCheckContextsResponse(rsp)
}

func (c *ClientWithResponses) ReposaddStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddStatusCheckContextsResponse, error) {
	rsp, err := c.ReposaddStatusCheckContexts(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddStatusCheckContextsResponse(rsp)
}

// RepossetStatusCheckContextsWithBodyWithResponse request with arbitrary body returning *RepossetStatusCheckContextsResponse
func (c *ClientWithResponses) RepossetStatusCheckContextsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetStatusCheckContextsResponse, error) {
	rsp, err := c.RepossetStatusCheckContextsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetStatusCheckContextsResponse(rsp)
}

func (c *ClientWithResponses) RepossetStatusCheckContextsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetStatusCheckContextsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetStatusCheckContextsResponse, error) {
	rsp, err := c.RepossetStatusCheckContexts(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetStatusCheckContextsResponse(rsp)
}

// ReposdeleteAccessRestrictionsWithResponse request returning *ReposdeleteAccessRestrictionsResponse
func (c *ClientWithResponses) ReposdeleteAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposdeleteAccessRestrictionsResponse, error) {
	rsp, err := c.ReposdeleteAccessRestrictions(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteAccessRestrictionsResponse(rsp)
}

// ReposgetAccessRestrictionsWithResponse request returning *ReposgetAccessRestrictionsResponse
func (c *ClientWithResponses) ReposgetAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAccessRestrictionsResponse, error) {
	rsp, err := c.ReposgetAccessRestrictions(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAccessRestrictionsResponse(rsp)
}

// ReposremoveAppAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposremoveAppAccessRestrictionsResponse
func (c *ClientWithResponses) ReposremoveAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveAppAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveAppAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveAppAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposremoveAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveAppAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveAppAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveAppAccessRestrictionsResponse(rsp)
}

// ReposgetAppsWithAccessToProtectedBranchWithResponse request returning *ReposgetAppsWithAccessToProtectedBranchResponse
func (c *ClientWithResponses) ReposgetAppsWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetAppsWithAccessToProtectedBranchResponse, error) {
	rsp, err := c.ReposgetAppsWithAccessToProtectedBranch(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAppsWithAccessToProtectedBranchResponse(rsp)
}

// ReposaddAppAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposaddAppAccessRestrictionsResponse
func (c *ClientWithResponses) ReposaddAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddAppAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddAppAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddAppAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposaddAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddAppAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddAppAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddAppAccessRestrictionsResponse(rsp)
}

// RepossetAppAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *RepossetAppAccessRestrictionsResponse
func (c *ClientWithResponses) RepossetAppAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetAppAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetAppAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetAppAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) RepossetAppAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetAppAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetAppAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetAppAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetAppAccessRestrictionsResponse(rsp)
}

// ReposremoveTeamAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposremoveTeamAccessRestrictionsResponse
func (c *ClientWithResponses) ReposremoveTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveTeamAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveTeamAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveTeamAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposremoveTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveTeamAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveTeamAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveTeamAccessRestrictionsResponse(rsp)
}

// ReposgetTeamsWithAccessToProtectedBranchWithResponse request returning *ReposgetTeamsWithAccessToProtectedBranchResponse
func (c *ClientWithResponses) ReposgetTeamsWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetTeamsWithAccessToProtectedBranchResponse, error) {
	rsp, err := c.ReposgetTeamsWithAccessToProtectedBranch(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetTeamsWithAccessToProtectedBranchResponse(rsp)
}

// ReposaddTeamAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposaddTeamAccessRestrictionsResponse
func (c *ClientWithResponses) ReposaddTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddTeamAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddTeamAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddTeamAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposaddTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddTeamAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddTeamAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddTeamAccessRestrictionsResponse(rsp)
}

// RepossetTeamAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *RepossetTeamAccessRestrictionsResponse
func (c *ClientWithResponses) RepossetTeamAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetTeamAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetTeamAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetTeamAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) RepossetTeamAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetTeamAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetTeamAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetTeamAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetTeamAccessRestrictionsResponse(rsp)
}

// ReposremoveUserAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposremoveUserAccessRestrictionsResponse
func (c *ClientWithResponses) ReposremoveUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposremoveUserAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveUserAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveUserAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposremoveUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposremoveUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposremoveUserAccessRestrictionsResponse, error) {
	rsp, err := c.ReposremoveUserAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveUserAccessRestrictionsResponse(rsp)
}

// ReposgetUsersWithAccessToProtectedBranchWithResponse request returning *ReposgetUsersWithAccessToProtectedBranchResponse
func (c *ClientWithResponses) ReposgetUsersWithAccessToProtectedBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, reqEditors ...RequestEditorFn) (*ReposgetUsersWithAccessToProtectedBranchResponse, error) {
	rsp, err := c.ReposgetUsersWithAccessToProtectedBranch(ctx, owner, repo, branch, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetUsersWithAccessToProtectedBranchResponse(rsp)
}

// ReposaddUserAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *ReposaddUserAccessRestrictionsResponse
func (c *ClientWithResponses) ReposaddUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddUserAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddUserAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddUserAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) ReposaddUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposaddUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddUserAccessRestrictionsResponse, error) {
	rsp, err := c.ReposaddUserAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddUserAccessRestrictionsResponse(rsp)
}

// RepossetUserAccessRestrictionsWithBodyWithResponse request with arbitrary body returning *RepossetUserAccessRestrictionsResponse
func (c *ClientWithResponses) RepossetUserAccessRestrictionsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepossetUserAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetUserAccessRestrictionsWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetUserAccessRestrictionsResponse(rsp)
}

func (c *ClientWithResponses) RepossetUserAccessRestrictionsWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body RepossetUserAccessRestrictionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RepossetUserAccessRestrictionsResponse, error) {
	rsp, err := c.RepossetUserAccessRestrictions(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepossetUserAccessRestrictionsResponse(rsp)
}

// ReposrenameBranchWithBodyWithResponse request with arbitrary body returning *ReposrenameBranchResponse
func (c *ClientWithResponses) ReposrenameBranchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposrenameBranchResponse, error) {
	rsp, err := c.ReposrenameBranchWithBody(ctx, owner, repo, branch, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposrenameBranchResponse(rsp)
}

func (c *ClientWithResponses) ReposrenameBranchWithResponse(ctx context.Context, owner Owner, repo Repo, branch Branch, body ReposrenameBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposrenameBranchResponse, error) {
	rsp, err := c.ReposrenameBranch(ctx, owner, repo, branch, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposrenameBranchResponse(rsp)
}

// CheckscreateWithBodyWithResponse request with arbitrary body returning *CheckscreateResponse
func (c *ClientWithResponses) CheckscreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckscreateResponse, error) {
	rsp, err := c.CheckscreateWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckscreateResponse(rsp)
}

func (c *ClientWithResponses) CheckscreateWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckscreateResponse, error) {
	rsp, err := c.Checkscreate(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckscreateResponse(rsp)
}

// ChecksgetWithResponse request returning *ChecksgetResponse
func (c *ClientWithResponses) ChecksgetWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*ChecksgetResponse, error) {
	rsp, err := c.Checksget(ctx, owner, repo, checkRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksgetResponse(rsp)
}

// ChecksupdateWithBodyWithResponse request with arbitrary body returning *ChecksupdateResponse
func (c *ClientWithResponses) ChecksupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChecksupdateResponse, error) {
	rsp, err := c.ChecksupdateWithBody(ctx, owner, repo, checkRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksupdateResponse(rsp)
}

func (c *ClientWithResponses) ChecksupdateWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, body ChecksupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*ChecksupdateResponse, error) {
	rsp, err := c.Checksupdate(ctx, owner, repo, checkRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksupdateResponse(rsp)
}

// CheckslistAnnotationsWithResponse request returning *CheckslistAnnotationsResponse
func (c *ClientWithResponses) CheckslistAnnotationsWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, params *CheckslistAnnotationsParams, reqEditors ...RequestEditorFn) (*CheckslistAnnotationsResponse, error) {
	rsp, err := c.CheckslistAnnotations(ctx, owner, repo, checkRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckslistAnnotationsResponse(rsp)
}

// ChecksrerequestRunWithResponse request returning *ChecksrerequestRunResponse
func (c *ClientWithResponses) ChecksrerequestRunWithResponse(ctx context.Context, owner Owner, repo Repo, checkRunId CheckRunId, reqEditors ...RequestEditorFn) (*ChecksrerequestRunResponse, error) {
	rsp, err := c.ChecksrerequestRun(ctx, owner, repo, checkRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksrerequestRunResponse(rsp)
}

// CheckscreateSuiteWithBodyWithResponse request with arbitrary body returning *CheckscreateSuiteResponse
func (c *ClientWithResponses) CheckscreateSuiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckscreateSuiteResponse, error) {
	rsp, err := c.CheckscreateSuiteWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckscreateSuiteResponse(rsp)
}

func (c *ClientWithResponses) CheckscreateSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckscreateSuiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckscreateSuiteResponse, error) {
	rsp, err := c.CheckscreateSuite(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckscreateSuiteResponse(rsp)
}

// CheckssetSuitesPreferencesWithBodyWithResponse request with arbitrary body returning *CheckssetSuitesPreferencesResponse
func (c *ClientWithResponses) CheckssetSuitesPreferencesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckssetSuitesPreferencesResponse, error) {
	rsp, err := c.CheckssetSuitesPreferencesWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckssetSuitesPreferencesResponse(rsp)
}

func (c *ClientWithResponses) CheckssetSuitesPreferencesWithResponse(ctx context.Context, owner Owner, repo Repo, body CheckssetSuitesPreferencesJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckssetSuitesPreferencesResponse, error) {
	rsp, err := c.CheckssetSuitesPreferences(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckssetSuitesPreferencesResponse(rsp)
}

// ChecksgetSuiteWithResponse request returning *ChecksgetSuiteResponse
func (c *ClientWithResponses) ChecksgetSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*ChecksgetSuiteResponse, error) {
	rsp, err := c.ChecksgetSuite(ctx, owner, repo, checkSuiteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksgetSuiteResponse(rsp)
}

// CheckslistForSuiteWithResponse request returning *CheckslistForSuiteResponse
func (c *ClientWithResponses) CheckslistForSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, params *CheckslistForSuiteParams, reqEditors ...RequestEditorFn) (*CheckslistForSuiteResponse, error) {
	rsp, err := c.CheckslistForSuite(ctx, owner, repo, checkSuiteId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckslistForSuiteResponse(rsp)
}

// ChecksrerequestSuiteWithResponse request returning *ChecksrerequestSuiteResponse
func (c *ClientWithResponses) ChecksrerequestSuiteWithResponse(ctx context.Context, owner Owner, repo Repo, checkSuiteId CheckSuiteId, reqEditors ...RequestEditorFn) (*ChecksrerequestSuiteResponse, error) {
	rsp, err := c.ChecksrerequestSuite(ctx, owner, repo, checkSuiteId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChecksrerequestSuiteResponse(rsp)
}

// CodeScanninglistAlertsForRepoWithResponse request returning *CodeScanninglistAlertsForRepoResponse
func (c *ClientWithResponses) CodeScanninglistAlertsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertsForRepoResponse, error) {
	rsp, err := c.CodeScanninglistAlertsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninglistAlertsForRepoResponse(rsp)
}

// CodeScanninggetAlertWithResponse request returning *CodeScanninggetAlertResponse
func (c *ClientWithResponses) CodeScanninggetAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*CodeScanninggetAlertResponse, error) {
	rsp, err := c.CodeScanninggetAlert(ctx, owner, repo, alertNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninggetAlertResponse(rsp)
}

// CodeScanningupdateAlertWithBodyWithResponse request with arbitrary body returning *CodeScanningupdateAlertResponse
func (c *ClientWithResponses) CodeScanningupdateAlertWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeScanningupdateAlertResponse, error) {
	rsp, err := c.CodeScanningupdateAlertWithBody(ctx, owner, repo, alertNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanningupdateAlertResponse(rsp)
}

func (c *ClientWithResponses) CodeScanningupdateAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body CodeScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeScanningupdateAlertResponse, error) {
	rsp, err := c.CodeScanningupdateAlert(ctx, owner, repo, alertNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanningupdateAlertResponse(rsp)
}

// CodeScanninglistAlertInstancesWithResponse request returning *CodeScanninglistAlertInstancesResponse
func (c *ClientWithResponses) CodeScanninglistAlertInstancesWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *CodeScanninglistAlertInstancesParams, reqEditors ...RequestEditorFn) (*CodeScanninglistAlertInstancesResponse, error) {
	rsp, err := c.CodeScanninglistAlertInstances(ctx, owner, repo, alertNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninglistAlertInstancesResponse(rsp)
}

// CodeScanninglistRecentAnalysesWithResponse request returning *CodeScanninglistRecentAnalysesResponse
func (c *ClientWithResponses) CodeScanninglistRecentAnalysesWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodeScanninglistRecentAnalysesParams, reqEditors ...RequestEditorFn) (*CodeScanninglistRecentAnalysesResponse, error) {
	rsp, err := c.CodeScanninglistRecentAnalyses(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninglistRecentAnalysesResponse(rsp)
}

// CodeScanningdeleteAnalysisWithResponse request returning *CodeScanningdeleteAnalysisResponse
func (c *ClientWithResponses) CodeScanningdeleteAnalysisWithResponse(ctx context.Context, owner Owner, repo Repo, analysisId int, params *CodeScanningdeleteAnalysisParams, reqEditors ...RequestEditorFn) (*CodeScanningdeleteAnalysisResponse, error) {
	rsp, err := c.CodeScanningdeleteAnalysis(ctx, owner, repo, analysisId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanningdeleteAnalysisResponse(rsp)
}

// CodeScanninggetAnalysisWithResponse request returning *CodeScanninggetAnalysisResponse
func (c *ClientWithResponses) CodeScanninggetAnalysisWithResponse(ctx context.Context, owner Owner, repo Repo, analysisId int, reqEditors ...RequestEditorFn) (*CodeScanninggetAnalysisResponse, error) {
	rsp, err := c.CodeScanninggetAnalysis(ctx, owner, repo, analysisId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninggetAnalysisResponse(rsp)
}

// CodeScanninguploadSarifWithBodyWithResponse request with arbitrary body returning *CodeScanninguploadSarifResponse
func (c *ClientWithResponses) CodeScanninguploadSarifWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodeScanninguploadSarifResponse, error) {
	rsp, err := c.CodeScanninguploadSarifWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninguploadSarifResponse(rsp)
}

func (c *ClientWithResponses) CodeScanninguploadSarifWithResponse(ctx context.Context, owner Owner, repo Repo, body CodeScanninguploadSarifJSONRequestBody, reqEditors ...RequestEditorFn) (*CodeScanninguploadSarifResponse, error) {
	rsp, err := c.CodeScanninguploadSarif(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninguploadSarifResponse(rsp)
}

// CodeScanninggetSarifWithResponse request returning *CodeScanninggetSarifResponse
func (c *ClientWithResponses) CodeScanninggetSarifWithResponse(ctx context.Context, owner Owner, repo Repo, sarifId string, reqEditors ...RequestEditorFn) (*CodeScanninggetSarifResponse, error) {
	rsp, err := c.CodeScanninggetSarif(ctx, owner, repo, sarifId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodeScanninggetSarifResponse(rsp)
}

// ReposcodeownersErrorsWithResponse request returning *ReposcodeownersErrorsResponse
func (c *ClientWithResponses) ReposcodeownersErrorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposcodeownersErrorsParams, reqEditors ...RequestEditorFn) (*ReposcodeownersErrorsResponse, error) {
	rsp, err := c.ReposcodeownersErrors(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcodeownersErrorsResponse(rsp)
}

// CodespaceslistInRepositoryForAuthenticatedUserWithResponse request returning *CodespaceslistInRepositoryForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespaceslistInRepositoryForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistInRepositoryForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespaceslistInRepositoryForAuthenticatedUser(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistInRepositoryForAuthenticatedUserResponse(rsp)
}

// CodespacescreateWithRepoForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacescreateWithRepoForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacescreateWithRepoForAuthenticatedUserWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateWithRepoForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateWithRepoForAuthenticatedUserWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateWithRepoForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacescreateWithRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, body CodespacescreateWithRepoForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateWithRepoForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateWithRepoForAuthenticatedUser(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateWithRepoForAuthenticatedUserResponse(rsp)
}

// CodespaceslistDevcontainersInRepositoryForAuthenticatedUserWithResponse request returning *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespaceslistDevcontainersInRepositoryForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistDevcontainersInRepositoryForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespaceslistDevcontainersInRepositoryForAuthenticatedUser(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse(rsp)
}

// CodespacesrepoMachinesForAuthenticatedUserWithResponse request returning *CodespacesrepoMachinesForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesrepoMachinesForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespacesrepoMachinesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespacesrepoMachinesForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesrepoMachinesForAuthenticatedUser(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesrepoMachinesForAuthenticatedUserResponse(rsp)
}

// CodespaceslistRepoSecretsWithResponse request returning *CodespaceslistRepoSecretsResponse
func (c *ClientWithResponses) CodespaceslistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *CodespaceslistRepoSecretsParams, reqEditors ...RequestEditorFn) (*CodespaceslistRepoSecretsResponse, error) {
	rsp, err := c.CodespaceslistRepoSecrets(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistRepoSecretsResponse(rsp)
}

// CodespacesgetRepoPublicKeyWithResponse request returning *CodespacesgetRepoPublicKeyResponse
func (c *ClientWithResponses) CodespacesgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*CodespacesgetRepoPublicKeyResponse, error) {
	rsp, err := c.CodespacesgetRepoPublicKey(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetRepoPublicKeyResponse(rsp)
}

// CodespacesdeleteRepoSecretWithResponse request returning *CodespacesdeleteRepoSecretResponse
func (c *ClientWithResponses) CodespacesdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesdeleteRepoSecretResponse, error) {
	rsp, err := c.CodespacesdeleteRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesdeleteRepoSecretResponse(rsp)
}

// CodespacesgetRepoSecretWithResponse request returning *CodespacesgetRepoSecretResponse
func (c *ClientWithResponses) CodespacesgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesgetRepoSecretResponse, error) {
	rsp, err := c.CodespacesgetRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetRepoSecretResponse(rsp)
}

// CodespacescreateOrUpdateRepoSecretWithBodyWithResponse request with arbitrary body returning *CodespacescreateOrUpdateRepoSecretResponse
func (c *ClientWithResponses) CodespacescreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.CodespacescreateOrUpdateRepoSecretWithBody(ctx, owner, repo, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateOrUpdateRepoSecretResponse(rsp)
}

func (c *ClientWithResponses) CodespacescreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body CodespacescreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.CodespacescreateOrUpdateRepoSecret(ctx, owner, repo, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateOrUpdateRepoSecretResponse(rsp)
}

// ReposlistCollaboratorsWithResponse request returning *ReposlistCollaboratorsResponse
func (c *ClientWithResponses) ReposlistCollaboratorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCollaboratorsParams, reqEditors ...RequestEditorFn) (*ReposlistCollaboratorsResponse, error) {
	rsp, err := c.ReposlistCollaborators(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistCollaboratorsResponse(rsp)
}

// ReposremoveCollaboratorWithResponse request returning *ReposremoveCollaboratorResponse
func (c *ClientWithResponses) ReposremoveCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposremoveCollaboratorResponse, error) {
	rsp, err := c.ReposremoveCollaborator(ctx, owner, repo, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposremoveCollaboratorResponse(rsp)
}

// ReposcheckCollaboratorWithResponse request returning *ReposcheckCollaboratorResponse
func (c *ClientWithResponses) ReposcheckCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposcheckCollaboratorResponse, error) {
	rsp, err := c.ReposcheckCollaborator(ctx, owner, repo, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcheckCollaboratorResponse(rsp)
}

// ReposaddCollaboratorWithBodyWithResponse request with arbitrary body returning *ReposaddCollaboratorResponse
func (c *ClientWithResponses) ReposaddCollaboratorWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposaddCollaboratorResponse, error) {
	rsp, err := c.ReposaddCollaboratorWithBody(ctx, owner, repo, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddCollaboratorResponse(rsp)
}

func (c *ClientWithResponses) ReposaddCollaboratorWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, body ReposaddCollaboratorJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposaddCollaboratorResponse, error) {
	rsp, err := c.ReposaddCollaborator(ctx, owner, repo, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposaddCollaboratorResponse(rsp)
}

// ReposgetCollaboratorPermissionLevelWithResponse request returning *ReposgetCollaboratorPermissionLevelResponse
func (c *ClientWithResponses) ReposgetCollaboratorPermissionLevelWithResponse(ctx context.Context, owner Owner, repo Repo, username Username, reqEditors ...RequestEditorFn) (*ReposgetCollaboratorPermissionLevelResponse, error) {
	rsp, err := c.ReposgetCollaboratorPermissionLevel(ctx, owner, repo, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCollaboratorPermissionLevelResponse(rsp)
}

// ReposlistCommitCommentsForRepoWithResponse request returning *ReposlistCommitCommentsForRepoResponse
func (c *ClientWithResponses) ReposlistCommitCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitCommentsForRepoParams, reqEditors ...RequestEditorFn) (*ReposlistCommitCommentsForRepoResponse, error) {
	rsp, err := c.ReposlistCommitCommentsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistCommitCommentsForRepoResponse(rsp)
}

// ReposdeleteCommitCommentWithResponse request returning *ReposdeleteCommitCommentResponse
func (c *ClientWithResponses) ReposdeleteCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*ReposdeleteCommitCommentResponse, error) {
	rsp, err := c.ReposdeleteCommitComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteCommitCommentResponse(rsp)
}

// ReposgetCommitCommentWithResponse request returning *ReposgetCommitCommentResponse
func (c *ClientWithResponses) ReposgetCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*ReposgetCommitCommentResponse, error) {
	rsp, err := c.ReposgetCommitComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommitCommentResponse(rsp)
}

// ReposupdateCommitCommentWithBodyWithResponse request with arbitrary body returning *ReposupdateCommitCommentResponse
func (c *ClientWithResponses) ReposupdateCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateCommitCommentResponse, error) {
	rsp, err := c.ReposupdateCommitCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateCommitCommentResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReposupdateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateCommitCommentResponse, error) {
	rsp, err := c.ReposupdateCommitComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateCommitCommentResponse(rsp)
}

// ReactionslistForCommitCommentWithResponse request returning *ReactionslistForCommitCommentResponse
func (c *ClientWithResponses) ReactionslistForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForCommitCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForCommitCommentResponse, error) {
	rsp, err := c.ReactionslistForCommitComment(ctx, owner, repo, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForCommitCommentResponse(rsp)
}

// ReactionscreateForCommitCommentWithBodyWithResponse request with arbitrary body returning *ReactionscreateForCommitCommentResponse
func (c *ClientWithResponses) ReactionscreateForCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForCommitCommentResponse, error) {
	rsp, err := c.ReactionscreateForCommitCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForCommitCommentResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForCommitCommentResponse, error) {
	rsp, err := c.ReactionscreateForCommitComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForCommitCommentResponse(rsp)
}

// ReactionsdeleteForCommitCommentWithResponse request returning *ReactionsdeleteForCommitCommentResponse
func (c *ClientWithResponses) ReactionsdeleteForCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForCommitCommentResponse, error) {
	rsp, err := c.ReactionsdeleteForCommitComment(ctx, owner, repo, commentId, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForCommitCommentResponse(rsp)
}

// ReposlistCommitsWithResponse request returning *ReposlistCommitsResponse
func (c *ClientWithResponses) ReposlistCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistCommitsParams, reqEditors ...RequestEditorFn) (*ReposlistCommitsResponse, error) {
	rsp, err := c.ReposlistCommits(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistCommitsResponse(rsp)
}

// ReposlistBranchesForHeadCommitWithResponse request returning *ReposlistBranchesForHeadCommitResponse
func (c *ClientWithResponses) ReposlistBranchesForHeadCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*ReposlistBranchesForHeadCommitResponse, error) {
	rsp, err := c.ReposlistBranchesForHeadCommit(ctx, owner, repo, commitSha, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistBranchesForHeadCommitResponse(rsp)
}

// ReposlistCommentsForCommitWithResponse request returning *ReposlistCommentsForCommitResponse
func (c *ClientWithResponses) ReposlistCommentsForCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistCommentsForCommitParams, reqEditors ...RequestEditorFn) (*ReposlistCommentsForCommitResponse, error) {
	rsp, err := c.ReposlistCommentsForCommit(ctx, owner, repo, commitSha, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistCommentsForCommitResponse(rsp)
}

// ReposcreateCommitCommentWithBodyWithResponse request with arbitrary body returning *ReposcreateCommitCommentResponse
func (c *ClientWithResponses) ReposcreateCommitCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateCommitCommentResponse, error) {
	rsp, err := c.ReposcreateCommitCommentWithBody(ctx, owner, repo, commitSha, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateCommitCommentResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateCommitCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, body ReposcreateCommitCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateCommitCommentResponse, error) {
	rsp, err := c.ReposcreateCommitComment(ctx, owner, repo, commitSha, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateCommitCommentResponse(rsp)
}

// ReposlistPullRequestsAssociatedWithCommitWithResponse request returning *ReposlistPullRequestsAssociatedWithCommitResponse
func (c *ClientWithResponses) ReposlistPullRequestsAssociatedWithCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, params *ReposlistPullRequestsAssociatedWithCommitParams, reqEditors ...RequestEditorFn) (*ReposlistPullRequestsAssociatedWithCommitResponse, error) {
	rsp, err := c.ReposlistPullRequestsAssociatedWithCommit(ctx, owner, repo, commitSha, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistPullRequestsAssociatedWithCommitResponse(rsp)
}

// ReposgetCommitWithResponse request returning *ReposgetCommitResponse
func (c *ClientWithResponses) ReposgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCommitParams, reqEditors ...RequestEditorFn) (*ReposgetCommitResponse, error) {
	rsp, err := c.ReposgetCommit(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommitResponse(rsp)
}

// CheckslistForRefWithResponse request returning *CheckslistForRefResponse
func (c *ClientWithResponses) CheckslistForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistForRefParams, reqEditors ...RequestEditorFn) (*CheckslistForRefResponse, error) {
	rsp, err := c.CheckslistForRef(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckslistForRefResponse(rsp)
}

// CheckslistSuitesForRefWithResponse request returning *CheckslistSuitesForRefResponse
func (c *ClientWithResponses) CheckslistSuitesForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *CheckslistSuitesForRefParams, reqEditors ...RequestEditorFn) (*CheckslistSuitesForRefResponse, error) {
	rsp, err := c.CheckslistSuitesForRef(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckslistSuitesForRefResponse(rsp)
}

// ReposgetCombinedStatusForRefWithResponse request returning *ReposgetCombinedStatusForRefResponse
func (c *ClientWithResponses) ReposgetCombinedStatusForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposgetCombinedStatusForRefParams, reqEditors ...RequestEditorFn) (*ReposgetCombinedStatusForRefResponse, error) {
	rsp, err := c.ReposgetCombinedStatusForRef(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCombinedStatusForRefResponse(rsp)
}

// ReposlistCommitStatusesForRefWithResponse request returning *ReposlistCommitStatusesForRefResponse
func (c *ClientWithResponses) ReposlistCommitStatusesForRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *ReposlistCommitStatusesForRefParams, reqEditors ...RequestEditorFn) (*ReposlistCommitStatusesForRefResponse, error) {
	rsp, err := c.ReposlistCommitStatusesForRef(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistCommitStatusesForRefResponse(rsp)
}

// ReposgetCommunityProfileMetricsWithResponse request returning *ReposgetCommunityProfileMetricsResponse
func (c *ClientWithResponses) ReposgetCommunityProfileMetricsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCommunityProfileMetricsResponse, error) {
	rsp, err := c.ReposgetCommunityProfileMetrics(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommunityProfileMetricsResponse(rsp)
}

// ReposcompareCommitsWithResponse request returning *ReposcompareCommitsResponse
func (c *ClientWithResponses) ReposcompareCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, basehead string, params *ReposcompareCommitsParams, reqEditors ...RequestEditorFn) (*ReposcompareCommitsResponse, error) {
	rsp, err := c.ReposcompareCommits(ctx, owner, repo, basehead, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcompareCommitsResponse(rsp)
}

// ReposdeleteFileWithBodyWithResponse request with arbitrary body returning *ReposdeleteFileResponse
func (c *ClientWithResponses) ReposdeleteFileWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposdeleteFileResponse, error) {
	rsp, err := c.ReposdeleteFileWithBody(ctx, owner, repo, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteFileResponse(rsp)
}

func (c *ClientWithResponses) ReposdeleteFileWithResponse(ctx context.Context, owner Owner, repo Repo, path string, body ReposdeleteFileJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposdeleteFileResponse, error) {
	rsp, err := c.ReposdeleteFile(ctx, owner, repo, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteFileResponse(rsp)
}

// ReposgetContentWithResponse request returning *ReposgetContentResponse
func (c *ClientWithResponses) ReposgetContentWithResponse(ctx context.Context, owner Owner, repo Repo, path string, params *ReposgetContentParams, reqEditors ...RequestEditorFn) (*ReposgetContentResponse, error) {
	rsp, err := c.ReposgetContent(ctx, owner, repo, path, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetContentResponse(rsp)
}

// ReposcreateOrUpdateFileContentsWithBodyWithResponse request with arbitrary body returning *ReposcreateOrUpdateFileContentsResponse
func (c *ClientWithResponses) ReposcreateOrUpdateFileContentsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, path string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error) {
	rsp, err := c.ReposcreateOrUpdateFileContentsWithBody(ctx, owner, repo, path, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateFileContentsResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateOrUpdateFileContentsWithResponse(ctx context.Context, owner Owner, repo Repo, path string, body ReposcreateOrUpdateFileContentsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateFileContentsResponse, error) {
	rsp, err := c.ReposcreateOrUpdateFileContents(ctx, owner, repo, path, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateFileContentsResponse(rsp)
}

// ReposlistContributorsWithResponse request returning *ReposlistContributorsResponse
func (c *ClientWithResponses) ReposlistContributorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistContributorsParams, reqEditors ...RequestEditorFn) (*ReposlistContributorsResponse, error) {
	rsp, err := c.ReposlistContributors(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistContributorsResponse(rsp)
}

// DependabotlistRepoSecretsWithResponse request returning *DependabotlistRepoSecretsResponse
func (c *ClientWithResponses) DependabotlistRepoSecretsWithResponse(ctx context.Context, owner Owner, repo Repo, params *DependabotlistRepoSecretsParams, reqEditors ...RequestEditorFn) (*DependabotlistRepoSecretsResponse, error) {
	rsp, err := c.DependabotlistRepoSecrets(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotlistRepoSecretsResponse(rsp)
}

// DependabotgetRepoPublicKeyWithResponse request returning *DependabotgetRepoPublicKeyResponse
func (c *ClientWithResponses) DependabotgetRepoPublicKeyWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*DependabotgetRepoPublicKeyResponse, error) {
	rsp, err := c.DependabotgetRepoPublicKey(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotgetRepoPublicKeyResponse(rsp)
}

// DependabotdeleteRepoSecretWithResponse request returning *DependabotdeleteRepoSecretResponse
func (c *ClientWithResponses) DependabotdeleteRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotdeleteRepoSecretResponse, error) {
	rsp, err := c.DependabotdeleteRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotdeleteRepoSecretResponse(rsp)
}

// DependabotgetRepoSecretWithResponse request returning *DependabotgetRepoSecretResponse
func (c *ClientWithResponses) DependabotgetRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, reqEditors ...RequestEditorFn) (*DependabotgetRepoSecretResponse, error) {
	rsp, err := c.DependabotgetRepoSecret(ctx, owner, repo, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotgetRepoSecretResponse(rsp)
}

// DependabotcreateOrUpdateRepoSecretWithBodyWithResponse request with arbitrary body returning *DependabotcreateOrUpdateRepoSecretResponse
func (c *ClientWithResponses) DependabotcreateOrUpdateRepoSecretWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.DependabotcreateOrUpdateRepoSecretWithBody(ctx, owner, repo, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotcreateOrUpdateRepoSecretResponse(rsp)
}

func (c *ClientWithResponses) DependabotcreateOrUpdateRepoSecretWithResponse(ctx context.Context, owner Owner, repo Repo, secretName SecretName, body DependabotcreateOrUpdateRepoSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*DependabotcreateOrUpdateRepoSecretResponse, error) {
	rsp, err := c.DependabotcreateOrUpdateRepoSecret(ctx, owner, repo, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependabotcreateOrUpdateRepoSecretResponse(rsp)
}

// DependencyGraphdiffRangeWithResponse request returning *DependencyGraphdiffRangeResponse
func (c *ClientWithResponses) DependencyGraphdiffRangeWithResponse(ctx context.Context, owner Owner, repo Repo, basehead string, params *DependencyGraphdiffRangeParams, reqEditors ...RequestEditorFn) (*DependencyGraphdiffRangeResponse, error) {
	rsp, err := c.DependencyGraphdiffRange(ctx, owner, repo, basehead, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDependencyGraphdiffRangeResponse(rsp)
}

// ReposlistDeploymentsWithResponse request returning *ReposlistDeploymentsResponse
func (c *ClientWithResponses) ReposlistDeploymentsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeploymentsParams, reqEditors ...RequestEditorFn) (*ReposlistDeploymentsResponse, error) {
	rsp, err := c.ReposlistDeployments(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistDeploymentsResponse(rsp)
}

// ReposcreateDeploymentWithBodyWithResponse request with arbitrary body returning *ReposcreateDeploymentResponse
func (c *ClientWithResponses) ReposcreateDeploymentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentResponse, error) {
	rsp, err := c.ReposcreateDeploymentWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeploymentResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeploymentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentResponse, error) {
	rsp, err := c.ReposcreateDeployment(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeploymentResponse(rsp)
}

// ReposdeleteDeploymentWithResponse request returning *ReposdeleteDeploymentResponse
func (c *ClientWithResponses) ReposdeleteDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*ReposdeleteDeploymentResponse, error) {
	rsp, err := c.ReposdeleteDeployment(ctx, owner, repo, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteDeploymentResponse(rsp)
}

// ReposgetDeploymentWithResponse request returning *ReposgetDeploymentResponse
func (c *ClientWithResponses) ReposgetDeploymentWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, reqEditors ...RequestEditorFn) (*ReposgetDeploymentResponse, error) {
	rsp, err := c.ReposgetDeployment(ctx, owner, repo, deploymentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetDeploymentResponse(rsp)
}

// ReposlistDeploymentStatusesWithResponse request returning *ReposlistDeploymentStatusesResponse
func (c *ClientWithResponses) ReposlistDeploymentStatusesWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, params *ReposlistDeploymentStatusesParams, reqEditors ...RequestEditorFn) (*ReposlistDeploymentStatusesResponse, error) {
	rsp, err := c.ReposlistDeploymentStatuses(ctx, owner, repo, deploymentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistDeploymentStatusesResponse(rsp)
}

// ReposcreateDeploymentStatusWithBodyWithResponse request with arbitrary body returning *ReposcreateDeploymentStatusResponse
func (c *ClientWithResponses) ReposcreateDeploymentStatusWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentStatusResponse, error) {
	rsp, err := c.ReposcreateDeploymentStatusWithBody(ctx, owner, repo, deploymentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeploymentStatusResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateDeploymentStatusWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, body ReposcreateDeploymentStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeploymentStatusResponse, error) {
	rsp, err := c.ReposcreateDeploymentStatus(ctx, owner, repo, deploymentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeploymentStatusResponse(rsp)
}

// ReposgetDeploymentStatusWithResponse request returning *ReposgetDeploymentStatusResponse
func (c *ClientWithResponses) ReposgetDeploymentStatusWithResponse(ctx context.Context, owner Owner, repo Repo, deploymentId DeploymentId, statusId int, reqEditors ...RequestEditorFn) (*ReposgetDeploymentStatusResponse, error) {
	rsp, err := c.ReposgetDeploymentStatus(ctx, owner, repo, deploymentId, statusId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetDeploymentStatusResponse(rsp)
}

// ReposcreateDispatchEventWithBodyWithResponse request with arbitrary body returning *ReposcreateDispatchEventResponse
func (c *ClientWithResponses) ReposcreateDispatchEventWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDispatchEventResponse, error) {
	rsp, err := c.ReposcreateDispatchEventWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDispatchEventResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateDispatchEventWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDispatchEventJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDispatchEventResponse, error) {
	rsp, err := c.ReposcreateDispatchEvent(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDispatchEventResponse(rsp)
}

// ReposgetAllEnvironmentsWithResponse request returning *ReposgetAllEnvironmentsResponse
func (c *ClientWithResponses) ReposgetAllEnvironmentsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllEnvironmentsParams, reqEditors ...RequestEditorFn) (*ReposgetAllEnvironmentsResponse, error) {
	rsp, err := c.ReposgetAllEnvironments(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAllEnvironmentsResponse(rsp)
}

// ReposdeleteAnEnvironmentWithResponse request returning *ReposdeleteAnEnvironmentResponse
func (c *ClientWithResponses) ReposdeleteAnEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ReposdeleteAnEnvironmentResponse, error) {
	rsp, err := c.ReposdeleteAnEnvironment(ctx, owner, repo, environmentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteAnEnvironmentResponse(rsp)
}

// ReposgetEnvironmentWithResponse request returning *ReposgetEnvironmentResponse
func (c *ClientWithResponses) ReposgetEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ReposgetEnvironmentResponse, error) {
	rsp, err := c.ReposgetEnvironment(ctx, owner, repo, environmentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetEnvironmentResponse(rsp)
}

// ReposcreateOrUpdateEnvironmentWithBodyWithResponse request with arbitrary body returning *ReposcreateOrUpdateEnvironmentResponse
func (c *ClientWithResponses) ReposcreateOrUpdateEnvironmentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateEnvironmentResponse, error) {
	rsp, err := c.ReposcreateOrUpdateEnvironmentWithBody(ctx, owner, repo, environmentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateOrUpdateEnvironmentWithResponse(ctx context.Context, owner Owner, repo Repo, environmentName EnvironmentName, body ReposcreateOrUpdateEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateOrUpdateEnvironmentResponse, error) {
	rsp, err := c.ReposcreateOrUpdateEnvironment(ctx, owner, repo, environmentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateOrUpdateEnvironmentResponse(rsp)
}

// ActivitylistRepoEventsWithResponse request returning *ActivitylistRepoEventsResponse
func (c *ClientWithResponses) ActivitylistRepoEventsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoEventsParams, reqEditors ...RequestEditorFn) (*ActivitylistRepoEventsResponse, error) {
	rsp, err := c.ActivitylistRepoEvents(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistRepoEventsResponse(rsp)
}

// ReposlistForksWithResponse request returning *ReposlistForksResponse
func (c *ClientWithResponses) ReposlistForksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistForksParams, reqEditors ...RequestEditorFn) (*ReposlistForksResponse, error) {
	rsp, err := c.ReposlistForks(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistForksResponse(rsp)
}

// ReposcreateForkWithBodyWithResponse request with arbitrary body returning *ReposcreateForkResponse
func (c *ClientWithResponses) ReposcreateForkWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateForkResponse, error) {
	rsp, err := c.ReposcreateForkWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateForkResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateForkWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateForkJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateForkResponse, error) {
	rsp, err := c.ReposcreateFork(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateForkResponse(rsp)
}

// GitcreateBlobWithBodyWithResponse request with arbitrary body returning *GitcreateBlobResponse
func (c *ClientWithResponses) GitcreateBlobWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateBlobResponse, error) {
	rsp, err := c.GitcreateBlobWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateBlobResponse(rsp)
}

func (c *ClientWithResponses) GitcreateBlobWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateBlobResponse, error) {
	rsp, err := c.GitcreateBlob(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateBlobResponse(rsp)
}

// GitgetBlobWithResponse request returning *GitgetBlobResponse
func (c *ClientWithResponses) GitgetBlobWithResponse(ctx context.Context, owner Owner, repo Repo, fileSha string, reqEditors ...RequestEditorFn) (*GitgetBlobResponse, error) {
	rsp, err := c.GitgetBlob(ctx, owner, repo, fileSha, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitgetBlobResponse(rsp)
}

// GitcreateCommitWithBodyWithResponse request with arbitrary body returning *GitcreateCommitResponse
func (c *ClientWithResponses) GitcreateCommitWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateCommitResponse, error) {
	rsp, err := c.GitcreateCommitWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateCommitResponse(rsp)
}

func (c *ClientWithResponses) GitcreateCommitWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateCommitJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateCommitResponse, error) {
	rsp, err := c.GitcreateCommit(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateCommitResponse(rsp)
}

// GitgetCommitWithResponse request returning *GitgetCommitResponse
func (c *ClientWithResponses) GitgetCommitWithResponse(ctx context.Context, owner Owner, repo Repo, commitSha CommitSha, reqEditors ...RequestEditorFn) (*GitgetCommitResponse, error) {
	rsp, err := c.GitgetCommit(ctx, owner, repo, commitSha, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitgetCommitResponse(rsp)
}

// GitlistMatchingRefsWithResponse request returning *GitlistMatchingRefsResponse
func (c *ClientWithResponses) GitlistMatchingRefsWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, params *GitlistMatchingRefsParams, reqEditors ...RequestEditorFn) (*GitlistMatchingRefsResponse, error) {
	rsp, err := c.GitlistMatchingRefs(ctx, owner, repo, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitlistMatchingRefsResponse(rsp)
}

// GitgetRefWithResponse request returning *GitgetRefResponse
func (c *ClientWithResponses) GitgetRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*GitgetRefResponse, error) {
	rsp, err := c.GitgetRef(ctx, owner, repo, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitgetRefResponse(rsp)
}

// GitcreateRefWithBodyWithResponse request with arbitrary body returning *GitcreateRefResponse
func (c *ClientWithResponses) GitcreateRefWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateRefResponse, error) {
	rsp, err := c.GitcreateRefWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateRefResponse(rsp)
}

func (c *ClientWithResponses) GitcreateRefWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateRefResponse, error) {
	rsp, err := c.GitcreateRef(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateRefResponse(rsp)
}

// GitdeleteRefWithResponse request returning *GitdeleteRefResponse
func (c *ClientWithResponses) GitdeleteRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*GitdeleteRefResponse, error) {
	rsp, err := c.GitdeleteRef(ctx, owner, repo, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitdeleteRefResponse(rsp)
}

// GitupdateRefWithBodyWithResponse request with arbitrary body returning *GitupdateRefResponse
func (c *ClientWithResponses) GitupdateRefWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitupdateRefResponse, error) {
	rsp, err := c.GitupdateRefWithBody(ctx, owner, repo, ref, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitupdateRefResponse(rsp)
}

func (c *ClientWithResponses) GitupdateRefWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, body GitupdateRefJSONRequestBody, reqEditors ...RequestEditorFn) (*GitupdateRefResponse, error) {
	rsp, err := c.GitupdateRef(ctx, owner, repo, ref, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitupdateRefResponse(rsp)
}

// GitcreateTagWithBodyWithResponse request with arbitrary body returning *GitcreateTagResponse
func (c *ClientWithResponses) GitcreateTagWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateTagResponse, error) {
	rsp, err := c.GitcreateTagWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateTagResponse(rsp)
}

func (c *ClientWithResponses) GitcreateTagWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateTagJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateTagResponse, error) {
	rsp, err := c.GitcreateTag(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateTagResponse(rsp)
}

// GitgetTagWithResponse request returning *GitgetTagResponse
func (c *ClientWithResponses) GitgetTagWithResponse(ctx context.Context, owner Owner, repo Repo, tagSha string, reqEditors ...RequestEditorFn) (*GitgetTagResponse, error) {
	rsp, err := c.GitgetTag(ctx, owner, repo, tagSha, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitgetTagResponse(rsp)
}

// GitcreateTreeWithBodyWithResponse request with arbitrary body returning *GitcreateTreeResponse
func (c *ClientWithResponses) GitcreateTreeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GitcreateTreeResponse, error) {
	rsp, err := c.GitcreateTreeWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateTreeResponse(rsp)
}

func (c *ClientWithResponses) GitcreateTreeWithResponse(ctx context.Context, owner Owner, repo Repo, body GitcreateTreeJSONRequestBody, reqEditors ...RequestEditorFn) (*GitcreateTreeResponse, error) {
	rsp, err := c.GitcreateTree(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitcreateTreeResponse(rsp)
}

// GitgetTreeWithResponse request returning *GitgetTreeResponse
func (c *ClientWithResponses) GitgetTreeWithResponse(ctx context.Context, owner Owner, repo Repo, treeSha string, params *GitgetTreeParams, reqEditors ...RequestEditorFn) (*GitgetTreeResponse, error) {
	rsp, err := c.GitgetTree(ctx, owner, repo, treeSha, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGitgetTreeResponse(rsp)
}

// ReposlistWebhooksWithResponse request returning *ReposlistWebhooksResponse
func (c *ClientWithResponses) ReposlistWebhooksWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistWebhooksParams, reqEditors ...RequestEditorFn) (*ReposlistWebhooksResponse, error) {
	rsp, err := c.ReposlistWebhooks(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistWebhooksResponse(rsp)
}

// ReposcreateWebhookWithBodyWithResponse request with arbitrary body returning *ReposcreateWebhookResponse
func (c *ClientWithResponses) ReposcreateWebhookWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateWebhookResponse, error) {
	rsp, err := c.ReposcreateWebhookWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateWebhookResponse, error) {
	rsp, err := c.ReposcreateWebhook(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateWebhookResponse(rsp)
}

// ReposdeleteWebhookWithResponse request returning *ReposdeleteWebhookResponse
func (c *ClientWithResponses) ReposdeleteWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposdeleteWebhookResponse, error) {
	rsp, err := c.ReposdeleteWebhook(ctx, owner, repo, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteWebhookResponse(rsp)
}

// ReposgetWebhookWithResponse request returning *ReposgetWebhookResponse
func (c *ClientWithResponses) ReposgetWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposgetWebhookResponse, error) {
	rsp, err := c.ReposgetWebhook(ctx, owner, repo, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetWebhookResponse(rsp)
}

// ReposupdateWebhookWithBodyWithResponse request with arbitrary body returning *ReposupdateWebhookResponse
func (c *ClientWithResponses) ReposupdateWebhookWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateWebhookResponse, error) {
	rsp, err := c.ReposupdateWebhookWithBody(ctx, owner, repo, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateWebhookResponse, error) {
	rsp, err := c.ReposupdateWebhook(ctx, owner, repo, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateWebhookResponse(rsp)
}

// ReposgetWebhookConfigForRepoWithResponse request returning *ReposgetWebhookConfigForRepoResponse
func (c *ClientWithResponses) ReposgetWebhookConfigForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*ReposgetWebhookConfigForRepoResponse, error) {
	rsp, err := c.ReposgetWebhookConfigForRepo(ctx, owner, repo, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetWebhookConfigForRepoResponse(rsp)
}

// ReposupdateWebhookConfigForRepoWithBodyWithResponse request with arbitrary body returning *ReposupdateWebhookConfigForRepoResponse
func (c *ClientWithResponses) ReposupdateWebhookConfigForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateWebhookConfigForRepoResponse, error) {
	rsp, err := c.ReposupdateWebhookConfigForRepoWithBody(ctx, owner, repo, hookId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateWebhookConfigForRepoResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateWebhookConfigForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, body ReposupdateWebhookConfigForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateWebhookConfigForRepoResponse, error) {
	rsp, err := c.ReposupdateWebhookConfigForRepo(ctx, owner, repo, hookId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateWebhookConfigForRepoResponse(rsp)
}

// ReposlistWebhookDeliveriesWithResponse request returning *ReposlistWebhookDeliveriesResponse
func (c *ClientWithResponses) ReposlistWebhookDeliveriesWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, params *ReposlistWebhookDeliveriesParams, reqEditors ...RequestEditorFn) (*ReposlistWebhookDeliveriesResponse, error) {
	rsp, err := c.ReposlistWebhookDeliveries(ctx, owner, repo, hookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistWebhookDeliveriesResponse(rsp)
}

// ReposgetWebhookDeliveryWithResponse request returning *ReposgetWebhookDeliveryResponse
func (c *ClientWithResponses) ReposgetWebhookDeliveryWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*ReposgetWebhookDeliveryResponse, error) {
	rsp, err := c.ReposgetWebhookDelivery(ctx, owner, repo, hookId, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetWebhookDeliveryResponse(rsp)
}

// ReposredeliverWebhookDeliveryWithResponse request returning *ReposredeliverWebhookDeliveryResponse
func (c *ClientWithResponses) ReposredeliverWebhookDeliveryWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, deliveryId DeliveryId, reqEditors ...RequestEditorFn) (*ReposredeliverWebhookDeliveryResponse, error) {
	rsp, err := c.ReposredeliverWebhookDelivery(ctx, owner, repo, hookId, deliveryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposredeliverWebhookDeliveryResponse(rsp)
}

// RepospingWebhookWithResponse request returning *RepospingWebhookResponse
func (c *ClientWithResponses) RepospingWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*RepospingWebhookResponse, error) {
	rsp, err := c.RepospingWebhook(ctx, owner, repo, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepospingWebhookResponse(rsp)
}

// RepostestPushWebhookWithResponse request returning *RepostestPushWebhookResponse
func (c *ClientWithResponses) RepostestPushWebhookWithResponse(ctx context.Context, owner Owner, repo Repo, hookId HookId, reqEditors ...RequestEditorFn) (*RepostestPushWebhookResponse, error) {
	rsp, err := c.RepostestPushWebhook(ctx, owner, repo, hookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepostestPushWebhookResponse(rsp)
}

// MigrationscancelImportWithResponse request returning *MigrationscancelImportResponse
func (c *ClientWithResponses) MigrationscancelImportWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationscancelImportResponse, error) {
	rsp, err := c.MigrationscancelImport(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationscancelImportResponse(rsp)
}

// MigrationsgetImportStatusWithResponse request returning *MigrationsgetImportStatusResponse
func (c *ClientWithResponses) MigrationsgetImportStatusWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationsgetImportStatusResponse, error) {
	rsp, err := c.MigrationsgetImportStatus(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetImportStatusResponse(rsp)
}

// MigrationsupdateImportWithBodyWithResponse request with arbitrary body returning *MigrationsupdateImportResponse
func (c *ClientWithResponses) MigrationsupdateImportWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsupdateImportResponse, error) {
	rsp, err := c.MigrationsupdateImportWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsupdateImportResponse(rsp)
}

func (c *ClientWithResponses) MigrationsupdateImportWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationsupdateImportJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsupdateImportResponse, error) {
	rsp, err := c.MigrationsupdateImport(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsupdateImportResponse(rsp)
}

// MigrationsstartImportWithBodyWithResponse request with arbitrary body returning *MigrationsstartImportResponse
func (c *ClientWithResponses) MigrationsstartImportWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartImportResponse, error) {
	rsp, err := c.MigrationsstartImportWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartImportResponse(rsp)
}

func (c *ClientWithResponses) MigrationsstartImportWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationsstartImportJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartImportResponse, error) {
	rsp, err := c.MigrationsstartImport(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartImportResponse(rsp)
}

// MigrationsgetCommitAuthorsWithResponse request returning *MigrationsgetCommitAuthorsResponse
func (c *ClientWithResponses) MigrationsgetCommitAuthorsWithResponse(ctx context.Context, owner Owner, repo Repo, params *MigrationsgetCommitAuthorsParams, reqEditors ...RequestEditorFn) (*MigrationsgetCommitAuthorsResponse, error) {
	rsp, err := c.MigrationsgetCommitAuthors(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetCommitAuthorsResponse(rsp)
}

// MigrationsmapCommitAuthorWithBodyWithResponse request with arbitrary body returning *MigrationsmapCommitAuthorResponse
func (c *ClientWithResponses) MigrationsmapCommitAuthorWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, authorId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsmapCommitAuthorResponse, error) {
	rsp, err := c.MigrationsmapCommitAuthorWithBody(ctx, owner, repo, authorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsmapCommitAuthorResponse(rsp)
}

func (c *ClientWithResponses) MigrationsmapCommitAuthorWithResponse(ctx context.Context, owner Owner, repo Repo, authorId int, body MigrationsmapCommitAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsmapCommitAuthorResponse, error) {
	rsp, err := c.MigrationsmapCommitAuthor(ctx, owner, repo, authorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsmapCommitAuthorResponse(rsp)
}

// MigrationsgetLargeFilesWithResponse request returning *MigrationsgetLargeFilesResponse
func (c *ClientWithResponses) MigrationsgetLargeFilesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*MigrationsgetLargeFilesResponse, error) {
	rsp, err := c.MigrationsgetLargeFiles(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetLargeFilesResponse(rsp)
}

// MigrationssetLfsPreferenceWithBodyWithResponse request with arbitrary body returning *MigrationssetLfsPreferenceResponse
func (c *ClientWithResponses) MigrationssetLfsPreferenceWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationssetLfsPreferenceResponse, error) {
	rsp, err := c.MigrationssetLfsPreferenceWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationssetLfsPreferenceResponse(rsp)
}

func (c *ClientWithResponses) MigrationssetLfsPreferenceWithResponse(ctx context.Context, owner Owner, repo Repo, body MigrationssetLfsPreferenceJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationssetLfsPreferenceResponse, error) {
	rsp, err := c.MigrationssetLfsPreference(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationssetLfsPreferenceResponse(rsp)
}

// AppsgetRepoInstallationWithResponse request returning *AppsgetRepoInstallationResponse
func (c *ClientWithResponses) AppsgetRepoInstallationWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*AppsgetRepoInstallationResponse, error) {
	rsp, err := c.AppsgetRepoInstallation(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetRepoInstallationResponse(rsp)
}

// InteractionsremoveRestrictionsForRepoWithResponse request returning *InteractionsremoveRestrictionsForRepoResponse
func (c *ClientWithResponses) InteractionsremoveRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForRepoResponse, error) {
	rsp, err := c.InteractionsremoveRestrictionsForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsremoveRestrictionsForRepoResponse(rsp)
}

// InteractionsgetRestrictionsForRepoWithResponse request returning *InteractionsgetRestrictionsForRepoResponse
func (c *ClientWithResponses) InteractionsgetRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForRepoResponse, error) {
	rsp, err := c.InteractionsgetRestrictionsForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsgetRestrictionsForRepoResponse(rsp)
}

// InteractionssetRestrictionsForRepoWithBodyWithResponse request with arbitrary body returning *InteractionssetRestrictionsForRepoResponse
func (c *ClientWithResponses) InteractionssetRestrictionsForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForRepoResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForRepoWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForRepoResponse(rsp)
}

func (c *ClientWithResponses) InteractionssetRestrictionsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, body InteractionssetRestrictionsForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForRepoResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForRepo(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForRepoResponse(rsp)
}

// ReposlistInvitationsWithResponse request returning *ReposlistInvitationsResponse
func (c *ClientWithResponses) ReposlistInvitationsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistInvitationsParams, reqEditors ...RequestEditorFn) (*ReposlistInvitationsResponse, error) {
	rsp, err := c.ReposlistInvitations(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistInvitationsResponse(rsp)
}

// ReposdeleteInvitationWithResponse request returning *ReposdeleteInvitationResponse
func (c *ClientWithResponses) ReposdeleteInvitationWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposdeleteInvitationResponse, error) {
	rsp, err := c.ReposdeleteInvitation(ctx, owner, repo, invitationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteInvitationResponse(rsp)
}

// ReposupdateInvitationWithBodyWithResponse request with arbitrary body returning *ReposupdateInvitationResponse
func (c *ClientWithResponses) ReposupdateInvitationWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateInvitationResponse, error) {
	rsp, err := c.ReposupdateInvitationWithBody(ctx, owner, repo, invitationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateInvitationResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateInvitationWithResponse(ctx context.Context, owner Owner, repo Repo, invitationId InvitationId, body ReposupdateInvitationJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateInvitationResponse, error) {
	rsp, err := c.ReposupdateInvitation(ctx, owner, repo, invitationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateInvitationResponse(rsp)
}

// IssueslistForRepoWithResponse request returning *IssueslistForRepoResponse
func (c *ClientWithResponses) IssueslistForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistForRepoResponse, error) {
	rsp, err := c.IssueslistForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistForRepoResponse(rsp)
}

// IssuescreateWithBodyWithResponse request with arbitrary body returning *IssuescreateResponse
func (c *ClientWithResponses) IssuescreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateResponse, error) {
	rsp, err := c.IssuescreateWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateResponse(rsp)
}

func (c *ClientWithResponses) IssuescreateWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateResponse, error) {
	rsp, err := c.Issuescreate(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateResponse(rsp)
}

// IssueslistCommentsForRepoWithResponse request returning *IssueslistCommentsForRepoResponse
func (c *ClientWithResponses) IssueslistCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistCommentsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistCommentsForRepoResponse, error) {
	rsp, err := c.IssueslistCommentsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistCommentsForRepoResponse(rsp)
}

// IssuesdeleteCommentWithResponse request returning *IssuesdeleteCommentResponse
func (c *ClientWithResponses) IssuesdeleteCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*IssuesdeleteCommentResponse, error) {
	rsp, err := c.IssuesdeleteComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesdeleteCommentResponse(rsp)
}

// IssuesgetCommentWithResponse request returning *IssuesgetCommentResponse
func (c *ClientWithResponses) IssuesgetCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*IssuesgetCommentResponse, error) {
	rsp, err := c.IssuesgetComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesgetCommentResponse(rsp)
}

// IssuesupdateCommentWithBodyWithResponse request with arbitrary body returning *IssuesupdateCommentResponse
func (c *ClientWithResponses) IssuesupdateCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateCommentResponse, error) {
	rsp, err := c.IssuesupdateCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateCommentResponse(rsp)
}

func (c *ClientWithResponses) IssuesupdateCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body IssuesupdateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateCommentResponse, error) {
	rsp, err := c.IssuesupdateComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateCommentResponse(rsp)
}

// ReactionslistForIssueCommentWithResponse request returning *ReactionslistForIssueCommentResponse
func (c *ClientWithResponses) ReactionslistForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForIssueCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForIssueCommentResponse, error) {
	rsp, err := c.ReactionslistForIssueComment(ctx, owner, repo, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForIssueCommentResponse(rsp)
}

// ReactionscreateForIssueCommentWithBodyWithResponse request with arbitrary body returning *ReactionscreateForIssueCommentResponse
func (c *ClientWithResponses) ReactionscreateForIssueCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueCommentResponse, error) {
	rsp, err := c.ReactionscreateForIssueCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForIssueCommentResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForIssueCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueCommentResponse, error) {
	rsp, err := c.ReactionscreateForIssueComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForIssueCommentResponse(rsp)
}

// ReactionsdeleteForIssueCommentWithResponse request returning *ReactionsdeleteForIssueCommentResponse
func (c *ClientWithResponses) ReactionsdeleteForIssueCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForIssueCommentResponse, error) {
	rsp, err := c.ReactionsdeleteForIssueComment(ctx, owner, repo, commentId, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForIssueCommentResponse(rsp)
}

// IssueslistEventsForRepoWithResponse request returning *IssueslistEventsForRepoResponse
func (c *ClientWithResponses) IssueslistEventsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistEventsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistEventsForRepoResponse, error) {
	rsp, err := c.IssueslistEventsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistEventsForRepoResponse(rsp)
}

// IssuesgetEventWithResponse request returning *IssuesgetEventResponse
func (c *ClientWithResponses) IssuesgetEventWithResponse(ctx context.Context, owner Owner, repo Repo, eventId int, reqEditors ...RequestEditorFn) (*IssuesgetEventResponse, error) {
	rsp, err := c.IssuesgetEvent(ctx, owner, repo, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesgetEventResponse(rsp)
}

// IssuesgetWithResponse request returning *IssuesgetResponse
func (c *ClientWithResponses) IssuesgetWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesgetResponse, error) {
	rsp, err := c.Issuesget(ctx, owner, repo, issueNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesgetResponse(rsp)
}

// IssuesupdateWithBodyWithResponse request with arbitrary body returning *IssuesupdateResponse
func (c *ClientWithResponses) IssuesupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateResponse, error) {
	rsp, err := c.IssuesupdateWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateResponse(rsp)
}

func (c *ClientWithResponses) IssuesupdateWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateResponse, error) {
	rsp, err := c.Issuesupdate(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateResponse(rsp)
}

// IssuesremoveAssigneesWithBodyWithResponse request with arbitrary body returning *IssuesremoveAssigneesResponse
func (c *ClientWithResponses) IssuesremoveAssigneesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesremoveAssigneesResponse, error) {
	rsp, err := c.IssuesremoveAssigneesWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesremoveAssigneesResponse(rsp)
}

func (c *ClientWithResponses) IssuesremoveAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesremoveAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesremoveAssigneesResponse, error) {
	rsp, err := c.IssuesremoveAssignees(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesremoveAssigneesResponse(rsp)
}

// IssuesaddAssigneesWithBodyWithResponse request with arbitrary body returning *IssuesaddAssigneesResponse
func (c *ClientWithResponses) IssuesaddAssigneesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesaddAssigneesResponse, error) {
	rsp, err := c.IssuesaddAssigneesWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesaddAssigneesResponse(rsp)
}

func (c *ClientWithResponses) IssuesaddAssigneesWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddAssigneesJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesaddAssigneesResponse, error) {
	rsp, err := c.IssuesaddAssignees(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesaddAssigneesResponse(rsp)
}

// IssueslistCommentsWithResponse request returning *IssueslistCommentsResponse
func (c *ClientWithResponses) IssueslistCommentsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistCommentsParams, reqEditors ...RequestEditorFn) (*IssueslistCommentsResponse, error) {
	rsp, err := c.IssueslistComments(ctx, owner, repo, issueNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistCommentsResponse(rsp)
}

// IssuescreateCommentWithBodyWithResponse request with arbitrary body returning *IssuescreateCommentResponse
func (c *ClientWithResponses) IssuescreateCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateCommentResponse, error) {
	rsp, err := c.IssuescreateCommentWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateCommentResponse(rsp)
}

func (c *ClientWithResponses) IssuescreateCommentWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuescreateCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateCommentResponse, error) {
	rsp, err := c.IssuescreateComment(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateCommentResponse(rsp)
}

// IssueslistEventsWithResponse request returning *IssueslistEventsResponse
func (c *ClientWithResponses) IssueslistEventsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsParams, reqEditors ...RequestEditorFn) (*IssueslistEventsResponse, error) {
	rsp, err := c.IssueslistEvents(ctx, owner, repo, issueNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistEventsResponse(rsp)
}

// IssuesremoveAllLabelsWithResponse request returning *IssuesremoveAllLabelsResponse
func (c *ClientWithResponses) IssuesremoveAllLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesremoveAllLabelsResponse, error) {
	rsp, err := c.IssuesremoveAllLabels(ctx, owner, repo, issueNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesremoveAllLabelsResponse(rsp)
}

// IssueslistLabelsOnIssueWithResponse request returning *IssueslistLabelsOnIssueResponse
func (c *ClientWithResponses) IssueslistLabelsOnIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistLabelsOnIssueParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsOnIssueResponse, error) {
	rsp, err := c.IssueslistLabelsOnIssue(ctx, owner, repo, issueNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistLabelsOnIssueResponse(rsp)
}

// IssuesaddLabelsWithBodyWithResponse request with arbitrary body returning *IssuesaddLabelsResponse
func (c *ClientWithResponses) IssuesaddLabelsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesaddLabelsResponse, error) {
	rsp, err := c.IssuesaddLabelsWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesaddLabelsResponse(rsp)
}

func (c *ClientWithResponses) IssuesaddLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuesaddLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesaddLabelsResponse, error) {
	rsp, err := c.IssuesaddLabels(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesaddLabelsResponse(rsp)
}

// IssuessetLabelsWithBodyWithResponse request with arbitrary body returning *IssuessetLabelsResponse
func (c *ClientWithResponses) IssuessetLabelsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuessetLabelsResponse, error) {
	rsp, err := c.IssuessetLabelsWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuessetLabelsResponse(rsp)
}

func (c *ClientWithResponses) IssuessetLabelsWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssuessetLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuessetLabelsResponse, error) {
	rsp, err := c.IssuessetLabels(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuessetLabelsResponse(rsp)
}

// IssuesremoveLabelWithResponse request returning *IssuesremoveLabelResponse
func (c *ClientWithResponses) IssuesremoveLabelWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, name string, reqEditors ...RequestEditorFn) (*IssuesremoveLabelResponse, error) {
	rsp, err := c.IssuesremoveLabel(ctx, owner, repo, issueNumber, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesremoveLabelResponse(rsp)
}

// IssuesunlockWithResponse request returning *IssuesunlockResponse
func (c *ClientWithResponses) IssuesunlockWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reqEditors ...RequestEditorFn) (*IssuesunlockResponse, error) {
	rsp, err := c.Issuesunlock(ctx, owner, repo, issueNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesunlockResponse(rsp)
}

// IssueslockWithBodyWithResponse request with arbitrary body returning *IssueslockResponse
func (c *ClientWithResponses) IssueslockWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssueslockResponse, error) {
	rsp, err := c.IssueslockWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslockResponse(rsp)
}

func (c *ClientWithResponses) IssueslockWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body IssueslockJSONRequestBody, reqEditors ...RequestEditorFn) (*IssueslockResponse, error) {
	rsp, err := c.Issueslock(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslockResponse(rsp)
}

// ReactionslistForIssueWithResponse request returning *ReactionslistForIssueResponse
func (c *ClientWithResponses) ReactionslistForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *ReactionslistForIssueParams, reqEditors ...RequestEditorFn) (*ReactionslistForIssueResponse, error) {
	rsp, err := c.ReactionslistForIssue(ctx, owner, repo, issueNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForIssueResponse(rsp)
}

// ReactionscreateForIssueWithBodyWithResponse request with arbitrary body returning *ReactionscreateForIssueResponse
func (c *ClientWithResponses) ReactionscreateForIssueWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueResponse, error) {
	rsp, err := c.ReactionscreateForIssueWithBody(ctx, owner, repo, issueNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForIssueResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, body ReactionscreateForIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForIssueResponse, error) {
	rsp, err := c.ReactionscreateForIssue(ctx, owner, repo, issueNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForIssueResponse(rsp)
}

// ReactionsdeleteForIssueWithResponse request returning *ReactionsdeleteForIssueResponse
func (c *ClientWithResponses) ReactionsdeleteForIssueWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForIssueResponse, error) {
	rsp, err := c.ReactionsdeleteForIssue(ctx, owner, repo, issueNumber, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForIssueResponse(rsp)
}

// IssueslistEventsForTimelineWithResponse request returning *IssueslistEventsForTimelineResponse
func (c *ClientWithResponses) IssueslistEventsForTimelineWithResponse(ctx context.Context, owner Owner, repo Repo, issueNumber IssueNumber, params *IssueslistEventsForTimelineParams, reqEditors ...RequestEditorFn) (*IssueslistEventsForTimelineResponse, error) {
	rsp, err := c.IssueslistEventsForTimeline(ctx, owner, repo, issueNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistEventsForTimelineResponse(rsp)
}

// ReposlistDeployKeysWithResponse request returning *ReposlistDeployKeysResponse
func (c *ClientWithResponses) ReposlistDeployKeysWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistDeployKeysParams, reqEditors ...RequestEditorFn) (*ReposlistDeployKeysResponse, error) {
	rsp, err := c.ReposlistDeployKeys(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistDeployKeysResponse(rsp)
}

// ReposcreateDeployKeyWithBodyWithResponse request with arbitrary body returning *ReposcreateDeployKeyResponse
func (c *ClientWithResponses) ReposcreateDeployKeyWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateDeployKeyResponse, error) {
	rsp, err := c.ReposcreateDeployKeyWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeployKeyResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateDeployKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateDeployKeyResponse, error) {
	rsp, err := c.ReposcreateDeployKey(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateDeployKeyResponse(rsp)
}

// ReposdeleteDeployKeyWithResponse request returning *ReposdeleteDeployKeyResponse
func (c *ClientWithResponses) ReposdeleteDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*ReposdeleteDeployKeyResponse, error) {
	rsp, err := c.ReposdeleteDeployKey(ctx, owner, repo, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteDeployKeyResponse(rsp)
}

// ReposgetDeployKeyWithResponse request returning *ReposgetDeployKeyResponse
func (c *ClientWithResponses) ReposgetDeployKeyWithResponse(ctx context.Context, owner Owner, repo Repo, keyId KeyId, reqEditors ...RequestEditorFn) (*ReposgetDeployKeyResponse, error) {
	rsp, err := c.ReposgetDeployKey(ctx, owner, repo, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetDeployKeyResponse(rsp)
}

// IssueslistLabelsForRepoWithResponse request returning *IssueslistLabelsForRepoResponse
func (c *ClientWithResponses) IssueslistLabelsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistLabelsForRepoParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsForRepoResponse, error) {
	rsp, err := c.IssueslistLabelsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistLabelsForRepoResponse(rsp)
}

// IssuescreateLabelWithBodyWithResponse request with arbitrary body returning *IssuescreateLabelResponse
func (c *ClientWithResponses) IssuescreateLabelWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateLabelResponse, error) {
	rsp, err := c.IssuescreateLabelWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateLabelResponse(rsp)
}

func (c *ClientWithResponses) IssuescreateLabelWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateLabelResponse, error) {
	rsp, err := c.IssuescreateLabel(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateLabelResponse(rsp)
}

// IssuesdeleteLabelWithResponse request returning *IssuesdeleteLabelResponse
func (c *ClientWithResponses) IssuesdeleteLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*IssuesdeleteLabelResponse, error) {
	rsp, err := c.IssuesdeleteLabel(ctx, owner, repo, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesdeleteLabelResponse(rsp)
}

// IssuesgetLabelWithResponse request returning *IssuesgetLabelResponse
func (c *ClientWithResponses) IssuesgetLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, reqEditors ...RequestEditorFn) (*IssuesgetLabelResponse, error) {
	rsp, err := c.IssuesgetLabel(ctx, owner, repo, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesgetLabelResponse(rsp)
}

// IssuesupdateLabelWithBodyWithResponse request with arbitrary body returning *IssuesupdateLabelResponse
func (c *ClientWithResponses) IssuesupdateLabelWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateLabelResponse, error) {
	rsp, err := c.IssuesupdateLabelWithBody(ctx, owner, repo, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateLabelResponse(rsp)
}

func (c *ClientWithResponses) IssuesupdateLabelWithResponse(ctx context.Context, owner Owner, repo Repo, name string, body IssuesupdateLabelJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateLabelResponse, error) {
	rsp, err := c.IssuesupdateLabel(ctx, owner, repo, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateLabelResponse(rsp)
}

// ReposlistLanguagesWithResponse request returning *ReposlistLanguagesResponse
func (c *ClientWithResponses) ReposlistLanguagesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposlistLanguagesResponse, error) {
	rsp, err := c.ReposlistLanguages(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistLanguagesResponse(rsp)
}

// ReposdisableLfsForRepoWithResponse request returning *ReposdisableLfsForRepoResponse
func (c *ClientWithResponses) ReposdisableLfsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableLfsForRepoResponse, error) {
	rsp, err := c.ReposdisableLfsForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdisableLfsForRepoResponse(rsp)
}

// ReposenableLfsForRepoWithResponse request returning *ReposenableLfsForRepoResponse
func (c *ClientWithResponses) ReposenableLfsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableLfsForRepoResponse, error) {
	rsp, err := c.ReposenableLfsForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposenableLfsForRepoResponse(rsp)
}

// LicensesgetForRepoWithResponse request returning *LicensesgetForRepoResponse
func (c *ClientWithResponses) LicensesgetForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*LicensesgetForRepoResponse, error) {
	rsp, err := c.LicensesgetForRepo(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLicensesgetForRepoResponse(rsp)
}

// ReposmergeUpstreamWithBodyWithResponse request with arbitrary body returning *ReposmergeUpstreamResponse
func (c *ClientWithResponses) ReposmergeUpstreamWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposmergeUpstreamResponse, error) {
	rsp, err := c.ReposmergeUpstreamWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposmergeUpstreamResponse(rsp)
}

func (c *ClientWithResponses) ReposmergeUpstreamWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposmergeUpstreamJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposmergeUpstreamResponse, error) {
	rsp, err := c.ReposmergeUpstream(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposmergeUpstreamResponse(rsp)
}

// ReposmergeWithBodyWithResponse request with arbitrary body returning *ReposmergeResponse
func (c *ClientWithResponses) ReposmergeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposmergeResponse, error) {
	rsp, err := c.ReposmergeWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposmergeResponse(rsp)
}

func (c *ClientWithResponses) ReposmergeWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposmergeResponse, error) {
	rsp, err := c.Reposmerge(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposmergeResponse(rsp)
}

// IssueslistMilestonesWithResponse request returning *IssueslistMilestonesResponse
func (c *ClientWithResponses) IssueslistMilestonesWithResponse(ctx context.Context, owner Owner, repo Repo, params *IssueslistMilestonesParams, reqEditors ...RequestEditorFn) (*IssueslistMilestonesResponse, error) {
	rsp, err := c.IssueslistMilestones(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistMilestonesResponse(rsp)
}

// IssuescreateMilestoneWithBodyWithResponse request with arbitrary body returning *IssuescreateMilestoneResponse
func (c *ClientWithResponses) IssuescreateMilestoneWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuescreateMilestoneResponse, error) {
	rsp, err := c.IssuescreateMilestoneWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateMilestoneResponse(rsp)
}

func (c *ClientWithResponses) IssuescreateMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, body IssuescreateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuescreateMilestoneResponse, error) {
	rsp, err := c.IssuescreateMilestone(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuescreateMilestoneResponse(rsp)
}

// IssuesdeleteMilestoneWithResponse request returning *IssuesdeleteMilestoneResponse
func (c *ClientWithResponses) IssuesdeleteMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*IssuesdeleteMilestoneResponse, error) {
	rsp, err := c.IssuesdeleteMilestone(ctx, owner, repo, milestoneNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesdeleteMilestoneResponse(rsp)
}

// IssuesgetMilestoneWithResponse request returning *IssuesgetMilestoneResponse
func (c *ClientWithResponses) IssuesgetMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, reqEditors ...RequestEditorFn) (*IssuesgetMilestoneResponse, error) {
	rsp, err := c.IssuesgetMilestone(ctx, owner, repo, milestoneNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesgetMilestoneResponse(rsp)
}

// IssuesupdateMilestoneWithBodyWithResponse request with arbitrary body returning *IssuesupdateMilestoneResponse
func (c *ClientWithResponses) IssuesupdateMilestoneWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IssuesupdateMilestoneResponse, error) {
	rsp, err := c.IssuesupdateMilestoneWithBody(ctx, owner, repo, milestoneNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateMilestoneResponse(rsp)
}

func (c *ClientWithResponses) IssuesupdateMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, body IssuesupdateMilestoneJSONRequestBody, reqEditors ...RequestEditorFn) (*IssuesupdateMilestoneResponse, error) {
	rsp, err := c.IssuesupdateMilestone(ctx, owner, repo, milestoneNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesupdateMilestoneResponse(rsp)
}

// IssueslistLabelsForMilestoneWithResponse request returning *IssueslistLabelsForMilestoneResponse
func (c *ClientWithResponses) IssueslistLabelsForMilestoneWithResponse(ctx context.Context, owner Owner, repo Repo, milestoneNumber MilestoneNumber, params *IssueslistLabelsForMilestoneParams, reqEditors ...RequestEditorFn) (*IssueslistLabelsForMilestoneResponse, error) {
	rsp, err := c.IssueslistLabelsForMilestone(ctx, owner, repo, milestoneNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistLabelsForMilestoneResponse(rsp)
}

// ActivitylistRepoNotificationsForAuthenticatedUserWithResponse request returning *ActivitylistRepoNotificationsForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistRepoNotificationsForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistRepoNotificationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistRepoNotificationsForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistRepoNotificationsForAuthenticatedUser(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistRepoNotificationsForAuthenticatedUserResponse(rsp)
}

// ActivitymarkRepoNotificationsAsReadWithBodyWithResponse request with arbitrary body returning *ActivitymarkRepoNotificationsAsReadResponse
func (c *ClientWithResponses) ActivitymarkRepoNotificationsAsReadWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitymarkRepoNotificationsAsReadResponse, error) {
	rsp, err := c.ActivitymarkRepoNotificationsAsReadWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitymarkRepoNotificationsAsReadResponse(rsp)
}

func (c *ClientWithResponses) ActivitymarkRepoNotificationsAsReadWithResponse(ctx context.Context, owner Owner, repo Repo, body ActivitymarkRepoNotificationsAsReadJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitymarkRepoNotificationsAsReadResponse, error) {
	rsp, err := c.ActivitymarkRepoNotificationsAsRead(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitymarkRepoNotificationsAsReadResponse(rsp)
}

// ReposdeletePagesSiteWithResponse request returning *ReposdeletePagesSiteResponse
func (c *ClientWithResponses) ReposdeletePagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdeletePagesSiteResponse, error) {
	rsp, err := c.ReposdeletePagesSite(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeletePagesSiteResponse(rsp)
}

// ReposgetPagesWithResponse request returning *ReposgetPagesResponse
func (c *ClientWithResponses) ReposgetPagesWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPagesResponse, error) {
	rsp, err := c.ReposgetPages(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetPagesResponse(rsp)
}

// ReposcreatePagesSiteWithBodyWithResponse request with arbitrary body returning *ReposcreatePagesSiteResponse
func (c *ClientWithResponses) ReposcreatePagesSiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreatePagesSiteResponse, error) {
	rsp, err := c.ReposcreatePagesSiteWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreatePagesSiteResponse(rsp)
}

func (c *ClientWithResponses) ReposcreatePagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreatePagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreatePagesSiteResponse, error) {
	rsp, err := c.ReposcreatePagesSite(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreatePagesSiteResponse(rsp)
}

// ReposupdateInformationAboutPagesSiteWithBodyWithResponse request with arbitrary body returning *ReposupdateInformationAboutPagesSiteResponse
func (c *ClientWithResponses) ReposupdateInformationAboutPagesSiteWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateInformationAboutPagesSiteResponse, error) {
	rsp, err := c.ReposupdateInformationAboutPagesSiteWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateInformationAboutPagesSiteResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateInformationAboutPagesSiteWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposupdateInformationAboutPagesSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateInformationAboutPagesSiteResponse, error) {
	rsp, err := c.ReposupdateInformationAboutPagesSite(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateInformationAboutPagesSiteResponse(rsp)
}

// ReposlistPagesBuildsWithResponse request returning *ReposlistPagesBuildsResponse
func (c *ClientWithResponses) ReposlistPagesBuildsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistPagesBuildsParams, reqEditors ...RequestEditorFn) (*ReposlistPagesBuildsResponse, error) {
	rsp, err := c.ReposlistPagesBuilds(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistPagesBuildsResponse(rsp)
}

// ReposrequestPagesBuildWithResponse request returning *ReposrequestPagesBuildResponse
func (c *ClientWithResponses) ReposrequestPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposrequestPagesBuildResponse, error) {
	rsp, err := c.ReposrequestPagesBuild(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposrequestPagesBuildResponse(rsp)
}

// ReposgetLatestPagesBuildWithResponse request returning *ReposgetLatestPagesBuildResponse
func (c *ClientWithResponses) ReposgetLatestPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetLatestPagesBuildResponse, error) {
	rsp, err := c.ReposgetLatestPagesBuild(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetLatestPagesBuildResponse(rsp)
}

// ReposgetPagesBuildWithResponse request returning *ReposgetPagesBuildResponse
func (c *ClientWithResponses) ReposgetPagesBuildWithResponse(ctx context.Context, owner Owner, repo Repo, buildId int, reqEditors ...RequestEditorFn) (*ReposgetPagesBuildResponse, error) {
	rsp, err := c.ReposgetPagesBuild(ctx, owner, repo, buildId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetPagesBuildResponse(rsp)
}

// ReposgetPagesHealthCheckWithResponse request returning *ReposgetPagesHealthCheckResponse
func (c *ClientWithResponses) ReposgetPagesHealthCheckWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPagesHealthCheckResponse, error) {
	rsp, err := c.ReposgetPagesHealthCheck(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetPagesHealthCheckResponse(rsp)
}

// ProjectslistForRepoWithResponse request returning *ProjectslistForRepoResponse
func (c *ClientWithResponses) ProjectslistForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ProjectslistForRepoParams, reqEditors ...RequestEditorFn) (*ProjectslistForRepoResponse, error) {
	rsp, err := c.ProjectslistForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistForRepoResponse(rsp)
}

// ProjectscreateForRepoWithBodyWithResponse request with arbitrary body returning *ProjectscreateForRepoResponse
func (c *ClientWithResponses) ProjectscreateForRepoWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForRepoResponse, error) {
	rsp, err := c.ProjectscreateForRepoWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForRepoResponse(rsp)
}

func (c *ClientWithResponses) ProjectscreateForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, body ProjectscreateForRepoJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForRepoResponse, error) {
	rsp, err := c.ProjectscreateForRepo(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForRepoResponse(rsp)
}

// PullslistWithResponse request returning *PullslistResponse
func (c *ClientWithResponses) PullslistWithResponse(ctx context.Context, owner Owner, repo Repo, params *PullslistParams, reqEditors ...RequestEditorFn) (*PullslistResponse, error) {
	rsp, err := c.Pullslist(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistResponse(rsp)
}

// PullscreateWithBodyWithResponse request with arbitrary body returning *PullscreateResponse
func (c *ClientWithResponses) PullscreateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateResponse, error) {
	rsp, err := c.PullscreateWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateResponse(rsp)
}

func (c *ClientWithResponses) PullscreateWithResponse(ctx context.Context, owner Owner, repo Repo, body PullscreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateResponse, error) {
	rsp, err := c.Pullscreate(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateResponse(rsp)
}

// PullslistReviewCommentsForRepoWithResponse request returning *PullslistReviewCommentsForRepoResponse
func (c *ClientWithResponses) PullslistReviewCommentsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *PullslistReviewCommentsForRepoParams, reqEditors ...RequestEditorFn) (*PullslistReviewCommentsForRepoResponse, error) {
	rsp, err := c.PullslistReviewCommentsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistReviewCommentsForRepoResponse(rsp)
}

// PullsdeleteReviewCommentWithResponse request returning *PullsdeleteReviewCommentResponse
func (c *ClientWithResponses) PullsdeleteReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*PullsdeleteReviewCommentResponse, error) {
	rsp, err := c.PullsdeleteReviewComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsdeleteReviewCommentResponse(rsp)
}

// PullsgetReviewCommentWithResponse request returning *PullsgetReviewCommentResponse
func (c *ClientWithResponses) PullsgetReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reqEditors ...RequestEditorFn) (*PullsgetReviewCommentResponse, error) {
	rsp, err := c.PullsgetReviewComment(ctx, owner, repo, commentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsgetReviewCommentResponse(rsp)
}

// PullsupdateReviewCommentWithBodyWithResponse request with arbitrary body returning *PullsupdateReviewCommentResponse
func (c *ClientWithResponses) PullsupdateReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateReviewCommentResponse, error) {
	rsp, err := c.PullsupdateReviewCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateReviewCommentResponse(rsp)
}

func (c *ClientWithResponses) PullsupdateReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body PullsupdateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateReviewCommentResponse, error) {
	rsp, err := c.PullsupdateReviewComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateReviewCommentResponse(rsp)
}

// ReactionslistForPullRequestReviewCommentWithResponse request returning *ReactionslistForPullRequestReviewCommentResponse
func (c *ClientWithResponses) ReactionslistForPullRequestReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, params *ReactionslistForPullRequestReviewCommentParams, reqEditors ...RequestEditorFn) (*ReactionslistForPullRequestReviewCommentResponse, error) {
	rsp, err := c.ReactionslistForPullRequestReviewComment(ctx, owner, repo, commentId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForPullRequestReviewCommentResponse(rsp)
}

// ReactionscreateForPullRequestReviewCommentWithBodyWithResponse request with arbitrary body returning *ReactionscreateForPullRequestReviewCommentResponse
func (c *ClientWithResponses) ReactionscreateForPullRequestReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForPullRequestReviewCommentResponse, error) {
	rsp, err := c.ReactionscreateForPullRequestReviewCommentWithBody(ctx, owner, repo, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForPullRequestReviewCommentResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForPullRequestReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, body ReactionscreateForPullRequestReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForPullRequestReviewCommentResponse, error) {
	rsp, err := c.ReactionscreateForPullRequestReviewComment(ctx, owner, repo, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForPullRequestReviewCommentResponse(rsp)
}

// ReactionsdeleteForPullRequestCommentWithResponse request returning *ReactionsdeleteForPullRequestCommentResponse
func (c *ClientWithResponses) ReactionsdeleteForPullRequestCommentWithResponse(ctx context.Context, owner Owner, repo Repo, commentId CommentId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForPullRequestCommentResponse, error) {
	rsp, err := c.ReactionsdeleteForPullRequestComment(ctx, owner, repo, commentId, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForPullRequestCommentResponse(rsp)
}

// PullsgetWithResponse request returning *PullsgetResponse
func (c *ClientWithResponses) PullsgetWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*PullsgetResponse, error) {
	rsp, err := c.Pullsget(ctx, owner, repo, pullNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsgetResponse(rsp)
}

// PullsupdateWithBodyWithResponse request with arbitrary body returning *PullsupdateResponse
func (c *ClientWithResponses) PullsupdateWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateResponse, error) {
	rsp, err := c.PullsupdateWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateResponse(rsp)
}

func (c *ClientWithResponses) PullsupdateWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateResponse, error) {
	rsp, err := c.Pullsupdate(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateResponse(rsp)
}

// CodespacescreateWithPrForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacescreateWithPrForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacescreateWithPrForAuthenticatedUserWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateWithPrForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateWithPrForAuthenticatedUserWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateWithPrForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacescreateWithPrForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body CodespacescreateWithPrForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateWithPrForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateWithPrForAuthenticatedUser(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateWithPrForAuthenticatedUserResponse(rsp)
}

// PullslistReviewCommentsWithResponse request returning *PullslistReviewCommentsResponse
func (c *ClientWithResponses) PullslistReviewCommentsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewCommentsParams, reqEditors ...RequestEditorFn) (*PullslistReviewCommentsResponse, error) {
	rsp, err := c.PullslistReviewComments(ctx, owner, repo, pullNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistReviewCommentsResponse(rsp)
}

// PullscreateReviewCommentWithBodyWithResponse request with arbitrary body returning *PullscreateReviewCommentResponse
func (c *ClientWithResponses) PullscreateReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReviewCommentResponse, error) {
	rsp, err := c.PullscreateReviewCommentWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReviewCommentResponse(rsp)
}

func (c *ClientWithResponses) PullscreateReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReviewCommentResponse, error) {
	rsp, err := c.PullscreateReviewComment(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReviewCommentResponse(rsp)
}

// PullscreateReplyForReviewCommentWithBodyWithResponse request with arbitrary body returning *PullscreateReplyForReviewCommentResponse
func (c *ClientWithResponses) PullscreateReplyForReviewCommentWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReplyForReviewCommentResponse, error) {
	rsp, err := c.PullscreateReplyForReviewCommentWithBody(ctx, owner, repo, pullNumber, commentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReplyForReviewCommentResponse(rsp)
}

func (c *ClientWithResponses) PullscreateReplyForReviewCommentWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, commentId CommentId, body PullscreateReplyForReviewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReplyForReviewCommentResponse, error) {
	rsp, err := c.PullscreateReplyForReviewComment(ctx, owner, repo, pullNumber, commentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReplyForReviewCommentResponse(rsp)
}

// PullslistCommitsWithResponse request returning *PullslistCommitsResponse
func (c *ClientWithResponses) PullslistCommitsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistCommitsParams, reqEditors ...RequestEditorFn) (*PullslistCommitsResponse, error) {
	rsp, err := c.PullslistCommits(ctx, owner, repo, pullNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistCommitsResponse(rsp)
}

// PullslistFilesWithResponse request returning *PullslistFilesResponse
func (c *ClientWithResponses) PullslistFilesWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistFilesParams, reqEditors ...RequestEditorFn) (*PullslistFilesResponse, error) {
	rsp, err := c.PullslistFiles(ctx, owner, repo, pullNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistFilesResponse(rsp)
}

// PullscheckIfMergedWithResponse request returning *PullscheckIfMergedResponse
func (c *ClientWithResponses) PullscheckIfMergedWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reqEditors ...RequestEditorFn) (*PullscheckIfMergedResponse, error) {
	rsp, err := c.PullscheckIfMerged(ctx, owner, repo, pullNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscheckIfMergedResponse(rsp)
}

// PullsmergeWithBodyWithResponse request with arbitrary body returning *PullsmergeResponse
func (c *ClientWithResponses) PullsmergeWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsmergeResponse, error) {
	rsp, err := c.PullsmergeWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsmergeResponse(rsp)
}

func (c *ClientWithResponses) PullsmergeWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsmergeJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsmergeResponse, error) {
	rsp, err := c.Pullsmerge(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsmergeResponse(rsp)
}

// PullsremoveRequestedReviewersWithBodyWithResponse request with arbitrary body returning *PullsremoveRequestedReviewersResponse
func (c *ClientWithResponses) PullsremoveRequestedReviewersWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsremoveRequestedReviewersResponse, error) {
	rsp, err := c.PullsremoveRequestedReviewersWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsremoveRequestedReviewersResponse(rsp)
}

func (c *ClientWithResponses) PullsremoveRequestedReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsremoveRequestedReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsremoveRequestedReviewersResponse, error) {
	rsp, err := c.PullsremoveRequestedReviewers(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsremoveRequestedReviewersResponse(rsp)
}

// PullslistRequestedReviewersWithResponse request returning *PullslistRequestedReviewersResponse
func (c *ClientWithResponses) PullslistRequestedReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistRequestedReviewersParams, reqEditors ...RequestEditorFn) (*PullslistRequestedReviewersResponse, error) {
	rsp, err := c.PullslistRequestedReviewers(ctx, owner, repo, pullNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistRequestedReviewersResponse(rsp)
}

// PullsrequestReviewersWithBodyWithResponse request with arbitrary body returning *PullsrequestReviewersResponse
func (c *ClientWithResponses) PullsrequestReviewersWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsrequestReviewersResponse, error) {
	rsp, err := c.PullsrequestReviewersWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsrequestReviewersResponse(rsp)
}

func (c *ClientWithResponses) PullsrequestReviewersWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsrequestReviewersJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsrequestReviewersResponse, error) {
	rsp, err := c.PullsrequestReviewers(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsrequestReviewersResponse(rsp)
}

// PullslistReviewsWithResponse request returning *PullslistReviewsResponse
func (c *ClientWithResponses) PullslistReviewsWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, params *PullslistReviewsParams, reqEditors ...RequestEditorFn) (*PullslistReviewsResponse, error) {
	rsp, err := c.PullslistReviews(ctx, owner, repo, pullNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistReviewsResponse(rsp)
}

// PullscreateReviewWithBodyWithResponse request with arbitrary body returning *PullscreateReviewResponse
func (c *ClientWithResponses) PullscreateReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullscreateReviewResponse, error) {
	rsp, err := c.PullscreateReviewWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReviewResponse(rsp)
}

func (c *ClientWithResponses) PullscreateReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullscreateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullscreateReviewResponse, error) {
	rsp, err := c.PullscreateReview(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullscreateReviewResponse(rsp)
}

// PullsdeletePendingReviewWithResponse request returning *PullsdeletePendingReviewResponse
func (c *ClientWithResponses) PullsdeletePendingReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*PullsdeletePendingReviewResponse, error) {
	rsp, err := c.PullsdeletePendingReview(ctx, owner, repo, pullNumber, reviewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsdeletePendingReviewResponse(rsp)
}

// PullsgetReviewWithResponse request returning *PullsgetReviewResponse
func (c *ClientWithResponses) PullsgetReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, reqEditors ...RequestEditorFn) (*PullsgetReviewResponse, error) {
	rsp, err := c.PullsgetReview(ctx, owner, repo, pullNumber, reviewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsgetReviewResponse(rsp)
}

// PullsupdateReviewWithBodyWithResponse request with arbitrary body returning *PullsupdateReviewResponse
func (c *ClientWithResponses) PullsupdateReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateReviewResponse, error) {
	rsp, err := c.PullsupdateReviewWithBody(ctx, owner, repo, pullNumber, reviewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateReviewResponse(rsp)
}

func (c *ClientWithResponses) PullsupdateReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsupdateReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateReviewResponse, error) {
	rsp, err := c.PullsupdateReview(ctx, owner, repo, pullNumber, reviewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateReviewResponse(rsp)
}

// PullslistCommentsForReviewWithResponse request returning *PullslistCommentsForReviewResponse
func (c *ClientWithResponses) PullslistCommentsForReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, params *PullslistCommentsForReviewParams, reqEditors ...RequestEditorFn) (*PullslistCommentsForReviewResponse, error) {
	rsp, err := c.PullslistCommentsForReview(ctx, owner, repo, pullNumber, reviewId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullslistCommentsForReviewResponse(rsp)
}

// PullsdismissReviewWithBodyWithResponse request with arbitrary body returning *PullsdismissReviewResponse
func (c *ClientWithResponses) PullsdismissReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsdismissReviewResponse, error) {
	rsp, err := c.PullsdismissReviewWithBody(ctx, owner, repo, pullNumber, reviewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsdismissReviewResponse(rsp)
}

func (c *ClientWithResponses) PullsdismissReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullsdismissReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsdismissReviewResponse, error) {
	rsp, err := c.PullsdismissReview(ctx, owner, repo, pullNumber, reviewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsdismissReviewResponse(rsp)
}

// PullssubmitReviewWithBodyWithResponse request with arbitrary body returning *PullssubmitReviewResponse
func (c *ClientWithResponses) PullssubmitReviewWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullssubmitReviewResponse, error) {
	rsp, err := c.PullssubmitReviewWithBody(ctx, owner, repo, pullNumber, reviewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullssubmitReviewResponse(rsp)
}

func (c *ClientWithResponses) PullssubmitReviewWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, reviewId ReviewId, body PullssubmitReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*PullssubmitReviewResponse, error) {
	rsp, err := c.PullssubmitReview(ctx, owner, repo, pullNumber, reviewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullssubmitReviewResponse(rsp)
}

// PullsupdateBranchWithBodyWithResponse request with arbitrary body returning *PullsupdateBranchResponse
func (c *ClientWithResponses) PullsupdateBranchWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PullsupdateBranchResponse, error) {
	rsp, err := c.PullsupdateBranchWithBody(ctx, owner, repo, pullNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateBranchResponse(rsp)
}

func (c *ClientWithResponses) PullsupdateBranchWithResponse(ctx context.Context, owner Owner, repo Repo, pullNumber PullNumber, body PullsupdateBranchJSONRequestBody, reqEditors ...RequestEditorFn) (*PullsupdateBranchResponse, error) {
	rsp, err := c.PullsupdateBranch(ctx, owner, repo, pullNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePullsupdateBranchResponse(rsp)
}

// ReposgetReadmeWithResponse request returning *ReposgetReadmeResponse
func (c *ClientWithResponses) ReposgetReadmeWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetReadmeParams, reqEditors ...RequestEditorFn) (*ReposgetReadmeResponse, error) {
	rsp, err := c.ReposgetReadme(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetReadmeResponse(rsp)
}

// ReposgetReadmeInDirectoryWithResponse request returning *ReposgetReadmeInDirectoryResponse
func (c *ClientWithResponses) ReposgetReadmeInDirectoryWithResponse(ctx context.Context, owner Owner, repo Repo, dir string, params *ReposgetReadmeInDirectoryParams, reqEditors ...RequestEditorFn) (*ReposgetReadmeInDirectoryResponse, error) {
	rsp, err := c.ReposgetReadmeInDirectory(ctx, owner, repo, dir, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetReadmeInDirectoryResponse(rsp)
}

// ReposlistReleasesWithResponse request returning *ReposlistReleasesResponse
func (c *ClientWithResponses) ReposlistReleasesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistReleasesParams, reqEditors ...RequestEditorFn) (*ReposlistReleasesResponse, error) {
	rsp, err := c.ReposlistReleases(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistReleasesResponse(rsp)
}

// ReposcreateReleaseWithBodyWithResponse request with arbitrary body returning *ReposcreateReleaseResponse
func (c *ClientWithResponses) ReposcreateReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateReleaseResponse, error) {
	rsp, err := c.ReposcreateReleaseWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateReleaseResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateReleaseResponse, error) {
	rsp, err := c.ReposcreateRelease(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateReleaseResponse(rsp)
}

// ReposdeleteReleaseAssetWithResponse request returning *ReposdeleteReleaseAssetResponse
func (c *ClientWithResponses) ReposdeleteReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*ReposdeleteReleaseAssetResponse, error) {
	rsp, err := c.ReposdeleteReleaseAsset(ctx, owner, repo, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteReleaseAssetResponse(rsp)
}

// ReposgetReleaseAssetWithResponse request returning *ReposgetReleaseAssetResponse
func (c *ClientWithResponses) ReposgetReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, reqEditors ...RequestEditorFn) (*ReposgetReleaseAssetResponse, error) {
	rsp, err := c.ReposgetReleaseAsset(ctx, owner, repo, assetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetReleaseAssetResponse(rsp)
}

// ReposupdateReleaseAssetWithBodyWithResponse request with arbitrary body returning *ReposupdateReleaseAssetResponse
func (c *ClientWithResponses) ReposupdateReleaseAssetWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateReleaseAssetResponse, error) {
	rsp, err := c.ReposupdateReleaseAssetWithBody(ctx, owner, repo, assetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateReleaseAssetResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateReleaseAssetWithResponse(ctx context.Context, owner Owner, repo Repo, assetId AssetId, body ReposupdateReleaseAssetJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateReleaseAssetResponse, error) {
	rsp, err := c.ReposupdateReleaseAsset(ctx, owner, repo, assetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateReleaseAssetResponse(rsp)
}

// ReposgenerateReleaseNotesWithBodyWithResponse request with arbitrary body returning *ReposgenerateReleaseNotesResponse
func (c *ClientWithResponses) ReposgenerateReleaseNotesWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposgenerateReleaseNotesResponse, error) {
	rsp, err := c.ReposgenerateReleaseNotesWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgenerateReleaseNotesResponse(rsp)
}

func (c *ClientWithResponses) ReposgenerateReleaseNotesWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposgenerateReleaseNotesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposgenerateReleaseNotesResponse, error) {
	rsp, err := c.ReposgenerateReleaseNotes(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgenerateReleaseNotesResponse(rsp)
}

// ReposgetLatestReleaseWithResponse request returning *ReposgetLatestReleaseResponse
func (c *ClientWithResponses) ReposgetLatestReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetLatestReleaseResponse, error) {
	rsp, err := c.ReposgetLatestRelease(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetLatestReleaseResponse(rsp)
}

// ReposgetReleaseByTagWithResponse request returning *ReposgetReleaseByTagResponse
func (c *ClientWithResponses) ReposgetReleaseByTagWithResponse(ctx context.Context, owner Owner, repo Repo, tag string, reqEditors ...RequestEditorFn) (*ReposgetReleaseByTagResponse, error) {
	rsp, err := c.ReposgetReleaseByTag(ctx, owner, repo, tag, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetReleaseByTagResponse(rsp)
}

// ReposdeleteReleaseWithResponse request returning *ReposdeleteReleaseResponse
func (c *ClientWithResponses) ReposdeleteReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*ReposdeleteReleaseResponse, error) {
	rsp, err := c.ReposdeleteRelease(ctx, owner, repo, releaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteReleaseResponse(rsp)
}

// ReposgetReleaseWithResponse request returning *ReposgetReleaseResponse
func (c *ClientWithResponses) ReposgetReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reqEditors ...RequestEditorFn) (*ReposgetReleaseResponse, error) {
	rsp, err := c.ReposgetRelease(ctx, owner, repo, releaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetReleaseResponse(rsp)
}

// ReposupdateReleaseWithBodyWithResponse request with arbitrary body returning *ReposupdateReleaseResponse
func (c *ClientWithResponses) ReposupdateReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposupdateReleaseResponse, error) {
	rsp, err := c.ReposupdateReleaseWithBody(ctx, owner, repo, releaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateReleaseResponse(rsp)
}

func (c *ClientWithResponses) ReposupdateReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReposupdateReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposupdateReleaseResponse, error) {
	rsp, err := c.ReposupdateRelease(ctx, owner, repo, releaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposupdateReleaseResponse(rsp)
}

// ReposlistReleaseAssetsWithResponse request returning *ReposlistReleaseAssetsResponse
func (c *ClientWithResponses) ReposlistReleaseAssetsWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposlistReleaseAssetsParams, reqEditors ...RequestEditorFn) (*ReposlistReleaseAssetsResponse, error) {
	rsp, err := c.ReposlistReleaseAssets(ctx, owner, repo, releaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistReleaseAssetsResponse(rsp)
}

// ReposuploadReleaseAssetWithBodyWithResponse request with arbitrary body returning *ReposuploadReleaseAssetResponse
func (c *ClientWithResponses) ReposuploadReleaseAssetWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReposuploadReleaseAssetParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposuploadReleaseAssetResponse, error) {
	rsp, err := c.ReposuploadReleaseAssetWithBody(ctx, owner, repo, releaseId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposuploadReleaseAssetResponse(rsp)
}

// ReactionslistForReleaseWithResponse request returning *ReactionslistForReleaseResponse
func (c *ClientWithResponses) ReactionslistForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, params *ReactionslistForReleaseParams, reqEditors ...RequestEditorFn) (*ReactionslistForReleaseResponse, error) {
	rsp, err := c.ReactionslistForRelease(ctx, owner, repo, releaseId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForReleaseResponse(rsp)
}

// ReactionscreateForReleaseWithBodyWithResponse request with arbitrary body returning *ReactionscreateForReleaseResponse
func (c *ClientWithResponses) ReactionscreateForReleaseWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForReleaseResponse, error) {
	rsp, err := c.ReactionscreateForReleaseWithBody(ctx, owner, repo, releaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForReleaseResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, body ReactionscreateForReleaseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForReleaseResponse, error) {
	rsp, err := c.ReactionscreateForRelease(ctx, owner, repo, releaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForReleaseResponse(rsp)
}

// ReactionsdeleteForReleaseWithResponse request returning *ReactionsdeleteForReleaseResponse
func (c *ClientWithResponses) ReactionsdeleteForReleaseWithResponse(ctx context.Context, owner Owner, repo Repo, releaseId ReleaseId, reactionId ReactionId, reqEditors ...RequestEditorFn) (*ReactionsdeleteForReleaseResponse, error) {
	rsp, err := c.ReactionsdeleteForRelease(ctx, owner, repo, releaseId, reactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionsdeleteForReleaseResponse(rsp)
}

// SecretScanninglistAlertsForRepoWithResponse request returning *SecretScanninglistAlertsForRepoResponse
func (c *ClientWithResponses) SecretScanninglistAlertsForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *SecretScanninglistAlertsForRepoParams, reqEditors ...RequestEditorFn) (*SecretScanninglistAlertsForRepoResponse, error) {
	rsp, err := c.SecretScanninglistAlertsForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanninglistAlertsForRepoResponse(rsp)
}

// SecretScanninggetAlertWithResponse request returning *SecretScanninggetAlertResponse
func (c *ClientWithResponses) SecretScanninggetAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, reqEditors ...RequestEditorFn) (*SecretScanninggetAlertResponse, error) {
	rsp, err := c.SecretScanninggetAlert(ctx, owner, repo, alertNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanninggetAlertResponse(rsp)
}

// SecretScanningupdateAlertWithBodyWithResponse request with arbitrary body returning *SecretScanningupdateAlertResponse
func (c *ClientWithResponses) SecretScanningupdateAlertWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SecretScanningupdateAlertResponse, error) {
	rsp, err := c.SecretScanningupdateAlertWithBody(ctx, owner, repo, alertNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanningupdateAlertResponse(rsp)
}

func (c *ClientWithResponses) SecretScanningupdateAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, body SecretScanningupdateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*SecretScanningupdateAlertResponse, error) {
	rsp, err := c.SecretScanningupdateAlert(ctx, owner, repo, alertNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanningupdateAlertResponse(rsp)
}

// SecretScanninglistLocationsForAlertWithResponse request returning *SecretScanninglistLocationsForAlertResponse
func (c *ClientWithResponses) SecretScanninglistLocationsForAlertWithResponse(ctx context.Context, owner Owner, repo Repo, alertNumber AlertNumber, params *SecretScanninglistLocationsForAlertParams, reqEditors ...RequestEditorFn) (*SecretScanninglistLocationsForAlertResponse, error) {
	rsp, err := c.SecretScanninglistLocationsForAlert(ctx, owner, repo, alertNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSecretScanninglistLocationsForAlertResponse(rsp)
}

// ActivitylistStargazersForRepoWithResponse request returning *ActivitylistStargazersForRepoResponse
func (c *ClientWithResponses) ActivitylistStargazersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistStargazersForRepoParams, reqEditors ...RequestEditorFn) (*ActivitylistStargazersForRepoResponse, error) {
	rsp, err := c.ActivitylistStargazersForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistStargazersForRepoResponse(rsp)
}

// ReposgetCodeFrequencyStatsWithResponse request returning *ReposgetCodeFrequencyStatsResponse
func (c *ClientWithResponses) ReposgetCodeFrequencyStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCodeFrequencyStatsResponse, error) {
	rsp, err := c.ReposgetCodeFrequencyStats(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCodeFrequencyStatsResponse(rsp)
}

// ReposgetCommitActivityStatsWithResponse request returning *ReposgetCommitActivityStatsResponse
func (c *ClientWithResponses) ReposgetCommitActivityStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetCommitActivityStatsResponse, error) {
	rsp, err := c.ReposgetCommitActivityStats(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetCommitActivityStatsResponse(rsp)
}

// ReposgetContributorsStatsWithResponse request returning *ReposgetContributorsStatsResponse
func (c *ClientWithResponses) ReposgetContributorsStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetContributorsStatsResponse, error) {
	rsp, err := c.ReposgetContributorsStats(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetContributorsStatsResponse(rsp)
}

// ReposgetParticipationStatsWithResponse request returning *ReposgetParticipationStatsResponse
func (c *ClientWithResponses) ReposgetParticipationStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetParticipationStatsResponse, error) {
	rsp, err := c.ReposgetParticipationStats(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetParticipationStatsResponse(rsp)
}

// ReposgetPunchCardStatsWithResponse request returning *ReposgetPunchCardStatsResponse
func (c *ClientWithResponses) ReposgetPunchCardStatsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetPunchCardStatsResponse, error) {
	rsp, err := c.ReposgetPunchCardStats(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetPunchCardStatsResponse(rsp)
}

// ReposcreateCommitStatusWithBodyWithResponse request with arbitrary body returning *ReposcreateCommitStatusResponse
func (c *ClientWithResponses) ReposcreateCommitStatusWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, sha string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateCommitStatusResponse, error) {
	rsp, err := c.ReposcreateCommitStatusWithBody(ctx, owner, repo, sha, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateCommitStatusResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateCommitStatusWithResponse(ctx context.Context, owner Owner, repo Repo, sha string, body ReposcreateCommitStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateCommitStatusResponse, error) {
	rsp, err := c.ReposcreateCommitStatus(ctx, owner, repo, sha, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateCommitStatusResponse(rsp)
}

// ActivitylistWatchersForRepoWithResponse request returning *ActivitylistWatchersForRepoResponse
func (c *ClientWithResponses) ActivitylistWatchersForRepoWithResponse(ctx context.Context, owner Owner, repo Repo, params *ActivitylistWatchersForRepoParams, reqEditors ...RequestEditorFn) (*ActivitylistWatchersForRepoResponse, error) {
	rsp, err := c.ActivitylistWatchersForRepo(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistWatchersForRepoResponse(rsp)
}

// ActivitydeleteRepoSubscriptionWithResponse request returning *ActivitydeleteRepoSubscriptionResponse
func (c *ClientWithResponses) ActivitydeleteRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitydeleteRepoSubscriptionResponse, error) {
	rsp, err := c.ActivitydeleteRepoSubscription(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitydeleteRepoSubscriptionResponse(rsp)
}

// ActivitygetRepoSubscriptionWithResponse request returning *ActivitygetRepoSubscriptionResponse
func (c *ClientWithResponses) ActivitygetRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitygetRepoSubscriptionResponse, error) {
	rsp, err := c.ActivitygetRepoSubscription(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitygetRepoSubscriptionResponse(rsp)
}

// ActivitysetRepoSubscriptionWithBodyWithResponse request with arbitrary body returning *ActivitysetRepoSubscriptionResponse
func (c *ClientWithResponses) ActivitysetRepoSubscriptionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActivitysetRepoSubscriptionResponse, error) {
	rsp, err := c.ActivitysetRepoSubscriptionWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitysetRepoSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) ActivitysetRepoSubscriptionWithResponse(ctx context.Context, owner Owner, repo Repo, body ActivitysetRepoSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ActivitysetRepoSubscriptionResponse, error) {
	rsp, err := c.ActivitysetRepoSubscription(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitysetRepoSubscriptionResponse(rsp)
}

// ReposlistTagsWithResponse request returning *ReposlistTagsResponse
func (c *ClientWithResponses) ReposlistTagsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistTagsParams, reqEditors ...RequestEditorFn) (*ReposlistTagsResponse, error) {
	rsp, err := c.ReposlistTags(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistTagsResponse(rsp)
}

// ReposlistTagProtectionWithResponse request returning *ReposlistTagProtectionResponse
func (c *ClientWithResponses) ReposlistTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposlistTagProtectionResponse, error) {
	rsp, err := c.ReposlistTagProtection(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistTagProtectionResponse(rsp)
}

// ReposcreateTagProtectionWithBodyWithResponse request with arbitrary body returning *ReposcreateTagProtectionResponse
func (c *ClientWithResponses) ReposcreateTagProtectionWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateTagProtectionResponse, error) {
	rsp, err := c.ReposcreateTagProtectionWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateTagProtectionResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposcreateTagProtectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateTagProtectionResponse, error) {
	rsp, err := c.ReposcreateTagProtection(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateTagProtectionResponse(rsp)
}

// ReposdeleteTagProtectionWithResponse request returning *ReposdeleteTagProtectionResponse
func (c *ClientWithResponses) ReposdeleteTagProtectionWithResponse(ctx context.Context, owner Owner, repo Repo, tagProtectionId TagProtectionId, reqEditors ...RequestEditorFn) (*ReposdeleteTagProtectionResponse, error) {
	rsp, err := c.ReposdeleteTagProtection(ctx, owner, repo, tagProtectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeleteTagProtectionResponse(rsp)
}

// ReposdownloadTarballArchiveWithResponse request returning *ReposdownloadTarballArchiveResponse
func (c *ClientWithResponses) ReposdownloadTarballArchiveWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*ReposdownloadTarballArchiveResponse, error) {
	rsp, err := c.ReposdownloadTarballArchive(ctx, owner, repo, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdownloadTarballArchiveResponse(rsp)
}

// ReposlistTeamsWithResponse request returning *ReposlistTeamsResponse
func (c *ClientWithResponses) ReposlistTeamsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposlistTeamsParams, reqEditors ...RequestEditorFn) (*ReposlistTeamsResponse, error) {
	rsp, err := c.ReposlistTeams(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistTeamsResponse(rsp)
}

// ReposgetAllTopicsWithResponse request returning *ReposgetAllTopicsResponse
func (c *ClientWithResponses) ReposgetAllTopicsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetAllTopicsParams, reqEditors ...RequestEditorFn) (*ReposgetAllTopicsResponse, error) {
	rsp, err := c.ReposgetAllTopics(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetAllTopicsResponse(rsp)
}

// ReposreplaceAllTopicsWithBodyWithResponse request with arbitrary body returning *ReposreplaceAllTopicsResponse
func (c *ClientWithResponses) ReposreplaceAllTopicsWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposreplaceAllTopicsResponse, error) {
	rsp, err := c.ReposreplaceAllTopicsWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposreplaceAllTopicsResponse(rsp)
}

func (c *ClientWithResponses) ReposreplaceAllTopicsWithResponse(ctx context.Context, owner Owner, repo Repo, body ReposreplaceAllTopicsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposreplaceAllTopicsResponse, error) {
	rsp, err := c.ReposreplaceAllTopics(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposreplaceAllTopicsResponse(rsp)
}

// ReposgetClonesWithResponse request returning *ReposgetClonesResponse
func (c *ClientWithResponses) ReposgetClonesWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetClonesParams, reqEditors ...RequestEditorFn) (*ReposgetClonesResponse, error) {
	rsp, err := c.ReposgetClones(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetClonesResponse(rsp)
}

// ReposgetTopPathsWithResponse request returning *ReposgetTopPathsResponse
func (c *ClientWithResponses) ReposgetTopPathsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetTopPathsResponse, error) {
	rsp, err := c.ReposgetTopPaths(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetTopPathsResponse(rsp)
}

// ReposgetTopReferrersWithResponse request returning *ReposgetTopReferrersResponse
func (c *ClientWithResponses) ReposgetTopReferrersWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposgetTopReferrersResponse, error) {
	rsp, err := c.ReposgetTopReferrers(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetTopReferrersResponse(rsp)
}

// ReposgetViewsWithResponse request returning *ReposgetViewsResponse
func (c *ClientWithResponses) ReposgetViewsWithResponse(ctx context.Context, owner Owner, repo Repo, params *ReposgetViewsParams, reqEditors ...RequestEditorFn) (*ReposgetViewsResponse, error) {
	rsp, err := c.ReposgetViews(ctx, owner, repo, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposgetViewsResponse(rsp)
}

// RepostransferWithBodyWithResponse request with arbitrary body returning *RepostransferResponse
func (c *ClientWithResponses) RepostransferWithBodyWithResponse(ctx context.Context, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RepostransferResponse, error) {
	rsp, err := c.RepostransferWithBody(ctx, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepostransferResponse(rsp)
}

func (c *ClientWithResponses) RepostransferWithResponse(ctx context.Context, owner Owner, repo Repo, body RepostransferJSONRequestBody, reqEditors ...RequestEditorFn) (*RepostransferResponse, error) {
	rsp, err := c.Repostransfer(ctx, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRepostransferResponse(rsp)
}

// ReposdisableVulnerabilityAlertsWithResponse request returning *ReposdisableVulnerabilityAlertsResponse
func (c *ClientWithResponses) ReposdisableVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposdisableVulnerabilityAlertsResponse, error) {
	rsp, err := c.ReposdisableVulnerabilityAlerts(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdisableVulnerabilityAlertsResponse(rsp)
}

// ReposcheckVulnerabilityAlertsWithResponse request returning *ReposcheckVulnerabilityAlertsResponse
func (c *ClientWithResponses) ReposcheckVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposcheckVulnerabilityAlertsResponse, error) {
	rsp, err := c.ReposcheckVulnerabilityAlerts(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcheckVulnerabilityAlertsResponse(rsp)
}

// ReposenableVulnerabilityAlertsWithResponse request returning *ReposenableVulnerabilityAlertsResponse
func (c *ClientWithResponses) ReposenableVulnerabilityAlertsWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ReposenableVulnerabilityAlertsResponse, error) {
	rsp, err := c.ReposenableVulnerabilityAlerts(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposenableVulnerabilityAlertsResponse(rsp)
}

// ReposdownloadZipballArchiveWithResponse request returning *ReposdownloadZipballArchiveResponse
func (c *ClientWithResponses) ReposdownloadZipballArchiveWithResponse(ctx context.Context, owner Owner, repo Repo, ref string, reqEditors ...RequestEditorFn) (*ReposdownloadZipballArchiveResponse, error) {
	rsp, err := c.ReposdownloadZipballArchive(ctx, owner, repo, ref, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdownloadZipballArchiveResponse(rsp)
}

// ReposcreateUsingTemplateWithBodyWithResponse request with arbitrary body returning *ReposcreateUsingTemplateResponse
func (c *ClientWithResponses) ReposcreateUsingTemplateWithBodyWithResponse(ctx context.Context, templateOwner string, templateRepo string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateUsingTemplateResponse, error) {
	rsp, err := c.ReposcreateUsingTemplateWithBody(ctx, templateOwner, templateRepo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateUsingTemplateResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateUsingTemplateWithResponse(ctx context.Context, templateOwner string, templateRepo string, body ReposcreateUsingTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateUsingTemplateResponse, error) {
	rsp, err := c.ReposcreateUsingTemplate(ctx, templateOwner, templateRepo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateUsingTemplateResponse(rsp)
}

// ReposlistPublicWithResponse request returning *ReposlistPublicResponse
func (c *ClientWithResponses) ReposlistPublicWithResponse(ctx context.Context, params *ReposlistPublicParams, reqEditors ...RequestEditorFn) (*ReposlistPublicResponse, error) {
	rsp, err := c.ReposlistPublic(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistPublicResponse(rsp)
}

// ActionslistEnvironmentSecretsWithResponse request returning *ActionslistEnvironmentSecretsResponse
func (c *ClientWithResponses) ActionslistEnvironmentSecretsWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, params *ActionslistEnvironmentSecretsParams, reqEditors ...RequestEditorFn) (*ActionslistEnvironmentSecretsResponse, error) {
	rsp, err := c.ActionslistEnvironmentSecrets(ctx, repositoryId, environmentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionslistEnvironmentSecretsResponse(rsp)
}

// ActionsgetEnvironmentPublicKeyWithResponse request returning *ActionsgetEnvironmentPublicKeyResponse
func (c *ClientWithResponses) ActionsgetEnvironmentPublicKeyWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, reqEditors ...RequestEditorFn) (*ActionsgetEnvironmentPublicKeyResponse, error) {
	rsp, err := c.ActionsgetEnvironmentPublicKey(ctx, repositoryId, environmentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetEnvironmentPublicKeyResponse(rsp)
}

// ActionsdeleteEnvironmentSecretWithResponse request returning *ActionsdeleteEnvironmentSecretResponse
func (c *ClientWithResponses) ActionsdeleteEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsdeleteEnvironmentSecretResponse, error) {
	rsp, err := c.ActionsdeleteEnvironmentSecret(ctx, repositoryId, environmentName, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsdeleteEnvironmentSecretResponse(rsp)
}

// ActionsgetEnvironmentSecretWithResponse request returning *ActionsgetEnvironmentSecretResponse
func (c *ClientWithResponses) ActionsgetEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, reqEditors ...RequestEditorFn) (*ActionsgetEnvironmentSecretResponse, error) {
	rsp, err := c.ActionsgetEnvironmentSecret(ctx, repositoryId, environmentName, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionsgetEnvironmentSecretResponse(rsp)
}

// ActionscreateOrUpdateEnvironmentSecretWithBodyWithResponse request with arbitrary body returning *ActionscreateOrUpdateEnvironmentSecretResponse
func (c *ClientWithResponses) ActionscreateOrUpdateEnvironmentSecretWithBodyWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateEnvironmentSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateEnvironmentSecretWithBody(ctx, repositoryId, environmentName, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateEnvironmentSecretResponse(rsp)
}

func (c *ClientWithResponses) ActionscreateOrUpdateEnvironmentSecretWithResponse(ctx context.Context, repositoryId RepositoryId, environmentName EnvironmentName, secretName SecretName, body ActionscreateOrUpdateEnvironmentSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*ActionscreateOrUpdateEnvironmentSecretResponse, error) {
	rsp, err := c.ActionscreateOrUpdateEnvironmentSecret(ctx, repositoryId, environmentName, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActionscreateOrUpdateEnvironmentSecretResponse(rsp)
}

// EnterpriseAdminlistProvisionedGroupsEnterpriseWithResponse request returning *EnterpriseAdminlistProvisionedGroupsEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistProvisionedGroupsEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedGroupsEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistProvisionedGroupsEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistProvisionedGroupsEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistProvisionedGroupsEnterpriseResponse(rsp)
}

// EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse
func (c *ClientWithResponses) EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminprovisionAndInviteEnterpriseGroupWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminprovisionAndInviteEnterpriseGroupResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminprovisionAndInviteEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminprovisionAndInviteEnterpriseGroup(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminprovisionAndInviteEnterpriseGroupResponse(rsp)
}

// EnterpriseAdmindeleteScimGroupFromEnterpriseWithResponse request returning *EnterpriseAdmindeleteScimGroupFromEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmindeleteScimGroupFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteScimGroupFromEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmindeleteScimGroupFromEnterprise(ctx, enterprise, scimGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmindeleteScimGroupFromEnterpriseResponse(rsp)
}

// EnterpriseAdmingetProvisioningInformationForEnterpriseGroupWithResponse request returning *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse
func (c *ClientWithResponses) EnterpriseAdmingetProvisioningInformationForEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, params *EnterpriseAdmingetProvisioningInformationForEnterpriseGroupParams, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdmingetProvisioningInformationForEnterpriseGroup(ctx, enterprise, scimGroupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse(rsp)
}

// EnterpriseAdminupdateAttributeForEnterpriseGroupWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminupdateAttributeForEnterpriseGroupResponse
func (c *ClientWithResponses) EnterpriseAdminupdateAttributeForEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminupdateAttributeForEnterpriseGroupWithBody(ctx, enterprise, scimGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateAttributeForEnterpriseGroupResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminupdateAttributeForEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminupdateAttributeForEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminupdateAttributeForEnterpriseGroup(ctx, enterprise, scimGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateAttributeForEnterpriseGroupResponse(rsp)
}

// EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse
func (c *ClientWithResponses) EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithBody(ctx, enterprise, scimGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithResponse(ctx context.Context, enterprise Enterprise, scimGroupId ScimGroupId, body EnterpriseAdminsetInformationForProvisionedEnterpriseGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse, error) {
	rsp, err := c.EnterpriseAdminsetInformationForProvisionedEnterpriseGroup(ctx, enterprise, scimGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse(rsp)
}

// EnterpriseAdminlistProvisionedIdentitiesEnterpriseWithResponse request returning *EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdminlistProvisionedIdentitiesEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, params *EnterpriseAdminlistProvisionedIdentitiesEnterpriseParams, reqEditors ...RequestEditorFn) (*EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdminlistProvisionedIdentitiesEnterprise(ctx, enterprise, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse(rsp)
}

// EnterpriseAdminprovisionAndInviteEnterpriseUserWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminprovisionAndInviteEnterpriseUserResponse
func (c *ClientWithResponses) EnterpriseAdminprovisionAndInviteEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminprovisionAndInviteEnterpriseUserWithBody(ctx, enterprise, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminprovisionAndInviteEnterpriseUserResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminprovisionAndInviteEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, body EnterpriseAdminprovisionAndInviteEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminprovisionAndInviteEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminprovisionAndInviteEnterpriseUser(ctx, enterprise, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminprovisionAndInviteEnterpriseUserResponse(rsp)
}

// EnterpriseAdmindeleteUserFromEnterpriseWithResponse request returning *EnterpriseAdmindeleteUserFromEnterpriseResponse
func (c *ClientWithResponses) EnterpriseAdmindeleteUserFromEnterpriseWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*EnterpriseAdmindeleteUserFromEnterpriseResponse, error) {
	rsp, err := c.EnterpriseAdmindeleteUserFromEnterprise(ctx, enterprise, scimUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmindeleteUserFromEnterpriseResponse(rsp)
}

// EnterpriseAdmingetProvisioningInformationForEnterpriseUserWithResponse request returning *EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse
func (c *ClientWithResponses) EnterpriseAdmingetProvisioningInformationForEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdmingetProvisioningInformationForEnterpriseUser(ctx, enterprise, scimUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse(rsp)
}

// EnterpriseAdminupdateAttributeForEnterpriseUserWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminupdateAttributeForEnterpriseUserResponse
func (c *ClientWithResponses) EnterpriseAdminupdateAttributeForEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminupdateAttributeForEnterpriseUserWithBody(ctx, enterprise, scimUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateAttributeForEnterpriseUserResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminupdateAttributeForEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminupdateAttributeForEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminupdateAttributeForEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminupdateAttributeForEnterpriseUser(ctx, enterprise, scimUserId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminupdateAttributeForEnterpriseUserResponse(rsp)
}

// EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBodyWithResponse request with arbitrary body returning *EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse
func (c *ClientWithResponses) EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBodyWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithBody(ctx, enterprise, scimUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse(rsp)
}

func (c *ClientWithResponses) EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithResponse(ctx context.Context, enterprise Enterprise, scimUserId ScimUserId, body EnterpriseAdminsetInformationForProvisionedEnterpriseUserJSONRequestBody, reqEditors ...RequestEditorFn) (*EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse, error) {
	rsp, err := c.EnterpriseAdminsetInformationForProvisionedEnterpriseUser(ctx, enterprise, scimUserId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse(rsp)
}

// ScimlistProvisionedIdentitiesWithResponse request returning *ScimlistProvisionedIdentitiesResponse
func (c *ClientWithResponses) ScimlistProvisionedIdentitiesWithResponse(ctx context.Context, org Org, params *ScimlistProvisionedIdentitiesParams, reqEditors ...RequestEditorFn) (*ScimlistProvisionedIdentitiesResponse, error) {
	rsp, err := c.ScimlistProvisionedIdentities(ctx, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimlistProvisionedIdentitiesResponse(rsp)
}

// ScimprovisionAndInviteUserWithBodyWithResponse request with arbitrary body returning *ScimprovisionAndInviteUserResponse
func (c *ClientWithResponses) ScimprovisionAndInviteUserWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimprovisionAndInviteUserResponse, error) {
	rsp, err := c.ScimprovisionAndInviteUserWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimprovisionAndInviteUserResponse(rsp)
}

func (c *ClientWithResponses) ScimprovisionAndInviteUserWithResponse(ctx context.Context, org Org, body ScimprovisionAndInviteUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimprovisionAndInviteUserResponse, error) {
	rsp, err := c.ScimprovisionAndInviteUser(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimprovisionAndInviteUserResponse(rsp)
}

// ScimdeleteUserFromOrgWithResponse request returning *ScimdeleteUserFromOrgResponse
func (c *ClientWithResponses) ScimdeleteUserFromOrgWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*ScimdeleteUserFromOrgResponse, error) {
	rsp, err := c.ScimdeleteUserFromOrg(ctx, org, scimUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimdeleteUserFromOrgResponse(rsp)
}

// ScimgetProvisioningInformationForUserWithResponse request returning *ScimgetProvisioningInformationForUserResponse
func (c *ClientWithResponses) ScimgetProvisioningInformationForUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, reqEditors ...RequestEditorFn) (*ScimgetProvisioningInformationForUserResponse, error) {
	rsp, err := c.ScimgetProvisioningInformationForUser(ctx, org, scimUserId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimgetProvisioningInformationForUserResponse(rsp)
}

// ScimupdateAttributeForUserWithBodyWithResponse request with arbitrary body returning *ScimupdateAttributeForUserResponse
func (c *ClientWithResponses) ScimupdateAttributeForUserWithBodyWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimupdateAttributeForUserResponse, error) {
	rsp, err := c.ScimupdateAttributeForUserWithBody(ctx, org, scimUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimupdateAttributeForUserResponse(rsp)
}

func (c *ClientWithResponses) ScimupdateAttributeForUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, body ScimupdateAttributeForUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimupdateAttributeForUserResponse, error) {
	rsp, err := c.ScimupdateAttributeForUser(ctx, org, scimUserId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimupdateAttributeForUserResponse(rsp)
}

// ScimsetInformationForProvisionedUserWithBodyWithResponse request with arbitrary body returning *ScimsetInformationForProvisionedUserResponse
func (c *ClientWithResponses) ScimsetInformationForProvisionedUserWithBodyWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScimsetInformationForProvisionedUserResponse, error) {
	rsp, err := c.ScimsetInformationForProvisionedUserWithBody(ctx, org, scimUserId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimsetInformationForProvisionedUserResponse(rsp)
}

func (c *ClientWithResponses) ScimsetInformationForProvisionedUserWithResponse(ctx context.Context, org Org, scimUserId ScimUserId, body ScimsetInformationForProvisionedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ScimsetInformationForProvisionedUserResponse, error) {
	rsp, err := c.ScimsetInformationForProvisionedUser(ctx, org, scimUserId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScimsetInformationForProvisionedUserResponse(rsp)
}

// SearchcodeWithResponse request returning *SearchcodeResponse
func (c *ClientWithResponses) SearchcodeWithResponse(ctx context.Context, params *SearchcodeParams, reqEditors ...RequestEditorFn) (*SearchcodeResponse, error) {
	rsp, err := c.Searchcode(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchcodeResponse(rsp)
}

// SearchcommitsWithResponse request returning *SearchcommitsResponse
func (c *ClientWithResponses) SearchcommitsWithResponse(ctx context.Context, params *SearchcommitsParams, reqEditors ...RequestEditorFn) (*SearchcommitsResponse, error) {
	rsp, err := c.Searchcommits(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchcommitsResponse(rsp)
}

// SearchissuesAndPullRequestsWithResponse request returning *SearchissuesAndPullRequestsResponse
func (c *ClientWithResponses) SearchissuesAndPullRequestsWithResponse(ctx context.Context, params *SearchissuesAndPullRequestsParams, reqEditors ...RequestEditorFn) (*SearchissuesAndPullRequestsResponse, error) {
	rsp, err := c.SearchissuesAndPullRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchissuesAndPullRequestsResponse(rsp)
}

// SearchlabelsWithResponse request returning *SearchlabelsResponse
func (c *ClientWithResponses) SearchlabelsWithResponse(ctx context.Context, params *SearchlabelsParams, reqEditors ...RequestEditorFn) (*SearchlabelsResponse, error) {
	rsp, err := c.Searchlabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchlabelsResponse(rsp)
}

// SearchreposWithResponse request returning *SearchreposResponse
func (c *ClientWithResponses) SearchreposWithResponse(ctx context.Context, params *SearchreposParams, reqEditors ...RequestEditorFn) (*SearchreposResponse, error) {
	rsp, err := c.Searchrepos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchreposResponse(rsp)
}

// SearchtopicsWithResponse request returning *SearchtopicsResponse
func (c *ClientWithResponses) SearchtopicsWithResponse(ctx context.Context, params *SearchtopicsParams, reqEditors ...RequestEditorFn) (*SearchtopicsResponse, error) {
	rsp, err := c.Searchtopics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchtopicsResponse(rsp)
}

// SearchusersWithResponse request returning *SearchusersResponse
func (c *ClientWithResponses) SearchusersWithResponse(ctx context.Context, params *SearchusersParams, reqEditors ...RequestEditorFn) (*SearchusersResponse, error) {
	rsp, err := c.Searchusers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchusersResponse(rsp)
}

// TeamsdeleteLegacyWithResponse request returning *TeamsdeleteLegacyResponse
func (c *ClientWithResponses) TeamsdeleteLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamsdeleteLegacyResponse, error) {
	rsp, err := c.TeamsdeleteLegacy(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteLegacyResponse(rsp)
}

// TeamsgetLegacyWithResponse request returning *TeamsgetLegacyResponse
func (c *ClientWithResponses) TeamsgetLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamsgetLegacyResponse, error) {
	rsp, err := c.TeamsgetLegacy(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetLegacyResponse(rsp)
}

// TeamsupdateLegacyWithBodyWithResponse request with arbitrary body returning *TeamsupdateLegacyResponse
func (c *ClientWithResponses) TeamsupdateLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateLegacyResponse, error) {
	rsp, err := c.TeamsupdateLegacyWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamsupdateLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateLegacyResponse, error) {
	rsp, err := c.TeamsupdateLegacy(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateLegacyResponse(rsp)
}

// TeamslistDiscussionsLegacyWithResponse request returning *TeamslistDiscussionsLegacyResponse
func (c *ClientWithResponses) TeamslistDiscussionsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistDiscussionsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionsLegacyResponse, error) {
	rsp, err := c.TeamslistDiscussionsLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistDiscussionsLegacyResponse(rsp)
}

// TeamscreateDiscussionLegacyWithBodyWithResponse request with arbitrary body returning *TeamscreateDiscussionLegacyResponse
func (c *ClientWithResponses) TeamscreateDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionLegacyResponse, error) {
	rsp, err := c.TeamscreateDiscussionLegacyWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamscreateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionLegacyResponse, error) {
	rsp, err := c.TeamscreateDiscussionLegacy(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionLegacyResponse(rsp)
}

// TeamsdeleteDiscussionLegacyWithResponse request returning *TeamsdeleteDiscussionLegacyResponse
func (c *ClientWithResponses) TeamsdeleteDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionLegacyResponse, error) {
	rsp, err := c.TeamsdeleteDiscussionLegacy(ctx, teamId, discussionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteDiscussionLegacyResponse(rsp)
}

// TeamsgetDiscussionLegacyWithResponse request returning *TeamsgetDiscussionLegacyResponse
func (c *ClientWithResponses) TeamsgetDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionLegacyResponse, error) {
	rsp, err := c.TeamsgetDiscussionLegacy(ctx, teamId, discussionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetDiscussionLegacyResponse(rsp)
}

// TeamsupdateDiscussionLegacyWithBodyWithResponse request with arbitrary body returning *TeamsupdateDiscussionLegacyResponse
func (c *ClientWithResponses) TeamsupdateDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionLegacyResponse, error) {
	rsp, err := c.TeamsupdateDiscussionLegacyWithBody(ctx, teamId, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamsupdateDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionLegacyResponse, error) {
	rsp, err := c.TeamsupdateDiscussionLegacy(ctx, teamId, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionLegacyResponse(rsp)
}

// TeamslistDiscussionCommentsLegacyWithResponse request returning *TeamslistDiscussionCommentsLegacyResponse
func (c *ClientWithResponses) TeamslistDiscussionCommentsLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *TeamslistDiscussionCommentsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistDiscussionCommentsLegacyResponse, error) {
	rsp, err := c.TeamslistDiscussionCommentsLegacy(ctx, teamId, discussionNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistDiscussionCommentsLegacyResponse(rsp)
}

// TeamscreateDiscussionCommentLegacyWithBodyWithResponse request with arbitrary body returning *TeamscreateDiscussionCommentLegacyResponse
func (c *ClientWithResponses) TeamscreateDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamscreateDiscussionCommentLegacyWithBody(ctx, teamId, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionCommentLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body TeamscreateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamscreateDiscussionCommentLegacy(ctx, teamId, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateDiscussionCommentLegacyResponse(rsp)
}

// TeamsdeleteDiscussionCommentLegacyWithResponse request returning *TeamsdeleteDiscussionCommentLegacyResponse
func (c *ClientWithResponses) TeamsdeleteDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsdeleteDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamsdeleteDiscussionCommentLegacy(ctx, teamId, discussionNumber, commentNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsdeleteDiscussionCommentLegacyResponse(rsp)
}

// TeamsgetDiscussionCommentLegacyWithResponse request returning *TeamsgetDiscussionCommentLegacyResponse
func (c *ClientWithResponses) TeamsgetDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, reqEditors ...RequestEditorFn) (*TeamsgetDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamsgetDiscussionCommentLegacy(ctx, teamId, discussionNumber, commentNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetDiscussionCommentLegacyResponse(rsp)
}

// TeamsupdateDiscussionCommentLegacyWithBodyWithResponse request with arbitrary body returning *TeamsupdateDiscussionCommentLegacyResponse
func (c *ClientWithResponses) TeamsupdateDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamsupdateDiscussionCommentLegacyWithBody(ctx, teamId, discussionNumber, commentNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionCommentLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsupdateDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body TeamsupdateDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsupdateDiscussionCommentLegacyResponse, error) {
	rsp, err := c.TeamsupdateDiscussionCommentLegacy(ctx, teamId, discussionNumber, commentNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsupdateDiscussionCommentLegacyResponse(rsp)
}

// ReactionslistForTeamDiscussionCommentLegacyWithResponse request returning *ReactionslistForTeamDiscussionCommentLegacyResponse
func (c *ClientWithResponses) ReactionslistForTeamDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, params *ReactionslistForTeamDiscussionCommentLegacyParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionCommentLegacyResponse, error) {
	rsp, err := c.ReactionslistForTeamDiscussionCommentLegacy(ctx, teamId, discussionNumber, commentNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForTeamDiscussionCommentLegacyResponse(rsp)
}

// ReactionscreateForTeamDiscussionCommentLegacyWithBodyWithResponse request with arbitrary body returning *ReactionscreateForTeamDiscussionCommentLegacyResponse
func (c *ClientWithResponses) ReactionscreateForTeamDiscussionCommentLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentLegacyResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionCommentLegacyWithBody(ctx, teamId, discussionNumber, commentNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionCommentLegacyResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForTeamDiscussionCommentLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, commentNumber CommentNumber, body ReactionscreateForTeamDiscussionCommentLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionCommentLegacyResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionCommentLegacy(ctx, teamId, discussionNumber, commentNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionCommentLegacyResponse(rsp)
}

// ReactionslistForTeamDiscussionLegacyWithResponse request returning *ReactionslistForTeamDiscussionLegacyResponse
func (c *ClientWithResponses) ReactionslistForTeamDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, params *ReactionslistForTeamDiscussionLegacyParams, reqEditors ...RequestEditorFn) (*ReactionslistForTeamDiscussionLegacyResponse, error) {
	rsp, err := c.ReactionslistForTeamDiscussionLegacy(ctx, teamId, discussionNumber, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionslistForTeamDiscussionLegacyResponse(rsp)
}

// ReactionscreateForTeamDiscussionLegacyWithBodyWithResponse request with arbitrary body returning *ReactionscreateForTeamDiscussionLegacyResponse
func (c *ClientWithResponses) ReactionscreateForTeamDiscussionLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionLegacyResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionLegacyWithBody(ctx, teamId, discussionNumber, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionLegacyResponse(rsp)
}

func (c *ClientWithResponses) ReactionscreateForTeamDiscussionLegacyWithResponse(ctx context.Context, teamId TeamId, discussionNumber DiscussionNumber, body ReactionscreateForTeamDiscussionLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*ReactionscreateForTeamDiscussionLegacyResponse, error) {
	rsp, err := c.ReactionscreateForTeamDiscussionLegacy(ctx, teamId, discussionNumber, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReactionscreateForTeamDiscussionLegacyResponse(rsp)
}

// TeamslistPendingInvitationsLegacyWithResponse request returning *TeamslistPendingInvitationsLegacyResponse
func (c *ClientWithResponses) TeamslistPendingInvitationsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistPendingInvitationsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistPendingInvitationsLegacyResponse, error) {
	rsp, err := c.TeamslistPendingInvitationsLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistPendingInvitationsLegacyResponse(rsp)
}

// TeamslistMembersLegacyWithResponse request returning *TeamslistMembersLegacyResponse
func (c *ClientWithResponses) TeamslistMembersLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistMembersLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistMembersLegacyResponse, error) {
	rsp, err := c.TeamslistMembersLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistMembersLegacyResponse(rsp)
}

// TeamsremoveMemberLegacyWithResponse request returning *TeamsremoveMemberLegacyResponse
func (c *ClientWithResponses) TeamsremoveMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMemberLegacyResponse, error) {
	rsp, err := c.TeamsremoveMemberLegacy(ctx, teamId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveMemberLegacyResponse(rsp)
}

// TeamsgetMemberLegacyWithResponse request returning *TeamsgetMemberLegacyResponse
func (c *ClientWithResponses) TeamsgetMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMemberLegacyResponse, error) {
	rsp, err := c.TeamsgetMemberLegacy(ctx, teamId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetMemberLegacyResponse(rsp)
}

// TeamsaddMemberLegacyWithResponse request returning *TeamsaddMemberLegacyResponse
func (c *ClientWithResponses) TeamsaddMemberLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsaddMemberLegacyResponse, error) {
	rsp, err := c.TeamsaddMemberLegacy(ctx, teamId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddMemberLegacyResponse(rsp)
}

// TeamsremoveMembershipForUserLegacyWithResponse request returning *TeamsremoveMembershipForUserLegacyResponse
func (c *ClientWithResponses) TeamsremoveMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsremoveMembershipForUserLegacyResponse, error) {
	rsp, err := c.TeamsremoveMembershipForUserLegacy(ctx, teamId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveMembershipForUserLegacyResponse(rsp)
}

// TeamsgetMembershipForUserLegacyWithResponse request returning *TeamsgetMembershipForUserLegacyResponse
func (c *ClientWithResponses) TeamsgetMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, reqEditors ...RequestEditorFn) (*TeamsgetMembershipForUserLegacyResponse, error) {
	rsp, err := c.TeamsgetMembershipForUserLegacy(ctx, teamId, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsgetMembershipForUserLegacyResponse(rsp)
}

// TeamsaddOrUpdateMembershipForUserLegacyWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateMembershipForUserLegacyResponse
func (c *ClientWithResponses) TeamsaddOrUpdateMembershipForUserLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, username Username, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateMembershipForUserLegacyWithBody(ctx, teamId, username, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateMembershipForUserLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateMembershipForUserLegacyWithResponse(ctx context.Context, teamId TeamId, username Username, body TeamsaddOrUpdateMembershipForUserLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateMembershipForUserLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateMembershipForUserLegacy(ctx, teamId, username, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateMembershipForUserLegacyResponse(rsp)
}

// TeamslistProjectsLegacyWithResponse request returning *TeamslistProjectsLegacyResponse
func (c *ClientWithResponses) TeamslistProjectsLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistProjectsLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistProjectsLegacyResponse, error) {
	rsp, err := c.TeamslistProjectsLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistProjectsLegacyResponse(rsp)
}

// TeamsremoveProjectLegacyWithResponse request returning *TeamsremoveProjectLegacyResponse
func (c *ClientWithResponses) TeamsremoveProjectLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamsremoveProjectLegacyResponse, error) {
	rsp, err := c.TeamsremoveProjectLegacy(ctx, teamId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveProjectLegacyResponse(rsp)
}

// TeamscheckPermissionsForProjectLegacyWithResponse request returning *TeamscheckPermissionsForProjectLegacyResponse
func (c *ClientWithResponses) TeamscheckPermissionsForProjectLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForProjectLegacyResponse, error) {
	rsp, err := c.TeamscheckPermissionsForProjectLegacy(ctx, teamId, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscheckPermissionsForProjectLegacyResponse(rsp)
}

// TeamsaddOrUpdateProjectPermissionsLegacyWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateProjectPermissionsLegacyResponse
func (c *ClientWithResponses) TeamsaddOrUpdateProjectPermissionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateProjectPermissionsLegacyWithBody(ctx, teamId, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateProjectPermissionsLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateProjectPermissionsLegacyWithResponse(ctx context.Context, teamId TeamId, projectId ProjectId, body TeamsaddOrUpdateProjectPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateProjectPermissionsLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateProjectPermissionsLegacy(ctx, teamId, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateProjectPermissionsLegacyResponse(rsp)
}

// TeamslistReposLegacyWithResponse request returning *TeamslistReposLegacyResponse
func (c *ClientWithResponses) TeamslistReposLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistReposLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistReposLegacyResponse, error) {
	rsp, err := c.TeamslistReposLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistReposLegacyResponse(rsp)
}

// TeamsremoveRepoLegacyWithResponse request returning *TeamsremoveRepoLegacyResponse
func (c *ClientWithResponses) TeamsremoveRepoLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamsremoveRepoLegacyResponse, error) {
	rsp, err := c.TeamsremoveRepoLegacy(ctx, teamId, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsremoveRepoLegacyResponse(rsp)
}

// TeamscheckPermissionsForRepoLegacyWithResponse request returning *TeamscheckPermissionsForRepoLegacyResponse
func (c *ClientWithResponses) TeamscheckPermissionsForRepoLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*TeamscheckPermissionsForRepoLegacyResponse, error) {
	rsp, err := c.TeamscheckPermissionsForRepoLegacy(ctx, teamId, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscheckPermissionsForRepoLegacyResponse(rsp)
}

// TeamsaddOrUpdateRepoPermissionsLegacyWithBodyWithResponse request with arbitrary body returning *TeamsaddOrUpdateRepoPermissionsLegacyResponse
func (c *ClientWithResponses) TeamsaddOrUpdateRepoPermissionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateRepoPermissionsLegacyWithBody(ctx, teamId, owner, repo, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateRepoPermissionsLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamsaddOrUpdateRepoPermissionsLegacyWithResponse(ctx context.Context, teamId TeamId, owner Owner, repo Repo, body TeamsaddOrUpdateRepoPermissionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamsaddOrUpdateRepoPermissionsLegacyResponse, error) {
	rsp, err := c.TeamsaddOrUpdateRepoPermissionsLegacy(ctx, teamId, owner, repo, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamsaddOrUpdateRepoPermissionsLegacyResponse(rsp)
}

// TeamslistIdpGroupsForLegacyWithResponse request returning *TeamslistIdpGroupsForLegacyResponse
func (c *ClientWithResponses) TeamslistIdpGroupsForLegacyWithResponse(ctx context.Context, teamId TeamId, reqEditors ...RequestEditorFn) (*TeamslistIdpGroupsForLegacyResponse, error) {
	rsp, err := c.TeamslistIdpGroupsForLegacy(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistIdpGroupsForLegacyResponse(rsp)
}

// TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBodyWithResponse request with arbitrary body returning *TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse
func (c *ClientWithResponses) TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBodyWithResponse(ctx context.Context, teamId TeamId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	rsp, err := c.TeamscreateOrUpdateIdpGroupConnectionsLegacyWithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateOrUpdateIdpGroupConnectionsLegacyResponse(rsp)
}

func (c *ClientWithResponses) TeamscreateOrUpdateIdpGroupConnectionsLegacyWithResponse(ctx context.Context, teamId TeamId, body TeamscreateOrUpdateIdpGroupConnectionsLegacyJSONRequestBody, reqEditors ...RequestEditorFn) (*TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	rsp, err := c.TeamscreateOrUpdateIdpGroupConnectionsLegacy(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamscreateOrUpdateIdpGroupConnectionsLegacyResponse(rsp)
}

// TeamslistChildLegacyWithResponse request returning *TeamslistChildLegacyResponse
func (c *ClientWithResponses) TeamslistChildLegacyWithResponse(ctx context.Context, teamId TeamId, params *TeamslistChildLegacyParams, reqEditors ...RequestEditorFn) (*TeamslistChildLegacyResponse, error) {
	rsp, err := c.TeamslistChildLegacy(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistChildLegacyResponse(rsp)
}

// UsersgetAuthenticatedWithResponse request returning *UsersgetAuthenticatedResponse
func (c *ClientWithResponses) UsersgetAuthenticatedWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UsersgetAuthenticatedResponse, error) {
	rsp, err := c.UsersgetAuthenticated(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersgetAuthenticatedResponse(rsp)
}

// UsersupdateAuthenticatedWithBodyWithResponse request with arbitrary body returning *UsersupdateAuthenticatedResponse
func (c *ClientWithResponses) UsersupdateAuthenticatedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersupdateAuthenticatedResponse, error) {
	rsp, err := c.UsersupdateAuthenticatedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersupdateAuthenticatedResponse(rsp)
}

func (c *ClientWithResponses) UsersupdateAuthenticatedWithResponse(ctx context.Context, body UsersupdateAuthenticatedJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersupdateAuthenticatedResponse, error) {
	rsp, err := c.UsersupdateAuthenticated(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersupdateAuthenticatedResponse(rsp)
}

// UserslistBlockedByAuthenticatedUserWithResponse request returning *UserslistBlockedByAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistBlockedByAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserslistBlockedByAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistBlockedByAuthenticatedUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistBlockedByAuthenticatedUserResponse(rsp)
}

// UsersunblockWithResponse request returning *UsersunblockResponse
func (c *ClientWithResponses) UsersunblockWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersunblockResponse, error) {
	rsp, err := c.Usersunblock(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersunblockResponse(rsp)
}

// UserscheckBlockedWithResponse request returning *UserscheckBlockedResponse
func (c *ClientWithResponses) UserscheckBlockedWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UserscheckBlockedResponse, error) {
	rsp, err := c.UserscheckBlocked(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscheckBlockedResponse(rsp)
}

// UsersblockWithResponse request returning *UsersblockResponse
func (c *ClientWithResponses) UsersblockWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersblockResponse, error) {
	rsp, err := c.Usersblock(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersblockResponse(rsp)
}

// CodespaceslistForAuthenticatedUserWithResponse request returning *CodespaceslistForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespaceslistForAuthenticatedUserWithResponse(ctx context.Context, params *CodespaceslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespaceslistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistForAuthenticatedUserResponse(rsp)
}

// CodespacescreateForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacescreateForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacescreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacescreateForAuthenticatedUserWithResponse(ctx context.Context, body CodespacescreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateForAuthenticatedUserResponse(rsp)
}

// CodespaceslistSecretsForAuthenticatedUserWithResponse request returning *CodespaceslistSecretsForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespaceslistSecretsForAuthenticatedUserWithResponse(ctx context.Context, params *CodespaceslistSecretsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*CodespaceslistSecretsForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespaceslistSecretsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistSecretsForAuthenticatedUserResponse(rsp)
}

// CodespacesgetPublicKeyForAuthenticatedUserWithResponse request returning *CodespacesgetPublicKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesgetPublicKeyForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CodespacesgetPublicKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesgetPublicKeyForAuthenticatedUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetPublicKeyForAuthenticatedUserResponse(rsp)
}

// CodespacesdeleteSecretForAuthenticatedUserWithResponse request returning *CodespacesdeleteSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesdeleteSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesdeleteSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesdeleteSecretForAuthenticatedUser(ctx, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesdeleteSecretForAuthenticatedUserResponse(rsp)
}

// CodespacesgetSecretForAuthenticatedUserWithResponse request returning *CodespacesgetSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesgetSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespacesgetSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesgetSecretForAuthenticatedUser(ctx, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetSecretForAuthenticatedUserResponse(rsp)
}

// CodespacescreateOrUpdateSecretForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacescreateOrUpdateSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacescreateOrUpdateSecretForAuthenticatedUserWithBodyWithResponse(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateOrUpdateSecretForAuthenticatedUserWithBody(ctx, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateOrUpdateSecretForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacescreateOrUpdateSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, body CodespacescreateOrUpdateSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacescreateOrUpdateSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescreateOrUpdateSecretForAuthenticatedUser(ctx, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescreateOrUpdateSecretForAuthenticatedUserResponse(rsp)
}

// CodespaceslistRepositoriesForSecretForAuthenticatedUserWithResponse request returning *CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespaceslistRepositoriesForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, reqEditors ...RequestEditorFn) (*CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespaceslistRepositoriesForSecretForAuthenticatedUser(ctx, secretName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespaceslistRepositoriesForSecretForAuthenticatedUserResponse(rsp)
}

// CodespacessetRepositoriesForSecretForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacessetRepositoriesForSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacessetRepositoriesForSecretForAuthenticatedUserWithBodyWithResponse(ctx context.Context, secretName SecretName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacessetRepositoriesForSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacessetRepositoriesForSecretForAuthenticatedUserWithBody(ctx, secretName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacessetRepositoriesForSecretForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacessetRepositoriesForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, body CodespacessetRepositoriesForSecretForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacessetRepositoriesForSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacessetRepositoriesForSecretForAuthenticatedUser(ctx, secretName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacessetRepositoriesForSecretForAuthenticatedUserResponse(rsp)
}

// CodespacesremoveRepositoryForSecretForAuthenticatedUserWithResponse request returning *CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesremoveRepositoryForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesremoveRepositoryForSecretForAuthenticatedUser(ctx, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesremoveRepositoryForSecretForAuthenticatedUserResponse(rsp)
}

// CodespacesaddRepositoryForSecretForAuthenticatedUserWithResponse request returning *CodespacesaddRepositoryForSecretForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesaddRepositoryForSecretForAuthenticatedUserWithResponse(ctx context.Context, secretName SecretName, repositoryId int, reqEditors ...RequestEditorFn) (*CodespacesaddRepositoryForSecretForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesaddRepositoryForSecretForAuthenticatedUser(ctx, secretName, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesaddRepositoryForSecretForAuthenticatedUserResponse(rsp)
}

// CodespacesdeleteForAuthenticatedUserWithResponse request returning *CodespacesdeleteForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesdeleteForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesdeleteForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesdeleteForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesdeleteForAuthenticatedUserResponse(rsp)
}

// CodespacesgetForAuthenticatedUserWithResponse request returning *CodespacesgetForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesgetForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesgetForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesgetForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetForAuthenticatedUserResponse(rsp)
}

// CodespacesupdateForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *CodespacesupdateForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesupdateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, codespaceName CodespaceName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CodespacesupdateForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesupdateForAuthenticatedUserWithBody(ctx, codespaceName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesupdateForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) CodespacesupdateForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, body CodespacesupdateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CodespacesupdateForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesupdateForAuthenticatedUser(ctx, codespaceName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesupdateForAuthenticatedUserResponse(rsp)
}

// CodespacesexportForAuthenticatedUserWithResponse request returning *CodespacesexportForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesexportForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesexportForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesexportForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesexportForAuthenticatedUserResponse(rsp)
}

// CodespacesgetExportDetailsForAuthenticatedUserWithResponse request returning *CodespacesgetExportDetailsForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesgetExportDetailsForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, exportId ExportId, reqEditors ...RequestEditorFn) (*CodespacesgetExportDetailsForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesgetExportDetailsForAuthenticatedUser(ctx, codespaceName, exportId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesgetExportDetailsForAuthenticatedUserResponse(rsp)
}

// CodespacescodespaceMachinesForAuthenticatedUserWithResponse request returning *CodespacescodespaceMachinesForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacescodespaceMachinesForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacescodespaceMachinesForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacescodespaceMachinesForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacescodespaceMachinesForAuthenticatedUserResponse(rsp)
}

// CodespacesstartForAuthenticatedUserWithResponse request returning *CodespacesstartForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesstartForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesstartForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesstartForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesstartForAuthenticatedUserResponse(rsp)
}

// CodespacesstopForAuthenticatedUserWithResponse request returning *CodespacesstopForAuthenticatedUserResponse
func (c *ClientWithResponses) CodespacesstopForAuthenticatedUserWithResponse(ctx context.Context, codespaceName CodespaceName, reqEditors ...RequestEditorFn) (*CodespacesstopForAuthenticatedUserResponse, error) {
	rsp, err := c.CodespacesstopForAuthenticatedUser(ctx, codespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCodespacesstopForAuthenticatedUserResponse(rsp)
}

// UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse
func (c *ClientWithResponses) UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse, error) {
	rsp, err := c.UserssetPrimaryEmailVisibilityForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserssetPrimaryEmailVisibilityForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) UserssetPrimaryEmailVisibilityForAuthenticatedUserWithResponse(ctx context.Context, body UserssetPrimaryEmailVisibilityForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse, error) {
	rsp, err := c.UserssetPrimaryEmailVisibilityForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserssetPrimaryEmailVisibilityForAuthenticatedUserResponse(rsp)
}

// UsersdeleteEmailForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *UsersdeleteEmailForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersdeleteEmailForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersdeleteEmailForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersdeleteEmailForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersdeleteEmailForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) UsersdeleteEmailForAuthenticatedUserWithResponse(ctx context.Context, body UsersdeleteEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersdeleteEmailForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersdeleteEmailForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersdeleteEmailForAuthenticatedUserResponse(rsp)
}

// UserslistEmailsForAuthenticatedUserWithResponse request returning *UserslistEmailsForAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistEmailsForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistEmailsForAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistEmailsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistEmailsForAuthenticatedUserResponse(rsp)
}

// UsersaddEmailForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *UsersaddEmailForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersaddEmailForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UsersaddEmailForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersaddEmailForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersaddEmailForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) UsersaddEmailForAuthenticatedUserWithResponse(ctx context.Context, body UsersaddEmailForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UsersaddEmailForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersaddEmailForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersaddEmailForAuthenticatedUserResponse(rsp)
}

// UserslistFollowersForAuthenticatedUserWithResponse request returning *UserslistFollowersForAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistFollowersForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistFollowersForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowersForAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistFollowersForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistFollowersForAuthenticatedUserResponse(rsp)
}

// UserslistFollowedByAuthenticatedUserWithResponse request returning *UserslistFollowedByAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistFollowedByAuthenticatedUserWithResponse(ctx context.Context, params *UserslistFollowedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowedByAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistFollowedByAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistFollowedByAuthenticatedUserResponse(rsp)
}

// UsersunfollowWithResponse request returning *UsersunfollowResponse
func (c *ClientWithResponses) UsersunfollowWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersunfollowResponse, error) {
	rsp, err := c.Usersunfollow(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersunfollowResponse(rsp)
}

// UserscheckPersonIsFollowedByAuthenticatedWithResponse request returning *UserscheckPersonIsFollowedByAuthenticatedResponse
func (c *ClientWithResponses) UserscheckPersonIsFollowedByAuthenticatedWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UserscheckPersonIsFollowedByAuthenticatedResponse, error) {
	rsp, err := c.UserscheckPersonIsFollowedByAuthenticated(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscheckPersonIsFollowedByAuthenticatedResponse(rsp)
}

// UsersfollowWithResponse request returning *UsersfollowResponse
func (c *ClientWithResponses) UsersfollowWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersfollowResponse, error) {
	rsp, err := c.Usersfollow(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersfollowResponse(rsp)
}

// UserslistGpgKeysForAuthenticatedUserWithResponse request returning *UserslistGpgKeysForAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistGpgKeysForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistGpgKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistGpgKeysForAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistGpgKeysForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistGpgKeysForAuthenticatedUserResponse(rsp)
}

// UserscreateGpgKeyForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *UserscreateGpgKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UserscreateGpgKeyForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserscreateGpgKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UserscreateGpgKeyForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscreateGpgKeyForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) UserscreateGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, body UserscreateGpgKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserscreateGpgKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UserscreateGpgKeyForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscreateGpgKeyForAuthenticatedUserResponse(rsp)
}

// UsersdeleteGpgKeyForAuthenticatedUserWithResponse request returning *UsersdeleteGpgKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersdeleteGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*UsersdeleteGpgKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersdeleteGpgKeyForAuthenticatedUser(ctx, gpgKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersdeleteGpgKeyForAuthenticatedUserResponse(rsp)
}

// UsersgetGpgKeyForAuthenticatedUserWithResponse request returning *UsersgetGpgKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersgetGpgKeyForAuthenticatedUserWithResponse(ctx context.Context, gpgKeyId GpgKeyId, reqEditors ...RequestEditorFn) (*UsersgetGpgKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersgetGpgKeyForAuthenticatedUser(ctx, gpgKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersgetGpgKeyForAuthenticatedUserResponse(rsp)
}

// AppslistInstallationsForAuthenticatedUserWithResponse request returning *AppslistInstallationsForAuthenticatedUserResponse
func (c *ClientWithResponses) AppslistInstallationsForAuthenticatedUserWithResponse(ctx context.Context, params *AppslistInstallationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistInstallationsForAuthenticatedUserResponse, error) {
	rsp, err := c.AppslistInstallationsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistInstallationsForAuthenticatedUserResponse(rsp)
}

// AppslistInstallationReposForAuthenticatedUserWithResponse request returning *AppslistInstallationReposForAuthenticatedUserResponse
func (c *ClientWithResponses) AppslistInstallationReposForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, params *AppslistInstallationReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistInstallationReposForAuthenticatedUserResponse, error) {
	rsp, err := c.AppslistInstallationReposForAuthenticatedUser(ctx, installationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistInstallationReposForAuthenticatedUserResponse(rsp)
}

// AppsremoveRepoFromInstallationForAuthenticatedUserWithResponse request returning *AppsremoveRepoFromInstallationForAuthenticatedUserResponse
func (c *ClientWithResponses) AppsremoveRepoFromInstallationForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*AppsremoveRepoFromInstallationForAuthenticatedUserResponse, error) {
	rsp, err := c.AppsremoveRepoFromInstallationForAuthenticatedUser(ctx, installationId, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsremoveRepoFromInstallationForAuthenticatedUserResponse(rsp)
}

// AppsaddRepoToInstallationForAuthenticatedUserWithResponse request returning *AppsaddRepoToInstallationForAuthenticatedUserResponse
func (c *ClientWithResponses) AppsaddRepoToInstallationForAuthenticatedUserWithResponse(ctx context.Context, installationId InstallationId, repositoryId RepositoryId, reqEditors ...RequestEditorFn) (*AppsaddRepoToInstallationForAuthenticatedUserResponse, error) {
	rsp, err := c.AppsaddRepoToInstallationForAuthenticatedUser(ctx, installationId, repositoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsaddRepoToInstallationForAuthenticatedUserResponse(rsp)
}

// InteractionsremoveRestrictionsForAuthenticatedUserWithResponse request returning *InteractionsremoveRestrictionsForAuthenticatedUserResponse
func (c *ClientWithResponses) InteractionsremoveRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InteractionsremoveRestrictionsForAuthenticatedUserResponse, error) {
	rsp, err := c.InteractionsremoveRestrictionsForAuthenticatedUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsremoveRestrictionsForAuthenticatedUserResponse(rsp)
}

// InteractionsgetRestrictionsForAuthenticatedUserWithResponse request returning *InteractionsgetRestrictionsForAuthenticatedUserResponse
func (c *ClientWithResponses) InteractionsgetRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InteractionsgetRestrictionsForAuthenticatedUserResponse, error) {
	rsp, err := c.InteractionsgetRestrictionsForAuthenticatedUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionsgetRestrictionsForAuthenticatedUserResponse(rsp)
}

// InteractionssetRestrictionsForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *InteractionssetRestrictionsForAuthenticatedUserResponse
func (c *ClientWithResponses) InteractionssetRestrictionsForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForAuthenticatedUserResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) InteractionssetRestrictionsForAuthenticatedUserWithResponse(ctx context.Context, body InteractionssetRestrictionsForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*InteractionssetRestrictionsForAuthenticatedUserResponse, error) {
	rsp, err := c.InteractionssetRestrictionsForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInteractionssetRestrictionsForAuthenticatedUserResponse(rsp)
}

// IssueslistForAuthenticatedUserWithResponse request returning *IssueslistForAuthenticatedUserResponse
func (c *ClientWithResponses) IssueslistForAuthenticatedUserWithResponse(ctx context.Context, params *IssueslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*IssueslistForAuthenticatedUserResponse, error) {
	rsp, err := c.IssueslistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssueslistForAuthenticatedUserResponse(rsp)
}

// UserslistPublicSshKeysForAuthenticatedUserWithResponse request returning *UserslistPublicSshKeysForAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistPublicSshKeysForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistPublicSshKeysForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicSshKeysForAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistPublicSshKeysForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistPublicSshKeysForAuthenticatedUserResponse(rsp)
}

// UserscreatePublicSshKeyForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *UserscreatePublicSshKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UserscreatePublicSshKeyForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserscreatePublicSshKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UserscreatePublicSshKeyForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscreatePublicSshKeyForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) UserscreatePublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, body UserscreatePublicSshKeyForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UserscreatePublicSshKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UserscreatePublicSshKeyForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscreatePublicSshKeyForAuthenticatedUserResponse(rsp)
}

// UsersdeletePublicSshKeyForAuthenticatedUserWithResponse request returning *UsersdeletePublicSshKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersdeletePublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*UsersdeletePublicSshKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersdeletePublicSshKeyForAuthenticatedUser(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersdeletePublicSshKeyForAuthenticatedUserResponse(rsp)
}

// UsersgetPublicSshKeyForAuthenticatedUserWithResponse request returning *UsersgetPublicSshKeyForAuthenticatedUserResponse
func (c *ClientWithResponses) UsersgetPublicSshKeyForAuthenticatedUserWithResponse(ctx context.Context, keyId KeyId, reqEditors ...RequestEditorFn) (*UsersgetPublicSshKeyForAuthenticatedUserResponse, error) {
	rsp, err := c.UsersgetPublicSshKeyForAuthenticatedUser(ctx, keyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersgetPublicSshKeyForAuthenticatedUserResponse(rsp)
}

// AppslistSubscriptionsForAuthenticatedUserWithResponse request returning *AppslistSubscriptionsForAuthenticatedUserResponse
func (c *ClientWithResponses) AppslistSubscriptionsForAuthenticatedUserWithResponse(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*AppslistSubscriptionsForAuthenticatedUserResponse, error) {
	rsp, err := c.AppslistSubscriptionsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistSubscriptionsForAuthenticatedUserResponse(rsp)
}

// AppslistSubscriptionsForAuthenticatedUserStubbedWithResponse request returning *AppslistSubscriptionsForAuthenticatedUserStubbedResponse
func (c *ClientWithResponses) AppslistSubscriptionsForAuthenticatedUserStubbedWithResponse(ctx context.Context, params *AppslistSubscriptionsForAuthenticatedUserStubbedParams, reqEditors ...RequestEditorFn) (*AppslistSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	rsp, err := c.AppslistSubscriptionsForAuthenticatedUserStubbed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppslistSubscriptionsForAuthenticatedUserStubbedResponse(rsp)
}

// OrgslistMembershipsForAuthenticatedUserWithResponse request returning *OrgslistMembershipsForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgslistMembershipsForAuthenticatedUserWithResponse(ctx context.Context, params *OrgslistMembershipsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*OrgslistMembershipsForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgslistMembershipsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistMembershipsForAuthenticatedUserResponse(rsp)
}

// OrgsgetMembershipForAuthenticatedUserWithResponse request returning *OrgsgetMembershipForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgsgetMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, reqEditors ...RequestEditorFn) (*OrgsgetMembershipForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgsgetMembershipForAuthenticatedUser(ctx, org, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsgetMembershipForAuthenticatedUserResponse(rsp)
}

// OrgsupdateMembershipForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *OrgsupdateMembershipForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgsupdateMembershipForAuthenticatedUserWithBodyWithResponse(ctx context.Context, org Org, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*OrgsupdateMembershipForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgsupdateMembershipForAuthenticatedUserWithBody(ctx, org, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateMembershipForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) OrgsupdateMembershipForAuthenticatedUserWithResponse(ctx context.Context, org Org, body OrgsupdateMembershipForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*OrgsupdateMembershipForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgsupdateMembershipForAuthenticatedUser(ctx, org, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgsupdateMembershipForAuthenticatedUserResponse(rsp)
}

// MigrationslistForAuthenticatedUserWithResponse request returning *MigrationslistForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationslistForAuthenticatedUserWithResponse(ctx context.Context, params *MigrationslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationslistForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationslistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationslistForAuthenticatedUserResponse(rsp)
}

// MigrationsstartForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *MigrationsstartForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationsstartForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MigrationsstartForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsstartForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) MigrationsstartForAuthenticatedUserWithResponse(ctx context.Context, body MigrationsstartForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*MigrationsstartForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsstartForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsstartForAuthenticatedUserResponse(rsp)
}

// MigrationsgetStatusForAuthenticatedUserWithResponse request returning *MigrationsgetStatusForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationsgetStatusForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, params *MigrationsgetStatusForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationsgetStatusForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsgetStatusForAuthenticatedUser(ctx, migrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetStatusForAuthenticatedUserResponse(rsp)
}

// MigrationsdeleteArchiveForAuthenticatedUserWithResponse request returning *MigrationsdeleteArchiveForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationsdeleteArchiveForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsdeleteArchiveForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsdeleteArchiveForAuthenticatedUser(ctx, migrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsdeleteArchiveForAuthenticatedUserResponse(rsp)
}

// MigrationsgetArchiveForAuthenticatedUserWithResponse request returning *MigrationsgetArchiveForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationsgetArchiveForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, reqEditors ...RequestEditorFn) (*MigrationsgetArchiveForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsgetArchiveForAuthenticatedUser(ctx, migrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsgetArchiveForAuthenticatedUserResponse(rsp)
}

// MigrationsunlockRepoForAuthenticatedUserWithResponse request returning *MigrationsunlockRepoForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationsunlockRepoForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, repoName RepoName, reqEditors ...RequestEditorFn) (*MigrationsunlockRepoForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationsunlockRepoForAuthenticatedUser(ctx, migrationId, repoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationsunlockRepoForAuthenticatedUserResponse(rsp)
}

// MigrationslistReposForAuthenticatedUserWithResponse request returning *MigrationslistReposForAuthenticatedUserResponse
func (c *ClientWithResponses) MigrationslistReposForAuthenticatedUserWithResponse(ctx context.Context, migrationId MigrationId, params *MigrationslistReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*MigrationslistReposForAuthenticatedUserResponse, error) {
	rsp, err := c.MigrationslistReposForAuthenticatedUser(ctx, migrationId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMigrationslistReposForAuthenticatedUserResponse(rsp)
}

// OrgslistForAuthenticatedUserWithResponse request returning *OrgslistForAuthenticatedUserResponse
func (c *ClientWithResponses) OrgslistForAuthenticatedUserWithResponse(ctx context.Context, params *OrgslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*OrgslistForAuthenticatedUserResponse, error) {
	rsp, err := c.OrgslistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistForAuthenticatedUserResponse(rsp)
}

// PackageslistPackagesForAuthenticatedUserWithResponse request returning *PackageslistPackagesForAuthenticatedUserResponse
func (c *ClientWithResponses) PackageslistPackagesForAuthenticatedUserWithResponse(ctx context.Context, params *PackageslistPackagesForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForAuthenticatedUserResponse, error) {
	rsp, err := c.PackageslistPackagesForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackageslistPackagesForAuthenticatedUserResponse(rsp)
}

// PackagesdeletePackageForAuthenticatedUserWithResponse request returning *PackagesdeletePackageForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesdeletePackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesdeletePackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesdeletePackageForAuthenticatedUser(ctx, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageForAuthenticatedUserResponse(rsp)
}

// PackagesgetPackageForAuthenticatedUserWithResponse request returning *PackagesgetPackageForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesgetPackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetPackageForAuthenticatedUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesgetPackageForAuthenticatedUser(ctx, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageForAuthenticatedUserResponse(rsp)
}

// PackagesrestorePackageForAuthenticatedUserWithResponse request returning *PackagesrestorePackageForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesrestorePackageForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesrestorePackageForAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesrestorePackageForAuthenticatedUser(ctx, packageType, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageForAuthenticatedUserResponse(rsp)
}

// PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithResponse request returning *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParamsPackageType, packageName PackageName, params *PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUser(ctx, packageType, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(rsp)
}

// PackagesdeletePackageVersionForAuthenticatedUserWithResponse request returning *PackagesdeletePackageVersionForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesdeletePackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesdeletePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesdeletePackageVersionForAuthenticatedUser(ctx, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageVersionForAuthenticatedUserResponse(rsp)
}

// PackagesgetPackageVersionForAuthenticatedUserWithResponse request returning *PackagesgetPackageVersionForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesgetPackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesgetPackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesgetPackageVersionForAuthenticatedUser(ctx, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageVersionForAuthenticatedUserResponse(rsp)
}

// PackagesrestorePackageVersionForAuthenticatedUserWithResponse request returning *PackagesrestorePackageVersionForAuthenticatedUserResponse
func (c *ClientWithResponses) PackagesrestorePackageVersionForAuthenticatedUserWithResponse(ctx context.Context, packageType PackagesrestorePackageVersionForAuthenticatedUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForAuthenticatedUserResponse, error) {
	rsp, err := c.PackagesrestorePackageVersionForAuthenticatedUser(ctx, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageVersionForAuthenticatedUserResponse(rsp)
}

// ProjectscreateForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *ProjectscreateForAuthenticatedUserResponse
func (c *ClientWithResponses) ProjectscreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ProjectscreateForAuthenticatedUserResponse, error) {
	rsp, err := c.ProjectscreateForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) ProjectscreateForAuthenticatedUserWithResponse(ctx context.Context, body ProjectscreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ProjectscreateForAuthenticatedUserResponse, error) {
	rsp, err := c.ProjectscreateForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectscreateForAuthenticatedUserResponse(rsp)
}

// UserslistPublicEmailsForAuthenticatedUserWithResponse request returning *UserslistPublicEmailsForAuthenticatedUserResponse
func (c *ClientWithResponses) UserslistPublicEmailsForAuthenticatedUserWithResponse(ctx context.Context, params *UserslistPublicEmailsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicEmailsForAuthenticatedUserResponse, error) {
	rsp, err := c.UserslistPublicEmailsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistPublicEmailsForAuthenticatedUserResponse(rsp)
}

// ReposlistForAuthenticatedUserWithResponse request returning *ReposlistForAuthenticatedUserResponse
func (c *ClientWithResponses) ReposlistForAuthenticatedUserWithResponse(ctx context.Context, params *ReposlistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ReposlistForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposlistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistForAuthenticatedUserResponse(rsp)
}

// ReposcreateForAuthenticatedUserWithBodyWithResponse request with arbitrary body returning *ReposcreateForAuthenticatedUserResponse
func (c *ClientWithResponses) ReposcreateForAuthenticatedUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReposcreateForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposcreateForAuthenticatedUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateForAuthenticatedUserResponse(rsp)
}

func (c *ClientWithResponses) ReposcreateForAuthenticatedUserWithResponse(ctx context.Context, body ReposcreateForAuthenticatedUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReposcreateForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposcreateForAuthenticatedUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposcreateForAuthenticatedUserResponse(rsp)
}

// ReposlistInvitationsForAuthenticatedUserWithResponse request returning *ReposlistInvitationsForAuthenticatedUserResponse
func (c *ClientWithResponses) ReposlistInvitationsForAuthenticatedUserWithResponse(ctx context.Context, params *ReposlistInvitationsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ReposlistInvitationsForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposlistInvitationsForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistInvitationsForAuthenticatedUserResponse(rsp)
}

// ReposdeclineInvitationForAuthenticatedUserWithResponse request returning *ReposdeclineInvitationForAuthenticatedUserResponse
func (c *ClientWithResponses) ReposdeclineInvitationForAuthenticatedUserWithResponse(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposdeclineInvitationForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposdeclineInvitationForAuthenticatedUser(ctx, invitationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposdeclineInvitationForAuthenticatedUserResponse(rsp)
}

// ReposacceptInvitationForAuthenticatedUserWithResponse request returning *ReposacceptInvitationForAuthenticatedUserResponse
func (c *ClientWithResponses) ReposacceptInvitationForAuthenticatedUserWithResponse(ctx context.Context, invitationId InvitationId, reqEditors ...RequestEditorFn) (*ReposacceptInvitationForAuthenticatedUserResponse, error) {
	rsp, err := c.ReposacceptInvitationForAuthenticatedUser(ctx, invitationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposacceptInvitationForAuthenticatedUserResponse(rsp)
}

// ActivitylistReposStarredByAuthenticatedUserWithResponse request returning *ActivitylistReposStarredByAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistReposStarredByAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistReposStarredByAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposStarredByAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistReposStarredByAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistReposStarredByAuthenticatedUserResponse(rsp)
}

// ActivityunstarRepoForAuthenticatedUserWithResponse request returning *ActivityunstarRepoForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivityunstarRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivityunstarRepoForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivityunstarRepoForAuthenticatedUser(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivityunstarRepoForAuthenticatedUserResponse(rsp)
}

// ActivitycheckRepoIsStarredByAuthenticatedUserWithResponse request returning *ActivitycheckRepoIsStarredByAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitycheckRepoIsStarredByAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitycheckRepoIsStarredByAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitycheckRepoIsStarredByAuthenticatedUser(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitycheckRepoIsStarredByAuthenticatedUserResponse(rsp)
}

// ActivitystarRepoForAuthenticatedUserWithResponse request returning *ActivitystarRepoForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitystarRepoForAuthenticatedUserWithResponse(ctx context.Context, owner Owner, repo Repo, reqEditors ...RequestEditorFn) (*ActivitystarRepoForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitystarRepoForAuthenticatedUser(ctx, owner, repo, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitystarRepoForAuthenticatedUserResponse(rsp)
}

// ActivitylistWatchedReposForAuthenticatedUserWithResponse request returning *ActivitylistWatchedReposForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistWatchedReposForAuthenticatedUserWithResponse(ctx context.Context, params *ActivitylistWatchedReposForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistWatchedReposForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistWatchedReposForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistWatchedReposForAuthenticatedUserResponse(rsp)
}

// TeamslistForAuthenticatedUserWithResponse request returning *TeamslistForAuthenticatedUserResponse
func (c *ClientWithResponses) TeamslistForAuthenticatedUserWithResponse(ctx context.Context, params *TeamslistForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*TeamslistForAuthenticatedUserResponse, error) {
	rsp, err := c.TeamslistForAuthenticatedUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTeamslistForAuthenticatedUserResponse(rsp)
}

// UserslistWithResponse request returning *UserslistResponse
func (c *ClientWithResponses) UserslistWithResponse(ctx context.Context, params *UserslistParams, reqEditors ...RequestEditorFn) (*UserslistResponse, error) {
	rsp, err := c.Userslist(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistResponse(rsp)
}

// UsersgetByUsernameWithResponse request returning *UsersgetByUsernameResponse
func (c *ClientWithResponses) UsersgetByUsernameWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*UsersgetByUsernameResponse, error) {
	rsp, err := c.UsersgetByUsername(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersgetByUsernameResponse(rsp)
}

// ActivitylistEventsForAuthenticatedUserWithResponse request returning *ActivitylistEventsForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistEventsForAuthenticatedUserWithResponse(ctx context.Context, username Username, params *ActivitylistEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistEventsForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistEventsForAuthenticatedUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistEventsForAuthenticatedUserResponse(rsp)
}

// ActivitylistOrgEventsForAuthenticatedUserWithResponse request returning *ActivitylistOrgEventsForAuthenticatedUserResponse
func (c *ClientWithResponses) ActivitylistOrgEventsForAuthenticatedUserWithResponse(ctx context.Context, username Username, org Org, params *ActivitylistOrgEventsForAuthenticatedUserParams, reqEditors ...RequestEditorFn) (*ActivitylistOrgEventsForAuthenticatedUserResponse, error) {
	rsp, err := c.ActivitylistOrgEventsForAuthenticatedUser(ctx, username, org, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistOrgEventsForAuthenticatedUserResponse(rsp)
}

// ActivitylistPublicEventsForUserWithResponse request returning *ActivitylistPublicEventsForUserResponse
func (c *ClientWithResponses) ActivitylistPublicEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistPublicEventsForUserResponse, error) {
	rsp, err := c.ActivitylistPublicEventsForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistPublicEventsForUserResponse(rsp)
}

// UserslistFollowersForUserWithResponse request returning *UserslistFollowersForUserResponse
func (c *ClientWithResponses) UserslistFollowersForUserWithResponse(ctx context.Context, username Username, params *UserslistFollowersForUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowersForUserResponse, error) {
	rsp, err := c.UserslistFollowersForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistFollowersForUserResponse(rsp)
}

// UserslistFollowingForUserWithResponse request returning *UserslistFollowingForUserResponse
func (c *ClientWithResponses) UserslistFollowingForUserWithResponse(ctx context.Context, username Username, params *UserslistFollowingForUserParams, reqEditors ...RequestEditorFn) (*UserslistFollowingForUserResponse, error) {
	rsp, err := c.UserslistFollowingForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistFollowingForUserResponse(rsp)
}

// UserscheckFollowingForUserWithResponse request returning *UserscheckFollowingForUserResponse
func (c *ClientWithResponses) UserscheckFollowingForUserWithResponse(ctx context.Context, username Username, targetUser string, reqEditors ...RequestEditorFn) (*UserscheckFollowingForUserResponse, error) {
	rsp, err := c.UserscheckFollowingForUser(ctx, username, targetUser, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserscheckFollowingForUserResponse(rsp)
}

// GistslistForUserWithResponse request returning *GistslistForUserResponse
func (c *ClientWithResponses) GistslistForUserWithResponse(ctx context.Context, username Username, params *GistslistForUserParams, reqEditors ...RequestEditorFn) (*GistslistForUserResponse, error) {
	rsp, err := c.GistslistForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGistslistForUserResponse(rsp)
}

// UserslistGpgKeysForUserWithResponse request returning *UserslistGpgKeysForUserResponse
func (c *ClientWithResponses) UserslistGpgKeysForUserWithResponse(ctx context.Context, username Username, params *UserslistGpgKeysForUserParams, reqEditors ...RequestEditorFn) (*UserslistGpgKeysForUserResponse, error) {
	rsp, err := c.UserslistGpgKeysForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistGpgKeysForUserResponse(rsp)
}

// UsersgetContextForUserWithResponse request returning *UsersgetContextForUserResponse
func (c *ClientWithResponses) UsersgetContextForUserWithResponse(ctx context.Context, username Username, params *UsersgetContextForUserParams, reqEditors ...RequestEditorFn) (*UsersgetContextForUserResponse, error) {
	rsp, err := c.UsersgetContextForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersgetContextForUserResponse(rsp)
}

// AppsgetUserInstallationWithResponse request returning *AppsgetUserInstallationResponse
func (c *ClientWithResponses) AppsgetUserInstallationWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*AppsgetUserInstallationResponse, error) {
	rsp, err := c.AppsgetUserInstallation(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAppsgetUserInstallationResponse(rsp)
}

// UserslistPublicKeysForUserWithResponse request returning *UserslistPublicKeysForUserResponse
func (c *ClientWithResponses) UserslistPublicKeysForUserWithResponse(ctx context.Context, username Username, params *UserslistPublicKeysForUserParams, reqEditors ...RequestEditorFn) (*UserslistPublicKeysForUserResponse, error) {
	rsp, err := c.UserslistPublicKeysForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserslistPublicKeysForUserResponse(rsp)
}

// OrgslistForUserWithResponse request returning *OrgslistForUserResponse
func (c *ClientWithResponses) OrgslistForUserWithResponse(ctx context.Context, username Username, params *OrgslistForUserParams, reqEditors ...RequestEditorFn) (*OrgslistForUserResponse, error) {
	rsp, err := c.OrgslistForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseOrgslistForUserResponse(rsp)
}

// PackageslistPackagesForUserWithResponse request returning *PackageslistPackagesForUserResponse
func (c *ClientWithResponses) PackageslistPackagesForUserWithResponse(ctx context.Context, username Username, params *PackageslistPackagesForUserParams, reqEditors ...RequestEditorFn) (*PackageslistPackagesForUserResponse, error) {
	rsp, err := c.PackageslistPackagesForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackageslistPackagesForUserResponse(rsp)
}

// PackagesdeletePackageForUserWithResponse request returning *PackagesdeletePackageForUserResponse
func (c *ClientWithResponses) PackagesdeletePackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesdeletePackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesdeletePackageForUserResponse, error) {
	rsp, err := c.PackagesdeletePackageForUser(ctx, username, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageForUserResponse(rsp)
}

// PackagesgetPackageForUserWithResponse request returning *PackagesgetPackageForUserResponse
func (c *ClientWithResponses) PackagesgetPackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesgetPackageForUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetPackageForUserResponse, error) {
	rsp, err := c.PackagesgetPackageForUser(ctx, username, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageForUserResponse(rsp)
}

// PackagesrestorePackageForUserWithResponse request returning *PackagesrestorePackageForUserResponse
func (c *ClientWithResponses) PackagesrestorePackageForUserWithResponse(ctx context.Context, username Username, packageType PackagesrestorePackageForUserParamsPackageType, packageName PackageName, params *PackagesrestorePackageForUserParams, reqEditors ...RequestEditorFn) (*PackagesrestorePackageForUserResponse, error) {
	rsp, err := c.PackagesrestorePackageForUser(ctx, username, packageType, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageForUserResponse(rsp)
}

// PackagesgetAllPackageVersionsForPackageOwnedByUserWithResponse request returning *PackagesgetAllPackageVersionsForPackageOwnedByUserResponse
func (c *ClientWithResponses) PackagesgetAllPackageVersionsForPackageOwnedByUserWithResponse(ctx context.Context, username Username, packageType PackagesgetAllPackageVersionsForPackageOwnedByUserParamsPackageType, packageName PackageName, reqEditors ...RequestEditorFn) (*PackagesgetAllPackageVersionsForPackageOwnedByUserResponse, error) {
	rsp, err := c.PackagesgetAllPackageVersionsForPackageOwnedByUser(ctx, username, packageType, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetAllPackageVersionsForPackageOwnedByUserResponse(rsp)
}

// PackagesdeletePackageVersionForUserWithResponse request returning *PackagesdeletePackageVersionForUserResponse
func (c *ClientWithResponses) PackagesdeletePackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesdeletePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesdeletePackageVersionForUserResponse, error) {
	rsp, err := c.PackagesdeletePackageVersionForUser(ctx, username, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesdeletePackageVersionForUserResponse(rsp)
}

// PackagesgetPackageVersionForUserWithResponse request returning *PackagesgetPackageVersionForUserResponse
func (c *ClientWithResponses) PackagesgetPackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesgetPackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesgetPackageVersionForUserResponse, error) {
	rsp, err := c.PackagesgetPackageVersionForUser(ctx, username, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesgetPackageVersionForUserResponse(rsp)
}

// PackagesrestorePackageVersionForUserWithResponse request returning *PackagesrestorePackageVersionForUserResponse
func (c *ClientWithResponses) PackagesrestorePackageVersionForUserWithResponse(ctx context.Context, username Username, packageType PackagesrestorePackageVersionForUserParamsPackageType, packageName PackageName, packageVersionId PackageVersionId, reqEditors ...RequestEditorFn) (*PackagesrestorePackageVersionForUserResponse, error) {
	rsp, err := c.PackagesrestorePackageVersionForUser(ctx, username, packageType, packageName, packageVersionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePackagesrestorePackageVersionForUserResponse(rsp)
}

// ProjectslistForUserWithResponse request returning *ProjectslistForUserResponse
func (c *ClientWithResponses) ProjectslistForUserWithResponse(ctx context.Context, username Username, params *ProjectslistForUserParams, reqEditors ...RequestEditorFn) (*ProjectslistForUserResponse, error) {
	rsp, err := c.ProjectslistForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectslistForUserResponse(rsp)
}

// ActivitylistReceivedEventsForUserWithResponse request returning *ActivitylistReceivedEventsForUserResponse
func (c *ClientWithResponses) ActivitylistReceivedEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistReceivedEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReceivedEventsForUserResponse, error) {
	rsp, err := c.ActivitylistReceivedEventsForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistReceivedEventsForUserResponse(rsp)
}

// ActivitylistReceivedPublicEventsForUserWithResponse request returning *ActivitylistReceivedPublicEventsForUserResponse
func (c *ClientWithResponses) ActivitylistReceivedPublicEventsForUserWithResponse(ctx context.Context, username Username, params *ActivitylistReceivedPublicEventsForUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReceivedPublicEventsForUserResponse, error) {
	rsp, err := c.ActivitylistReceivedPublicEventsForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistReceivedPublicEventsForUserResponse(rsp)
}

// ReposlistForUserWithResponse request returning *ReposlistForUserResponse
func (c *ClientWithResponses) ReposlistForUserWithResponse(ctx context.Context, username Username, params *ReposlistForUserParams, reqEditors ...RequestEditorFn) (*ReposlistForUserResponse, error) {
	rsp, err := c.ReposlistForUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReposlistForUserResponse(rsp)
}

// BillinggetGithubActionsBillingUserWithResponse request returning *BillinggetGithubActionsBillingUserResponse
func (c *ClientWithResponses) BillinggetGithubActionsBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetGithubActionsBillingUserResponse, error) {
	rsp, err := c.BillinggetGithubActionsBillingUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubActionsBillingUserResponse(rsp)
}

// BillinggetGithubPackagesBillingUserWithResponse request returning *BillinggetGithubPackagesBillingUserResponse
func (c *ClientWithResponses) BillinggetGithubPackagesBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetGithubPackagesBillingUserResponse, error) {
	rsp, err := c.BillinggetGithubPackagesBillingUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetGithubPackagesBillingUserResponse(rsp)
}

// BillinggetSharedStorageBillingUserWithResponse request returning *BillinggetSharedStorageBillingUserResponse
func (c *ClientWithResponses) BillinggetSharedStorageBillingUserWithResponse(ctx context.Context, username Username, reqEditors ...RequestEditorFn) (*BillinggetSharedStorageBillingUserResponse, error) {
	rsp, err := c.BillinggetSharedStorageBillingUser(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBillinggetSharedStorageBillingUserResponse(rsp)
}

// ActivitylistReposStarredByUserWithResponse request returning *ActivitylistReposStarredByUserResponse
func (c *ClientWithResponses) ActivitylistReposStarredByUserWithResponse(ctx context.Context, username Username, params *ActivitylistReposStarredByUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposStarredByUserResponse, error) {
	rsp, err := c.ActivitylistReposStarredByUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistReposStarredByUserResponse(rsp)
}

// ActivitylistReposWatchedByUserWithResponse request returning *ActivitylistReposWatchedByUserResponse
func (c *ClientWithResponses) ActivitylistReposWatchedByUserWithResponse(ctx context.Context, username Username, params *ActivitylistReposWatchedByUserParams, reqEditors ...RequestEditorFn) (*ActivitylistReposWatchedByUserResponse, error) {
	rsp, err := c.ActivitylistReposWatchedByUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseActivitylistReposWatchedByUserResponse(rsp)
}

// MetagetZenWithResponse request returning *MetagetZenResponse
func (c *ClientWithResponses) MetagetZenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*MetagetZenResponse, error) {
	rsp, err := c.MetagetZen(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMetagetZenResponse(rsp)
}

// ParseMetarootResponse parses an HTTP response from a MetarootWithResponse call
func ParseMetarootResponse(rsp *http.Response) (*MetarootResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetarootResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AuthorizationsUrl                string  `json:"authorizations_url"`
			CodeSearchUrl                    string  `json:"code_search_url"`
			CommitSearchUrl                  string  `json:"commit_search_url"`
			CurrentUserAuthorizationsHtmlUrl string  `json:"current_user_authorizations_html_url"`
			CurrentUserRepositoriesUrl       string  `json:"current_user_repositories_url"`
			CurrentUserUrl                   string  `json:"current_user_url"`
			EmailsUrl                        string  `json:"emails_url"`
			EmojisUrl                        string  `json:"emojis_url"`
			EventsUrl                        string  `json:"events_url"`
			FeedsUrl                         string  `json:"feeds_url"`
			FollowersUrl                     string  `json:"followers_url"`
			FollowingUrl                     string  `json:"following_url"`
			GistsUrl                         string  `json:"gists_url"`
			HubUrl                           string  `json:"hub_url"`
			IssueSearchUrl                   string  `json:"issue_search_url"`
			IssuesUrl                        string  `json:"issues_url"`
			KeysUrl                          string  `json:"keys_url"`
			LabelSearchUrl                   string  `json:"label_search_url"`
			NotificationsUrl                 string  `json:"notifications_url"`
			OrganizationRepositoriesUrl      string  `json:"organization_repositories_url"`
			OrganizationTeamsUrl             string  `json:"organization_teams_url"`
			OrganizationUrl                  string  `json:"organization_url"`
			PublicGistsUrl                   string  `json:"public_gists_url"`
			RateLimitUrl                     string  `json:"rate_limit_url"`
			RepositorySearchUrl              string  `json:"repository_search_url"`
			RepositoryUrl                    string  `json:"repository_url"`
			StarredGistsUrl                  string  `json:"starred_gists_url"`
			StarredUrl                       string  `json:"starred_url"`
			TopicSearchUrl                   *string `json:"topic_search_url,omitempty"`
			UserOrganizationsUrl             string  `json:"user_organizations_url"`
			UserRepositoriesUrl              string  `json:"user_repositories_url"`
			UserSearchUrl                    string  `json:"user_search_url"`
			UserUrl                          string  `json:"user_url"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppsgetAuthenticatedResponse parses an HTTP response from a AppsgetAuthenticatedWithResponse call
func ParseAppsgetAuthenticatedResponse(rsp *http.Response) (*AppsgetAuthenticatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetAuthenticatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppscreateFromManifestResponse parses an HTTP response from a AppscreateFromManifestWithResponse call
func ParseAppscreateFromManifestResponse(rsp *http.Response) (*AppscreateFromManifestResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppscreateFromManifestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Embedded struct due to allOf(#/components/schemas/integration)
			Integration `yaml:",inline"`
			// Embedded fields due to inline allOf schema
			ClientId             string                 `json:"client_id"`
			ClientSecret         string                 `json:"client_secret"`
			Pem                  string                 `json:"pem"`
			WebhookSecret        *string                `json:"webhook_secret"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsgetWebhookConfigForAppResponse parses an HTTP response from a AppsgetWebhookConfigForAppWithResponse call
func ParseAppsgetWebhookConfigForAppResponse(rsp *http.Response) (*AppsgetWebhookConfigForAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetWebhookConfigForAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppsupdateWebhookConfigForAppResponse parses an HTTP response from a AppsupdateWebhookConfigForAppWithResponse call
func ParseAppsupdateWebhookConfigForAppResponse(rsp *http.Response) (*AppsupdateWebhookConfigForAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsupdateWebhookConfigForAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppslistWebhookDeliveriesResponse parses an HTTP response from a AppslistWebhookDeliveriesWithResponse call
func ParseAppslistWebhookDeliveriesResponse(rsp *http.Response) (*AppslistWebhookDeliveriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistWebhookDeliveriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HookDeliveryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseAppsgetWebhookDeliveryResponse parses an HTTP response from a AppsgetWebhookDeliveryWithResponse call
func ParseAppsgetWebhookDeliveryResponse(rsp *http.Response) (*AppsgetWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookDelivery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseAppsredeliverWebhookDeliveryResponse parses an HTTP response from a AppsredeliverWebhookDeliveryWithResponse call
func ParseAppsredeliverWebhookDeliveryResponse(rsp *http.Response) (*AppsredeliverWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsredeliverWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseAppslistInstallationsResponse parses an HTTP response from a AppslistInstallationsWithResponse call
func ParseAppslistInstallationsResponse(rsp *http.Response) (*AppslistInstallationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistInstallationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppsdeleteInstallationResponse parses an HTTP response from a AppsdeleteInstallationWithResponse call
func ParseAppsdeleteInstallationResponse(rsp *http.Response) (*AppsdeleteInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsdeleteInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsgetInstallationResponse parses an HTTP response from a AppsgetInstallationWithResponse call
func ParseAppsgetInstallationResponse(rsp *http.Response) (*AppsgetInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppscreateInstallationAccessTokenResponse parses an HTTP response from a AppscreateInstallationAccessTokenWithResponse call
func ParseAppscreateInstallationAccessTokenResponse(rsp *http.Response) (*AppscreateInstallationAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppscreateInstallationAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest InstallationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsunsuspendInstallationResponse parses an HTTP response from a AppsunsuspendInstallationWithResponse call
func ParseAppsunsuspendInstallationResponse(rsp *http.Response) (*AppsunsuspendInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsunsuspendInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppssuspendInstallationResponse parses an HTTP response from a AppssuspendInstallationWithResponse call
func ParseAppssuspendInstallationResponse(rsp *http.Response) (*AppssuspendInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppssuspendInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationslistGrantsResponse parses an HTTP response from a OauthAuthorizationslistGrantsWithResponse call
func ParseOauthAuthorizationslistGrantsResponse(rsp *http.Response) (*OauthAuthorizationslistGrantsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationslistGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApplicationGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsdeleteGrantResponse parses an HTTP response from a OauthAuthorizationsdeleteGrantWithResponse call
func ParseOauthAuthorizationsdeleteGrantResponse(rsp *http.Response) (*OauthAuthorizationsdeleteGrantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsdeleteGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsgetGrantResponse parses an HTTP response from a OauthAuthorizationsgetGrantWithResponse call
func ParseOauthAuthorizationsgetGrantResponse(rsp *http.Response) (*OauthAuthorizationsgetGrantResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsgetGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationGrant
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppsdeleteAuthorizationResponse parses an HTTP response from a AppsdeleteAuthorizationWithResponse call
func ParseAppsdeleteAuthorizationResponse(rsp *http.Response) (*AppsdeleteAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsdeleteAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsdeleteTokenResponse parses an HTTP response from a AppsdeleteTokenWithResponse call
func ParseAppsdeleteTokenResponse(rsp *http.Response) (*AppsdeleteTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsdeleteTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsresetTokenResponse parses an HTTP response from a AppsresetTokenWithResponse call
func ParseAppsresetTokenResponse(rsp *http.Response) (*AppsresetTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsresetTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppscheckTokenResponse parses an HTTP response from a AppscheckTokenWithResponse call
func ParseAppscheckTokenResponse(rsp *http.Response) (*AppscheckTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppscheckTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsscopeTokenResponse parses an HTTP response from a AppsscopeTokenWithResponse call
func ParseAppsscopeTokenResponse(rsp *http.Response) (*AppsscopeTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsscopeTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsgetBySlugResponse parses an HTTP response from a AppsgetBySlugWithResponse call
func ParseAppsgetBySlugResponse(rsp *http.Response) (*AppsgetBySlugResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetBySlugResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationslistAuthorizationsResponse parses an HTTP response from a OauthAuthorizationslistAuthorizationsWithResponse call
func ParseOauthAuthorizationslistAuthorizationsResponse(rsp *http.Response) (*OauthAuthorizationslistAuthorizationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationslistAuthorizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationscreateAuthorizationResponse parses an HTTP response from a OauthAuthorizationscreateAuthorizationWithResponse call
func ParseOauthAuthorizationscreateAuthorizationResponse(rsp *http.Response) (*OauthAuthorizationscreateAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationscreateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsgetOrCreateAuthorizationForAppResponse parses an HTTP response from a OauthAuthorizationsgetOrCreateAuthorizationForAppWithResponse call
func ParseOauthAuthorizationsgetOrCreateAuthorizationForAppResponse(rsp *http.Response) (*OauthAuthorizationsgetOrCreateAuthorizationForAppResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsgetOrCreateAuthorizationForAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse parses an HTTP response from a OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintWithResponse call
func ParseOauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse(rsp *http.Response) (*OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsgetOrCreateAuthorizationForAppAndFingerprintResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsdeleteAuthorizationResponse parses an HTTP response from a OauthAuthorizationsdeleteAuthorizationWithResponse call
func ParseOauthAuthorizationsdeleteAuthorizationResponse(rsp *http.Response) (*OauthAuthorizationsdeleteAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsdeleteAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsgetAuthorizationResponse parses an HTTP response from a OauthAuthorizationsgetAuthorizationWithResponse call
func ParseOauthAuthorizationsgetAuthorizationResponse(rsp *http.Response) (*OauthAuthorizationsgetAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsgetAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseOauthAuthorizationsupdateAuthorizationResponse parses an HTTP response from a OauthAuthorizationsupdateAuthorizationWithResponse call
func ParseOauthAuthorizationsupdateAuthorizationResponse(rsp *http.Response) (*OauthAuthorizationsupdateAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OauthAuthorizationsupdateAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Authorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCodesOfConductgetAllCodesOfConductResponse parses an HTTP response from a CodesOfConductgetAllCodesOfConductWithResponse call
func ParseCodesOfConductgetAllCodesOfConductResponse(rsp *http.Response) (*CodesOfConductgetAllCodesOfConductResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodesOfConductgetAllCodesOfConductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeOfConduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodesOfConductgetConductCodeResponse parses an HTTP response from a CodesOfConductgetConductCodeWithResponse call
func ParseCodesOfConductgetConductCodeResponse(rsp *http.Response) (*CodesOfConductgetConductCodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodesOfConductgetConductCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeOfConduct
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEmojisgetResponse parses an HTTP response from a EmojisgetWithResponse call
func ParseEmojisgetResponse(rsp *http.Response) (*EmojisgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmojisgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AdditionalProperties map[string]string `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmingetServerStatisticsResponse parses an HTTP response from a EnterpriseAdmingetServerStatisticsWithResponse call
func ParseEnterpriseAdmingetServerStatisticsResponse(rsp *http.Response) (*EnterpriseAdmingetServerStatisticsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetServerStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetActionsCacheUsageForEnterpriseResponse parses an HTTP response from a ActionsgetActionsCacheUsageForEnterpriseWithResponse call
func ParseActionsgetActionsCacheUsageForEnterpriseResponse(rsp *http.Response) (*ActionsgetActionsCacheUsageForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetActionsCacheUsageForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsCacheUsageOrgEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse parses an HTTP response from a EnterpriseAdmingetGithubActionsPermissionsEnterpriseWithResponse call
func ParseEnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetGithubActionsPermissionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsEnterprisePermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetGithubActionsPermissionsEnterpriseWithResponse call
func ParseEnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetGithubActionsPermissionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse call
func ParseEnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistSelectedOrganizationsEnabledGithubActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Organizations []OrganizationSimple `json:"organizations"`
			TotalCount    float32              `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseWithResponse call
func ParseEnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseWithResponse call
func ParseEnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmindisableSelectedOrganizationGithubActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseWithResponse call
func ParseEnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminenableSelectedOrganizationGithubActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmingetAllowedActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdmingetAllowedActionsEnterpriseWithResponse call
func ParseEnterpriseAdmingetAllowedActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmingetAllowedActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetAllowedActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelectedActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetAllowedActionsEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetAllowedActionsEnterpriseWithResponse call
func ParseEnterpriseAdminsetAllowedActionsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetAllowedActionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetAllowedActionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse parses an HTTP response from a ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse call
func ParseActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse(rsp *http.Response) (*ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsGetDefaultWorkflowPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse parses an HTTP response from a ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseWithResponse call
func ParseActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse(rsp *http.Response) (*ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseWithResponse call
func ParseEnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistSelfHostedRunnerGroupsForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			RunnerGroups []RunnerGroupsEnterprise `json:"runner_groups"`
			TotalCount   float32                  `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseWithResponse call
func ParseEnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmincreateSelfHostedRunnerGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RunnerGroupsEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse parses an HTTP response from a EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseWithResponse call
func ParseEnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmindeleteSelfHostedRunnerGroupFromEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseWithResponse call
func ParseEnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetSelfHostedRunnerGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunnerGroupsEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseWithResponse call
func ParseEnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminupdateSelfHostedRunnerGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunnerGroupsEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse call
func ParseEnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Organizations []OrganizationSimple `json:"organizations"`
			TotalCount    float32              `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse call
func ParseEnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse parses an HTTP response from a EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse call
func ParseEnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminremoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse parses an HTTP response from a EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseWithResponse call
func ParseEnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminaddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseWithResponse call
func ParseEnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistSelfHostedRunnersInGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Runners    []Runner `json:"runners"`
			TotalCount float32  `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseWithResponse call
func ParseEnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetSelfHostedRunnersInGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseWithResponse call
func ParseEnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminremoveSelfHostedRunnerFromGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse parses an HTTP response from a EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseWithResponse call
func ParseEnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminaddSelfHostedRunnerToGroupForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistSelfHostedRunnersForEnterpriseWithResponse call
func ParseEnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistSelfHostedRunnersForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Runners    *[]Runner `json:"runners,omitempty"`
			TotalCount *float32  `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminlistRunnerApplicationsForEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistRunnerApplicationsForEnterpriseWithResponse call
func ParseEnterpriseAdminlistRunnerApplicationsForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistRunnerApplicationsForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RunnerApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmincreateRegistrationTokenForEnterpriseResponse parses an HTTP response from a EnterpriseAdmincreateRegistrationTokenForEnterpriseWithResponse call
func ParseEnterpriseAdmincreateRegistrationTokenForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmincreateRegistrationTokenForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmincreateRemoveTokenForEnterpriseResponse parses an HTTP response from a EnterpriseAdmincreateRemoveTokenForEnterpriseWithResponse call
func ParseEnterpriseAdmincreateRemoveTokenForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmincreateRemoveTokenForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmincreateRemoveTokenForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse parses an HTTP response from a EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseWithResponse call
func ParseEnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmindeleteSelfHostedRunnerFromEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdmingetSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Runner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminremoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistLabelsForSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminaddCustomLabelsToSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetCustomLabelsForSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse parses an HTTP response from a EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseWithResponse call
func ParseEnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminremoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmingetAuditLogResponse parses an HTTP response from a EnterpriseAdmingetAuditLogWithResponse call
func ParseEnterpriseAdmingetAuditLogResponse(rsp *http.Response) (*EnterpriseAdmingetAuditLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLogEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSecretScanninglistAlertsForEnterpriseResponse parses an HTTP response from a SecretScanninglistAlertsForEnterpriseWithResponse call
func ParseSecretScanninglistAlertsForEnterpriseResponse(rsp *http.Response) (*SecretScanninglistAlertsForEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanninglistAlertsForEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationSecretScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubActionsBillingGheResponse parses an HTTP response from a BillinggetGithubActionsBillingGheWithResponse call
func ParseBillinggetGithubActionsBillingGheResponse(rsp *http.Response) (*BillinggetGithubActionsBillingGheResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubActionsBillingGheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubAdvancedSecurityBillingGheResponse parses an HTTP response from a BillinggetGithubAdvancedSecurityBillingGheWithResponse call
func ParseBillinggetGithubAdvancedSecurityBillingGheResponse(rsp *http.Response) (*BillinggetGithubAdvancedSecurityBillingGheResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubAdvancedSecurityBillingGheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdvancedSecurityActiveCommitters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubPackagesBillingGheResponse parses an HTTP response from a BillinggetGithubPackagesBillingGheWithResponse call
func ParseBillinggetGithubPackagesBillingGheResponse(rsp *http.Response) (*BillinggetGithubPackagesBillingGheResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubPackagesBillingGheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackagesBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetSharedStorageBillingGheResponse parses an HTTP response from a BillinggetSharedStorageBillingGheWithResponse call
func ParseBillinggetSharedStorageBillingGheResponse(rsp *http.Response) (*BillinggetSharedStorageBillingGheResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetSharedStorageBillingGheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CombinedBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistPublicEventsResponse parses an HTTP response from a ActivitylistPublicEventsWithResponse call
func ParseActivitylistPublicEventsResponse(rsp *http.Response) (*ActivitylistPublicEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistPublicEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseActivitygetFeedsResponse parses an HTTP response from a ActivitygetFeedsWithResponse call
func ParseActivitygetFeedsResponse(rsp *http.Response) (*ActivitygetFeedsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitygetFeedsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Feed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGistslistResponse parses an HTTP response from a GistslistWithResponse call
func ParseGistslistResponse(rsp *http.Response) (*GistslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseGist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGistscreateResponse parses an HTTP response from a GistscreateWithResponse call
func ParseGistscreateResponse(rsp *http.Response) (*GistscreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistscreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GistSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGistslistPublicResponse parses an HTTP response from a GistslistPublicWithResponse call
func ParseGistslistPublicResponse(rsp *http.Response) (*GistslistPublicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistPublicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseGist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGistslistStarredResponse parses an HTTP response from a GistslistStarredWithResponse call
func ParseGistslistStarredResponse(rsp *http.Response) (*GistslistStarredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistStarredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseGist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGistsdeleteResponse parses an HTTP response from a GistsdeleteWithResponse call
func ParseGistsdeleteResponse(rsp *http.Response) (*GistsdeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsdeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsgetResponse parses an HTTP response from a GistsgetWithResponse call
func ParseGistsgetResponse(rsp *http.Response) (*GistsgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GistSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Block *struct {
				CreatedAt *string `json:"created_at,omitempty"`
				HtmlUrl   *string `json:"html_url"`
				Reason    *string `json:"reason,omitempty"`
			} `json:"block,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsupdateResponse parses an HTTP response from a GistsupdateWithResponse call
func ParseGistsupdateResponse(rsp *http.Response) (*GistsupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GistSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGistslistCommentsResponse parses an HTTP response from a GistslistCommentsWithResponse call
func ParseGistslistCommentsResponse(rsp *http.Response) (*GistslistCommentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GistComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistscreateCommentResponse parses an HTTP response from a GistscreateCommentWithResponse call
func ParseGistscreateCommentResponse(rsp *http.Response) (*GistscreateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistscreateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GistComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsdeleteCommentResponse parses an HTTP response from a GistsdeleteCommentWithResponse call
func ParseGistsdeleteCommentResponse(rsp *http.Response) (*GistsdeleteCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsdeleteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsgetCommentResponse parses an HTTP response from a GistsgetCommentWithResponse call
func ParseGistsgetCommentResponse(rsp *http.Response) (*GistsgetCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsgetCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GistComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Block *struct {
				CreatedAt *string `json:"created_at,omitempty"`
				HtmlUrl   *string `json:"html_url"`
				Reason    *string `json:"reason,omitempty"`
			} `json:"block,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsupdateCommentResponse parses an HTTP response from a GistsupdateCommentWithResponse call
func ParseGistsupdateCommentResponse(rsp *http.Response) (*GistsupdateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsupdateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GistComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistslistCommitsResponse parses an HTTP response from a GistslistCommitsWithResponse call
func ParseGistslistCommitsResponse(rsp *http.Response) (*GistslistCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GistCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistslistForksResponse parses an HTTP response from a GistslistForksWithResponse call
func ParseGistslistForksResponse(rsp *http.Response) (*GistslistForksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistForksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GistSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsforkResponse parses an HTTP response from a GistsforkWithResponse call
func ParseGistsforkResponse(rsp *http.Response) (*GistsforkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsforkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BaseGist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGistsunstarResponse parses an HTTP response from a GistsunstarWithResponse call
func ParseGistsunstarResponse(rsp *http.Response) (*GistsunstarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsunstarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistscheckIsStarredResponse parses an HTTP response from a GistscheckIsStarredWithResponse call
func ParseGistscheckIsStarredResponse(rsp *http.Response) (*GistscheckIsStarredResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistscheckIsStarredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsstarResponse parses an HTTP response from a GistsstarWithResponse call
func ParseGistsstarResponse(rsp *http.Response) (*GistsstarResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsstarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGistsgetRevisionResponse parses an HTTP response from a GistsgetRevisionWithResponse call
func ParseGistsgetRevisionResponse(rsp *http.Response) (*GistsgetRevisionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistsgetRevisionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GistSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitignoregetAllTemplatesResponse parses an HTTP response from a GitignoregetAllTemplatesWithResponse call
func ParseGitignoregetAllTemplatesResponse(rsp *http.Response) (*GitignoregetAllTemplatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitignoregetAllTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGitignoregetTemplateResponse parses an HTTP response from a GitignoregetTemplateWithResponse call
func ParseGitignoregetTemplateResponse(rsp *http.Response) (*GitignoregetTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitignoregetTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitignoreTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAppslistReposAccessibleToInstallationResponse parses an HTTP response from a AppslistReposAccessibleToInstallationWithResponse call
func ParseAppslistReposAccessibleToInstallationResponse(rsp *http.Response) (*AppslistReposAccessibleToInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistReposAccessibleToInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories        []Repository `json:"repositories"`
			RepositorySelection *string      `json:"repository_selection,omitempty"`
			TotalCount          int          `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppsrevokeInstallationAccessTokenResponse parses an HTTP response from a AppsrevokeInstallationAccessTokenWithResponse call
func ParseAppsrevokeInstallationAccessTokenResponse(rsp *http.Response) (*AppsrevokeInstallationAccessTokenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsrevokeInstallationAccessTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueslistResponse parses an HTTP response from a IssueslistWithResponse call
func ParseIssueslistResponse(rsp *http.Response) (*IssueslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseLicensesgetAllCommonlyUsedResponse parses an HTTP response from a LicensesgetAllCommonlyUsedWithResponse call
func ParseLicensesgetAllCommonlyUsedResponse(rsp *http.Response) (*LicensesgetAllCommonlyUsedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LicensesgetAllCommonlyUsedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LicenseSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLicensesgetResponse parses an HTTP response from a LicensesgetWithResponse call
func ParseLicensesgetResponse(rsp *http.Response) (*LicensesgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LicensesgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest License
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMarkdownrenderResponse parses an HTTP response from a MarkdownrenderWithResponse call
func ParseMarkdownrenderResponse(rsp *http.Response) (*MarkdownrenderResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkdownrenderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMarkdownrenderRawResponse parses an HTTP response from a MarkdownrenderRawWithResponse call
func ParseMarkdownrenderRawResponse(rsp *http.Response) (*MarkdownrenderRawResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MarkdownrenderRawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAppsgetSubscriptionPlanForAccountResponse parses an HTTP response from a AppsgetSubscriptionPlanForAccountWithResponse call
func ParseAppsgetSubscriptionPlanForAccountResponse(rsp *http.Response) (*AppsgetSubscriptionPlanForAccountResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetSubscriptionPlanForAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppslistPlansResponse parses an HTTP response from a AppslistPlansWithResponse call
func ParseAppslistPlansResponse(rsp *http.Response) (*AppslistPlansResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketplaceListingPlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppslistAccountsForPlanResponse parses an HTTP response from a AppslistAccountsForPlanWithResponse call
func ParseAppslistAccountsForPlanResponse(rsp *http.Response) (*AppslistAccountsForPlanResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistAccountsForPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsgetSubscriptionPlanForAccountStubbedResponse parses an HTTP response from a AppsgetSubscriptionPlanForAccountStubbedWithResponse call
func ParseAppsgetSubscriptionPlanForAccountStubbedResponse(rsp *http.Response) (*AppsgetSubscriptionPlanForAccountStubbedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetSubscriptionPlanForAccountStubbedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAppslistPlansStubbedResponse parses an HTTP response from a AppslistPlansStubbedWithResponse call
func ParseAppslistPlansStubbedResponse(rsp *http.Response) (*AppslistPlansStubbedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistPlansStubbedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketplaceListingPlan
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseAppslistAccountsForPlanStubbedResponse parses an HTTP response from a AppslistAccountsForPlanStubbedWithResponse call
func ParseAppslistAccountsForPlanStubbedResponse(rsp *http.Response) (*AppslistAccountsForPlanStubbedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistAccountsForPlanStubbedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseMetagetResponse parses an HTTP response from a MetagetWithResponse call
func ParseMetagetResponse(rsp *http.Response) (*MetagetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetagetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistPublicEventsForRepoNetworkResponse parses an HTTP response from a ActivitylistPublicEventsForRepoNetworkWithResponse call
func ParseActivitylistPublicEventsForRepoNetworkResponse(rsp *http.Response) (*ActivitylistPublicEventsForRepoNetworkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistPublicEventsForRepoNetworkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivitylistNotificationsForAuthenticatedUserResponse parses an HTTP response from a ActivitylistNotificationsForAuthenticatedUserWithResponse call
func ParseActivitylistNotificationsForAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistNotificationsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistNotificationsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Thread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActivitymarkNotificationsAsReadResponse parses an HTTP response from a ActivitymarkNotificationsAsReadWithResponse call
func ParseActivitymarkNotificationsAsReadResponse(rsp *http.Response) (*ActivitymarkNotificationsAsReadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitymarkNotificationsAsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitygetThreadResponse parses an HTTP response from a ActivitygetThreadWithResponse call
func ParseActivitygetThreadResponse(rsp *http.Response) (*ActivitygetThreadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitygetThreadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Thread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitymarkThreadAsReadResponse parses an HTTP response from a ActivitymarkThreadAsReadWithResponse call
func ParseActivitymarkThreadAsReadResponse(rsp *http.Response) (*ActivitymarkThreadAsReadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitymarkThreadAsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitydeleteThreadSubscriptionResponse parses an HTTP response from a ActivitydeleteThreadSubscriptionWithResponse call
func ParseActivitydeleteThreadSubscriptionResponse(rsp *http.Response) (*ActivitydeleteThreadSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitydeleteThreadSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitygetThreadSubscriptionForAuthenticatedUserResponse parses an HTTP response from a ActivitygetThreadSubscriptionForAuthenticatedUserWithResponse call
func ParseActivitygetThreadSubscriptionForAuthenticatedUserResponse(rsp *http.Response) (*ActivitygetThreadSubscriptionForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitygetThreadSubscriptionForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitysetThreadSubscriptionResponse parses an HTTP response from a ActivitysetThreadSubscriptionWithResponse call
func ParseActivitysetThreadSubscriptionResponse(rsp *http.Response) (*ActivitysetThreadSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitysetThreadSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ThreadSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMetagetOctocatResponse parses an HTTP response from a MetagetOctocatWithResponse call
func ParseMetagetOctocatResponse(rsp *http.Response) (*MetagetOctocatResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetagetOctocatResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgslistResponse parses an HTTP response from a OrgslistWithResponse call
func ParseOrgslistResponse(rsp *http.Response) (*OrgslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistCustomRolesResponse parses an HTTP response from a OrgslistCustomRolesWithResponse call
func ParseOrgslistCustomRolesResponse(rsp *http.Response) (*OrgslistCustomRolesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistCustomRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CustomRoles *[]OrganizationCustomRepositoryRole `json:"custom_roles,omitempty"`

			// The number of custom roles in this organization
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsgetResponse parses an HTTP response from a OrgsgetWithResponse call
func ParseOrgsgetResponse(rsp *http.Response) (*OrgsgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsupdateResponse parses an HTTP response from a OrgsupdateWithResponse call
func ParseOrgsupdateResponse(rsp *http.Response) (*OrgsupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionsgetActionsCacheUsageForOrgResponse parses an HTTP response from a ActionsgetActionsCacheUsageForOrgWithResponse call
func ParseActionsgetActionsCacheUsageForOrgResponse(rsp *http.Response) (*ActionsgetActionsCacheUsageForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetActionsCacheUsageForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsCacheUsageOrgEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetActionsCacheUsageByRepoForOrgResponse parses an HTTP response from a ActionsgetActionsCacheUsageByRepoForOrgWithResponse call
func ParseActionsgetActionsCacheUsageByRepoForOrgResponse(rsp *http.Response) (*ActionsgetActionsCacheUsageByRepoForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetActionsCacheUsageByRepoForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			RepositoryCacheUsages []ActionsCacheUsageByRepository `json:"repository_cache_usages"`
			TotalCount            int                             `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetGithubActionsPermissionsOrganizationResponse parses an HTTP response from a ActionsgetGithubActionsPermissionsOrganizationWithResponse call
func ParseActionsgetGithubActionsPermissionsOrganizationResponse(rsp *http.Response) (*ActionsgetGithubActionsPermissionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetGithubActionsPermissionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsOrganizationPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetGithubActionsPermissionsOrganizationResponse parses an HTTP response from a ActionssetGithubActionsPermissionsOrganizationWithResponse call
func ParseActionssetGithubActionsPermissionsOrganizationResponse(rsp *http.Response) (*ActionssetGithubActionsPermissionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetGithubActionsPermissionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse parses an HTTP response from a ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse call
func ParseActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse(rsp *http.Response) (*ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelectedRepositoriesEnabledGithubActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories []Repository `json:"repositories"`
			TotalCount   float32      `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse parses an HTTP response from a ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationWithResponse call
func ParseActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse(rsp *http.Response) (*ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetSelectedRepositoriesEnabledGithubActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsdisableSelectedRepositoryGithubActionsOrganizationResponse parses an HTTP response from a ActionsdisableSelectedRepositoryGithubActionsOrganizationWithResponse call
func ParseActionsdisableSelectedRepositoryGithubActionsOrganizationResponse(rsp *http.Response) (*ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdisableSelectedRepositoryGithubActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsenableSelectedRepositoryGithubActionsOrganizationResponse parses an HTTP response from a ActionsenableSelectedRepositoryGithubActionsOrganizationWithResponse call
func ParseActionsenableSelectedRepositoryGithubActionsOrganizationResponse(rsp *http.Response) (*ActionsenableSelectedRepositoryGithubActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsenableSelectedRepositoryGithubActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetAllowedActionsOrganizationResponse parses an HTTP response from a ActionsgetAllowedActionsOrganizationWithResponse call
func ParseActionsgetAllowedActionsOrganizationResponse(rsp *http.Response) (*ActionsgetAllowedActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetAllowedActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelectedActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetAllowedActionsOrganizationResponse parses an HTTP response from a ActionssetAllowedActionsOrganizationWithResponse call
func ParseActionssetAllowedActionsOrganizationResponse(rsp *http.Response) (*ActionssetAllowedActionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetAllowedActionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse parses an HTTP response from a ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse call
func ParseActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse(rsp *http.Response) (*ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsGetDefaultWorkflowPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse parses an HTTP response from a ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationWithResponse call
func ParseActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse(rsp *http.Response) (*ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetGithubActionsDefaultWorkflowPermissionsOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistSelfHostedRunnerGroupsForOrgResponse parses an HTTP response from a ActionslistSelfHostedRunnerGroupsForOrgWithResponse call
func ParseActionslistSelfHostedRunnerGroupsForOrgResponse(rsp *http.Response) (*ActionslistSelfHostedRunnerGroupsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelfHostedRunnerGroupsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			RunnerGroups []RunnerGroupsOrg `json:"runner_groups"`
			TotalCount   float32           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateSelfHostedRunnerGroupForOrgResponse parses an HTTP response from a ActionscreateSelfHostedRunnerGroupForOrgWithResponse call
func ParseActionscreateSelfHostedRunnerGroupForOrgResponse(rsp *http.Response) (*ActionscreateSelfHostedRunnerGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateSelfHostedRunnerGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RunnerGroupsOrg
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionsdeleteSelfHostedRunnerGroupFromOrgResponse parses an HTTP response from a ActionsdeleteSelfHostedRunnerGroupFromOrgWithResponse call
func ParseActionsdeleteSelfHostedRunnerGroupFromOrgResponse(rsp *http.Response) (*ActionsdeleteSelfHostedRunnerGroupFromOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteSelfHostedRunnerGroupFromOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetSelfHostedRunnerGroupForOrgResponse parses an HTTP response from a ActionsgetSelfHostedRunnerGroupForOrgWithResponse call
func ParseActionsgetSelfHostedRunnerGroupForOrgResponse(rsp *http.Response) (*ActionsgetSelfHostedRunnerGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetSelfHostedRunnerGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunnerGroupsOrg
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsupdateSelfHostedRunnerGroupForOrgResponse parses an HTTP response from a ActionsupdateSelfHostedRunnerGroupForOrgWithResponse call
func ParseActionsupdateSelfHostedRunnerGroupForOrgResponse(rsp *http.Response) (*ActionsupdateSelfHostedRunnerGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsupdateSelfHostedRunnerGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunnerGroupsOrg
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse parses an HTTP response from a ActionslistRepoAccessToSelfHostedRunnerGroupInOrgWithResponse call
func ParseActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp *http.Response) (*ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistRepoAccessToSelfHostedRunnerGroupInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories []MinimalRepository `json:"repositories"`
			TotalCount   float32             `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse parses an HTTP response from a ActionssetRepoAccessToSelfHostedRunnerGroupInOrgWithResponse call
func ParseActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp *http.Response) (*ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetRepoAccessToSelfHostedRunnerGroupInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse parses an HTTP response from a ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgWithResponse call
func ParseActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp *http.Response) (*ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveRepoAccessToSelfHostedRunnerGroupInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse parses an HTTP response from a ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgWithResponse call
func ParseActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse(rsp *http.Response) (*ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsaddRepoAccessToSelfHostedRunnerGroupInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistSelfHostedRunnersInGroupForOrgResponse parses an HTTP response from a ActionslistSelfHostedRunnersInGroupForOrgWithResponse call
func ParseActionslistSelfHostedRunnersInGroupForOrgResponse(rsp *http.Response) (*ActionslistSelfHostedRunnersInGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelfHostedRunnersInGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Runners    []Runner `json:"runners"`
			TotalCount float32  `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetSelfHostedRunnersInGroupForOrgResponse parses an HTTP response from a ActionssetSelfHostedRunnersInGroupForOrgWithResponse call
func ParseActionssetSelfHostedRunnersInGroupForOrgResponse(rsp *http.Response) (*ActionssetSelfHostedRunnersInGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetSelfHostedRunnersInGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsremoveSelfHostedRunnerFromGroupForOrgResponse parses an HTTP response from a ActionsremoveSelfHostedRunnerFromGroupForOrgWithResponse call
func ParseActionsremoveSelfHostedRunnerFromGroupForOrgResponse(rsp *http.Response) (*ActionsremoveSelfHostedRunnerFromGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveSelfHostedRunnerFromGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsaddSelfHostedRunnerToGroupForOrgResponse parses an HTTP response from a ActionsaddSelfHostedRunnerToGroupForOrgWithResponse call
func ParseActionsaddSelfHostedRunnerToGroupForOrgResponse(rsp *http.Response) (*ActionsaddSelfHostedRunnerToGroupForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsaddSelfHostedRunnerToGroupForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistSelfHostedRunnersForOrgResponse parses an HTTP response from a ActionslistSelfHostedRunnersForOrgWithResponse call
func ParseActionslistSelfHostedRunnersForOrgResponse(rsp *http.Response) (*ActionslistSelfHostedRunnersForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelfHostedRunnersForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Runners    []Runner `json:"runners"`
			TotalCount int      `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionslistRunnerApplicationsForOrgResponse parses an HTTP response from a ActionslistRunnerApplicationsForOrgWithResponse call
func ParseActionslistRunnerApplicationsForOrgResponse(rsp *http.Response) (*ActionslistRunnerApplicationsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistRunnerApplicationsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RunnerApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateRegistrationTokenForOrgResponse parses an HTTP response from a ActionscreateRegistrationTokenForOrgWithResponse call
func ParseActionscreateRegistrationTokenForOrgResponse(rsp *http.Response) (*ActionscreateRegistrationTokenForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateRegistrationTokenForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionscreateRemoveTokenForOrgResponse parses an HTTP response from a ActionscreateRemoveTokenForOrgWithResponse call
func ParseActionscreateRemoveTokenForOrgResponse(rsp *http.Response) (*ActionscreateRemoveTokenForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateRemoveTokenForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionsdeleteSelfHostedRunnerFromOrgResponse parses an HTTP response from a ActionsdeleteSelfHostedRunnerFromOrgWithResponse call
func ParseActionsdeleteSelfHostedRunnerFromOrgResponse(rsp *http.Response) (*ActionsdeleteSelfHostedRunnerFromOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteSelfHostedRunnerFromOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionsgetSelfHostedRunnerForOrgWithResponse call
func ParseActionsgetSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionsgetSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Runner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgWithResponse call
func ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionslistLabelsForSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionslistLabelsForSelfHostedRunnerForOrgWithResponse call
func ParseActionslistLabelsForSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionslistLabelsForSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistLabelsForSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionsaddCustomLabelsToSelfHostedRunnerForOrgWithResponse call
func ParseActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsaddCustomLabelsToSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionssetCustomLabelsForSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionssetCustomLabelsForSelfHostedRunnerForOrgWithResponse call
func ParseActionssetCustomLabelsForSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetCustomLabelsForSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse parses an HTTP response from a ActionsremoveCustomLabelFromSelfHostedRunnerForOrgWithResponse call
func ParseActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse(rsp *http.Response) (*ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveCustomLabelFromSelfHostedRunnerForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionslistOrgSecretsResponse parses an HTTP response from a ActionslistOrgSecretsWithResponse call
func ParseActionslistOrgSecretsResponse(rsp *http.Response) (*ActionslistOrgSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistOrgSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []OrganizationActionsSecret `json:"secrets"`
			TotalCount int                         `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetOrgPublicKeyResponse parses an HTTP response from a ActionsgetOrgPublicKeyWithResponse call
func ParseActionsgetOrgPublicKeyResponse(rsp *http.Response) (*ActionsgetOrgPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetOrgPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteOrgSecretResponse parses an HTTP response from a ActionsdeleteOrgSecretWithResponse call
func ParseActionsdeleteOrgSecretResponse(rsp *http.Response) (*ActionsdeleteOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetOrgSecretResponse parses an HTTP response from a ActionsgetOrgSecretWithResponse call
func ParseActionsgetOrgSecretResponse(rsp *http.Response) (*ActionsgetOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationActionsSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateOrUpdateOrgSecretResponse parses an HTTP response from a ActionscreateOrUpdateOrgSecretWithResponse call
func ParseActionscreateOrUpdateOrgSecretResponse(rsp *http.Response) (*ActionscreateOrUpdateOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateOrUpdateOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionslistSelectedReposForOrgSecretResponse parses an HTTP response from a ActionslistSelectedReposForOrgSecretWithResponse call
func ParseActionslistSelectedReposForOrgSecretResponse(rsp *http.Response) (*ActionslistSelectedReposForOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelectedReposForOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories []MinimalRepository `json:"repositories"`
			TotalCount   int                 `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetSelectedReposForOrgSecretResponse parses an HTTP response from a ActionssetSelectedReposForOrgSecretWithResponse call
func ParseActionssetSelectedReposForOrgSecretResponse(rsp *http.Response) (*ActionssetSelectedReposForOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetSelectedReposForOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsremoveSelectedRepoFromOrgSecretResponse parses an HTTP response from a ActionsremoveSelectedRepoFromOrgSecretWithResponse call
func ParseActionsremoveSelectedRepoFromOrgSecretResponse(rsp *http.Response) (*ActionsremoveSelectedRepoFromOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveSelectedRepoFromOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsaddSelectedRepoToOrgSecretResponse parses an HTTP response from a ActionsaddSelectedRepoToOrgSecretWithResponse call
func ParseActionsaddSelectedRepoToOrgSecretResponse(rsp *http.Response) (*ActionsaddSelectedRepoToOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsaddSelectedRepoToOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgsgetAuditLogResponse parses an HTTP response from a OrgsgetAuditLogWithResponse call
func ParseOrgsgetAuditLogResponse(rsp *http.Response) (*OrgsgetAuditLogResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetAuditLogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuditLogEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistBlockedUsersResponse parses an HTTP response from a OrgslistBlockedUsersWithResponse call
func ParseOrgslistBlockedUsersResponse(rsp *http.Response) (*OrgslistBlockedUsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistBlockedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsunblockUserResponse parses an HTTP response from a OrgsunblockUserWithResponse call
func ParseOrgsunblockUserResponse(rsp *http.Response) (*OrgsunblockUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsunblockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgscheckBlockedUserResponse parses an HTTP response from a OrgscheckBlockedUserWithResponse call
func ParseOrgscheckBlockedUserResponse(rsp *http.Response) (*OrgscheckBlockedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscheckBlockedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsblockUserResponse parses an HTTP response from a OrgsblockUserWithResponse call
func ParseOrgsblockUserResponse(rsp *http.Response) (*OrgsblockUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsblockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCodeScanninglistAlertsForOrgResponse parses an HTTP response from a CodeScanninglistAlertsForOrgWithResponse call
func ParseCodeScanninglistAlertsForOrgResponse(rsp *http.Response) (*CodeScanninglistAlertsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninglistAlertsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeScanningOrganizationAlertItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseOrgslistSamlSsoAuthorizationsResponse parses an HTTP response from a OrgslistSamlSsoAuthorizationsWithResponse call
func ParseOrgslistSamlSsoAuthorizationsResponse(rsp *http.Response) (*OrgslistSamlSsoAuthorizationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistSamlSsoAuthorizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CredentialAuthorization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsremoveSamlSsoAuthorizationResponse parses an HTTP response from a OrgsremoveSamlSsoAuthorizationWithResponse call
func ParseOrgsremoveSamlSsoAuthorizationResponse(rsp *http.Response) (*OrgsremoveSamlSsoAuthorizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsremoveSamlSsoAuthorizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDependabotlistOrgSecretsResponse parses an HTTP response from a DependabotlistOrgSecretsWithResponse call
func ParseDependabotlistOrgSecretsResponse(rsp *http.Response) (*DependabotlistOrgSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotlistOrgSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []OrganizationDependabotSecret `json:"secrets"`
			TotalCount int                            `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotgetOrgPublicKeyResponse parses an HTTP response from a DependabotgetOrgPublicKeyWithResponse call
func ParseDependabotgetOrgPublicKeyResponse(rsp *http.Response) (*DependabotgetOrgPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotgetOrgPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DependabotPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotdeleteOrgSecretResponse parses an HTTP response from a DependabotdeleteOrgSecretWithResponse call
func ParseDependabotdeleteOrgSecretResponse(rsp *http.Response) (*DependabotdeleteOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotdeleteOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDependabotgetOrgSecretResponse parses an HTTP response from a DependabotgetOrgSecretWithResponse call
func ParseDependabotgetOrgSecretResponse(rsp *http.Response) (*DependabotgetOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotgetOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationDependabotSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotcreateOrUpdateOrgSecretResponse parses an HTTP response from a DependabotcreateOrUpdateOrgSecretWithResponse call
func ParseDependabotcreateOrUpdateOrgSecretResponse(rsp *http.Response) (*DependabotcreateOrUpdateOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotcreateOrUpdateOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDependabotlistSelectedReposForOrgSecretResponse parses an HTTP response from a DependabotlistSelectedReposForOrgSecretWithResponse call
func ParseDependabotlistSelectedReposForOrgSecretResponse(rsp *http.Response) (*DependabotlistSelectedReposForOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotlistSelectedReposForOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories []MinimalRepository `json:"repositories"`
			TotalCount   int                 `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotsetSelectedReposForOrgSecretResponse parses an HTTP response from a DependabotsetSelectedReposForOrgSecretWithResponse call
func ParseDependabotsetSelectedReposForOrgSecretResponse(rsp *http.Response) (*DependabotsetSelectedReposForOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotsetSelectedReposForOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDependabotremoveSelectedRepoFromOrgSecretResponse parses an HTTP response from a DependabotremoveSelectedRepoFromOrgSecretWithResponse call
func ParseDependabotremoveSelectedRepoFromOrgSecretResponse(rsp *http.Response) (*DependabotremoveSelectedRepoFromOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotremoveSelectedRepoFromOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDependabotaddSelectedRepoToOrgSecretResponse parses an HTTP response from a DependabotaddSelectedRepoToOrgSecretWithResponse call
func ParseDependabotaddSelectedRepoToOrgSecretResponse(rsp *http.Response) (*DependabotaddSelectedRepoToOrgSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotaddSelectedRepoToOrgSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActivitylistPublicOrgEventsResponse parses an HTTP response from a ActivitylistPublicOrgEventsWithResponse call
func ParseActivitylistPublicOrgEventsResponse(rsp *http.Response) (*ActivitylistPublicOrgEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistPublicOrgEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsexternalIdpGroupInfoForOrgResponse parses an HTTP response from a TeamsexternalIdpGroupInfoForOrgWithResponse call
func ParseTeamsexternalIdpGroupInfoForOrgResponse(rsp *http.Response) (*TeamsexternalIdpGroupInfoForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsexternalIdpGroupInfoForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistExternalIdpGroupsForOrgResponse parses an HTTP response from a TeamslistExternalIdpGroupsForOrgWithResponse call
func ParseTeamslistExternalIdpGroupsForOrgResponse(rsp *http.Response) (*TeamslistExternalIdpGroupsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistExternalIdpGroupsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistFailedInvitationsResponse parses an HTTP response from a OrgslistFailedInvitationsWithResponse call
func ParseOrgslistFailedInvitationsResponse(rsp *http.Response) (*OrgslistFailedInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistFailedInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgslistWebhooksResponse parses an HTTP response from a OrgslistWebhooksWithResponse call
func ParseOrgslistWebhooksResponse(rsp *http.Response) (*OrgslistWebhooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrgHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgscreateWebhookResponse parses an HTTP response from a OrgscreateWebhookWithResponse call
func ParseOrgscreateWebhookResponse(rsp *http.Response) (*OrgscreateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrgHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgsdeleteWebhookResponse parses an HTTP response from a OrgsdeleteWebhookWithResponse call
func ParseOrgsdeleteWebhookResponse(rsp *http.Response) (*OrgsdeleteWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsdeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsgetWebhookResponse parses an HTTP response from a OrgsgetWebhookWithResponse call
func ParseOrgsgetWebhookResponse(rsp *http.Response) (*OrgsgetWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsupdateWebhookResponse parses an HTTP response from a OrgsupdateWebhookWithResponse call
func ParseOrgsupdateWebhookResponse(rsp *http.Response) (*OrgsupdateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsupdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgHook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgsgetWebhookConfigForOrgResponse parses an HTTP response from a OrgsgetWebhookConfigForOrgWithResponse call
func ParseOrgsgetWebhookConfigForOrgResponse(rsp *http.Response) (*OrgsgetWebhookConfigForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetWebhookConfigForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsupdateWebhookConfigForOrgResponse parses an HTTP response from a OrgsupdateWebhookConfigForOrgWithResponse call
func ParseOrgsupdateWebhookConfigForOrgResponse(rsp *http.Response) (*OrgsupdateWebhookConfigForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsupdateWebhookConfigForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistWebhookDeliveriesResponse parses an HTTP response from a OrgslistWebhookDeliveriesWithResponse call
func ParseOrgslistWebhookDeliveriesResponse(rsp *http.Response) (*OrgslistWebhookDeliveriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistWebhookDeliveriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HookDeliveryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseOrgsgetWebhookDeliveryResponse parses an HTTP response from a OrgsgetWebhookDeliveryWithResponse call
func ParseOrgsgetWebhookDeliveryResponse(rsp *http.Response) (*OrgsgetWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookDelivery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseOrgsredeliverWebhookDeliveryResponse parses an HTTP response from a OrgsredeliverWebhookDeliveryWithResponse call
func ParseOrgsredeliverWebhookDeliveryResponse(rsp *http.Response) (*OrgsredeliverWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsredeliverWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseOrgspingWebhookResponse parses an HTTP response from a OrgspingWebhookWithResponse call
func ParseOrgspingWebhookResponse(rsp *http.Response) (*OrgspingWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgspingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsgetOrgInstallationResponse parses an HTTP response from a AppsgetOrgInstallationWithResponse call
func ParseAppsgetOrgInstallationResponse(rsp *http.Response) (*AppsgetOrgInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetOrgInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistAppInstallationsResponse parses an HTTP response from a OrgslistAppInstallationsWithResponse call
func ParseOrgslistAppInstallationsResponse(rsp *http.Response) (*OrgslistAppInstallationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistAppInstallationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Installations []Installation `json:"installations"`
			TotalCount    int            `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInteractionsremoveRestrictionsForOrgResponse parses an HTTP response from a InteractionsremoveRestrictionsForOrgWithResponse call
func ParseInteractionsremoveRestrictionsForOrgResponse(rsp *http.Response) (*InteractionsremoveRestrictionsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsremoveRestrictionsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInteractionsgetRestrictionsForOrgResponse parses an HTTP response from a InteractionsgetRestrictionsForOrgWithResponse call
func ParseInteractionsgetRestrictionsForOrgResponse(rsp *http.Response) (*InteractionsgetRestrictionsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsgetRestrictionsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInteractionssetRestrictionsForOrgResponse parses an HTTP response from a InteractionssetRestrictionsForOrgWithResponse call
func ParseInteractionssetRestrictionsForOrgResponse(rsp *http.Response) (*InteractionssetRestrictionsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionssetRestrictionsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InteractionLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgslistPendingInvitationsResponse parses an HTTP response from a OrgslistPendingInvitationsWithResponse call
func ParseOrgslistPendingInvitationsResponse(rsp *http.Response) (*OrgslistPendingInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistPendingInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgscreateInvitationResponse parses an HTTP response from a OrgscreateInvitationWithResponse call
func ParseOrgscreateInvitationResponse(rsp *http.Response) (*OrgscreateInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscreateInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OrganizationInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgscancelInvitationResponse parses an HTTP response from a OrgscancelInvitationWithResponse call
func ParseOrgscancelInvitationResponse(rsp *http.Response) (*OrgscancelInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscancelInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgslistInvitationTeamsResponse parses an HTTP response from a OrgslistInvitationTeamsWithResponse call
func ParseOrgslistInvitationTeamsResponse(rsp *http.Response) (*OrgslistInvitationTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistInvitationTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssueslistForOrgResponse parses an HTTP response from a IssueslistForOrgWithResponse call
func ParseIssueslistForOrgResponse(rsp *http.Response) (*IssueslistForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgslistMembersResponse parses an HTTP response from a OrgslistMembersWithResponse call
func ParseOrgslistMembersResponse(rsp *http.Response) (*OrgslistMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgsremoveMemberResponse parses an HTTP response from a OrgsremoveMemberWithResponse call
func ParseOrgsremoveMemberResponse(rsp *http.Response) (*OrgsremoveMemberResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsremoveMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseOrgscheckMembershipForUserResponse parses an HTTP response from a OrgscheckMembershipForUserWithResponse call
func ParseOrgscheckMembershipForUserResponse(rsp *http.Response) (*OrgscheckMembershipForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscheckMembershipForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgsremoveMembershipForUserResponse parses an HTTP response from a OrgsremoveMembershipForUserWithResponse call
func ParseOrgsremoveMembershipForUserResponse(rsp *http.Response) (*OrgsremoveMembershipForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsremoveMembershipForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsgetMembershipForUserResponse parses an HTTP response from a OrgsgetMembershipForUserWithResponse call
func ParseOrgsgetMembershipForUserResponse(rsp *http.Response) (*OrgsgetMembershipForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetMembershipForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgssetMembershipForUserResponse parses an HTTP response from a OrgssetMembershipForUserWithResponse call
func ParseOrgssetMembershipForUserResponse(rsp *http.Response) (*OrgssetMembershipForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgssetMembershipForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationslistForOrgResponse parses an HTTP response from a MigrationslistForOrgWithResponse call
func ParseMigrationslistForOrgResponse(rsp *http.Response) (*MigrationslistForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationslistForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMigrationsstartForOrgResponse parses an HTTP response from a MigrationsstartForOrgWithResponse call
func ParseMigrationsstartForOrgResponse(rsp *http.Response) (*MigrationsstartForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsstartForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationsgetStatusForOrgResponse parses an HTTP response from a MigrationsgetStatusForOrgWithResponse call
func ParseMigrationsgetStatusForOrgResponse(rsp *http.Response) (*MigrationsgetStatusForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetStatusForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsdeleteArchiveForOrgResponse parses an HTTP response from a MigrationsdeleteArchiveForOrgWithResponse call
func ParseMigrationsdeleteArchiveForOrgResponse(rsp *http.Response) (*MigrationsdeleteArchiveForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsdeleteArchiveForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsdownloadArchiveForOrgResponse parses an HTTP response from a MigrationsdownloadArchiveForOrgWithResponse call
func ParseMigrationsdownloadArchiveForOrgResponse(rsp *http.Response) (*MigrationsdownloadArchiveForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsdownloadArchiveForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsunlockRepoForOrgResponse parses an HTTP response from a MigrationsunlockRepoForOrgWithResponse call
func ParseMigrationsunlockRepoForOrgResponse(rsp *http.Response) (*MigrationsunlockRepoForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsunlockRepoForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationslistReposForOrgResponse parses an HTTP response from a MigrationslistReposForOrgWithResponse call
func ParseMigrationslistReposForOrgResponse(rsp *http.Response) (*MigrationslistReposForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationslistReposForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgslistOutsideCollaboratorsResponse parses an HTTP response from a OrgslistOutsideCollaboratorsWithResponse call
func ParseOrgslistOutsideCollaboratorsResponse(rsp *http.Response) (*OrgslistOutsideCollaboratorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistOutsideCollaboratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsremoveOutsideCollaboratorResponse parses an HTTP response from a OrgsremoveOutsideCollaboratorWithResponse call
func ParseOrgsremoveOutsideCollaboratorResponse(rsp *http.Response) (*OrgsremoveOutsideCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsremoveOutsideCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgsconvertMemberToOutsideCollaboratorResponse parses an HTTP response from a OrgsconvertMemberToOutsideCollaboratorWithResponse call
func ParseOrgsconvertMemberToOutsideCollaboratorResponse(rsp *http.Response) (*OrgsconvertMemberToOutsideCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsconvertMemberToOutsideCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackageslistPackagesForOrganizationResponse parses an HTTP response from a PackageslistPackagesForOrganizationWithResponse call
func ParsePackageslistPackagesForOrganizationResponse(rsp *http.Response) (*PackageslistPackagesForOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackageslistPackagesForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageForOrgResponse parses an HTTP response from a PackagesdeletePackageForOrgWithResponse call
func ParsePackagesdeletePackageForOrgResponse(rsp *http.Response) (*PackagesdeletePackageForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageForOrganizationResponse parses an HTTP response from a PackagesgetPackageForOrganizationWithResponse call
func ParsePackagesgetPackageForOrganizationResponse(rsp *http.Response) (*PackagesgetPackageForOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageForOrgResponse parses an HTTP response from a PackagesrestorePackageForOrgWithResponse call
func ParsePackagesrestorePackageForOrgResponse(rsp *http.Response) (*PackagesrestorePackageForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetAllPackageVersionsForPackageOwnedByOrgResponse parses an HTTP response from a PackagesgetAllPackageVersionsForPackageOwnedByOrgWithResponse call
func ParsePackagesgetAllPackageVersionsForPackageOwnedByOrgResponse(rsp *http.Response) (*PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetAllPackageVersionsForPackageOwnedByOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageVersionForOrgResponse parses an HTTP response from a PackagesdeletePackageVersionForOrgWithResponse call
func ParsePackagesdeletePackageVersionForOrgResponse(rsp *http.Response) (*PackagesdeletePackageVersionForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageVersionForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageVersionForOrganizationResponse parses an HTTP response from a PackagesgetPackageVersionForOrganizationWithResponse call
func ParsePackagesgetPackageVersionForOrganizationResponse(rsp *http.Response) (*PackagesgetPackageVersionForOrganizationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageVersionForOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageVersionForOrgResponse parses an HTTP response from a PackagesrestorePackageVersionForOrgWithResponse call
func ParsePackagesrestorePackageVersionForOrgResponse(rsp *http.Response) (*PackagesrestorePackageVersionForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageVersionForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectslistForOrgResponse parses an HTTP response from a ProjectslistForOrgWithResponse call
func ParseProjectslistForOrgResponse(rsp *http.Response) (*ProjectslistForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectscreateForOrgResponse parses an HTTP response from a ProjectscreateForOrgWithResponse call
func ParseProjectscreateForOrgResponse(rsp *http.Response) (*ProjectscreateForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectscreateForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgslistPublicMembersResponse parses an HTTP response from a OrgslistPublicMembersWithResponse call
func ParseOrgslistPublicMembersResponse(rsp *http.Response) (*OrgslistPublicMembersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistPublicMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgsremovePublicMembershipForAuthenticatedUserResponse parses an HTTP response from a OrgsremovePublicMembershipForAuthenticatedUserWithResponse call
func ParseOrgsremovePublicMembershipForAuthenticatedUserResponse(rsp *http.Response) (*OrgsremovePublicMembershipForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsremovePublicMembershipForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgscheckPublicMembershipForUserResponse parses an HTTP response from a OrgscheckPublicMembershipForUserWithResponse call
func ParseOrgscheckPublicMembershipForUserResponse(rsp *http.Response) (*OrgscheckPublicMembershipForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgscheckPublicMembershipForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseOrgssetPublicMembershipForAuthenticatedUserResponse parses an HTTP response from a OrgssetPublicMembershipForAuthenticatedUserWithResponse call
func ParseOrgssetPublicMembershipForAuthenticatedUserResponse(rsp *http.Response) (*OrgssetPublicMembershipForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgssetPublicMembershipForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReposlistForOrgResponse parses an HTTP response from a ReposlistForOrgWithResponse call
func ParseReposlistForOrgResponse(rsp *http.Response) (*ReposlistForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateInOrgResponse parses an HTTP response from a ReposcreateInOrgWithResponse call
func ParseReposcreateInOrgResponse(rsp *http.Response) (*ReposcreateInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSecretScanninglistAlertsForOrgResponse parses an HTTP response from a SecretScanninglistAlertsForOrgWithResponse call
func ParseSecretScanninglistAlertsForOrgResponse(rsp *http.Response) (*SecretScanninglistAlertsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanninglistAlertsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationSecretScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubActionsBillingOrgResponse parses an HTTP response from a BillinggetGithubActionsBillingOrgWithResponse call
func ParseBillinggetGithubActionsBillingOrgResponse(rsp *http.Response) (*BillinggetGithubActionsBillingOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubActionsBillingOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubAdvancedSecurityBillingOrgResponse parses an HTTP response from a BillinggetGithubAdvancedSecurityBillingOrgWithResponse call
func ParseBillinggetGithubAdvancedSecurityBillingOrgResponse(rsp *http.Response) (*BillinggetGithubAdvancedSecurityBillingOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubAdvancedSecurityBillingOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AdvancedSecurityActiveCommitters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubPackagesBillingOrgResponse parses an HTTP response from a BillinggetGithubPackagesBillingOrgWithResponse call
func ParseBillinggetGithubPackagesBillingOrgResponse(rsp *http.Response) (*BillinggetGithubPackagesBillingOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubPackagesBillingOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackagesBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetSharedStorageBillingOrgResponse parses an HTTP response from a BillinggetSharedStorageBillingOrgWithResponse call
func ParseBillinggetSharedStorageBillingOrgResponse(rsp *http.Response) (*BillinggetSharedStorageBillingOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetSharedStorageBillingOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CombinedBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistIdpGroupsForOrgResponse parses an HTTP response from a TeamslistIdpGroupsForOrgWithResponse call
func ParseTeamslistIdpGroupsForOrgResponse(rsp *http.Response) (*TeamslistIdpGroupsForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistIdpGroupsForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistResponse parses an HTTP response from a TeamslistWithResponse call
func ParseTeamslistResponse(rsp *http.Response) (*TeamslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTeamscreateResponse parses an HTTP response from a TeamscreateWithResponse call
func ParseTeamscreateResponse(rsp *http.Response) (*TeamscreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteInOrgResponse parses an HTTP response from a TeamsdeleteInOrgWithResponse call
func ParseTeamsdeleteInOrgResponse(rsp *http.Response) (*TeamsdeleteInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetByNameResponse parses an HTTP response from a TeamsgetByNameWithResponse call
func ParseTeamsgetByNameResponse(rsp *http.Response) (*TeamsgetByNameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetByNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsupdateInOrgResponse parses an HTTP response from a TeamsupdateInOrgWithResponse call
func ParseTeamsupdateInOrgResponse(rsp *http.Response) (*TeamsupdateInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamslistDiscussionsInOrgResponse parses an HTTP response from a TeamslistDiscussionsInOrgWithResponse call
func ParseTeamslistDiscussionsInOrgResponse(rsp *http.Response) (*TeamslistDiscussionsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistDiscussionsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamscreateDiscussionInOrgResponse parses an HTTP response from a TeamscreateDiscussionInOrgWithResponse call
func ParseTeamscreateDiscussionInOrgResponse(rsp *http.Response) (*TeamscreateDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteDiscussionInOrgResponse parses an HTTP response from a TeamsdeleteDiscussionInOrgWithResponse call
func ParseTeamsdeleteDiscussionInOrgResponse(rsp *http.Response) (*TeamsdeleteDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetDiscussionInOrgResponse parses an HTTP response from a TeamsgetDiscussionInOrgWithResponse call
func ParseTeamsgetDiscussionInOrgResponse(rsp *http.Response) (*TeamsgetDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsupdateDiscussionInOrgResponse parses an HTTP response from a TeamsupdateDiscussionInOrgWithResponse call
func ParseTeamsupdateDiscussionInOrgResponse(rsp *http.Response) (*TeamsupdateDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistDiscussionCommentsInOrgResponse parses an HTTP response from a TeamslistDiscussionCommentsInOrgWithResponse call
func ParseTeamslistDiscussionCommentsInOrgResponse(rsp *http.Response) (*TeamslistDiscussionCommentsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistDiscussionCommentsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamscreateDiscussionCommentInOrgResponse parses an HTTP response from a TeamscreateDiscussionCommentInOrgWithResponse call
func ParseTeamscreateDiscussionCommentInOrgResponse(rsp *http.Response) (*TeamscreateDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteDiscussionCommentInOrgResponse parses an HTTP response from a TeamsdeleteDiscussionCommentInOrgWithResponse call
func ParseTeamsdeleteDiscussionCommentInOrgResponse(rsp *http.Response) (*TeamsdeleteDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetDiscussionCommentInOrgResponse parses an HTTP response from a TeamsgetDiscussionCommentInOrgWithResponse call
func ParseTeamsgetDiscussionCommentInOrgResponse(rsp *http.Response) (*TeamsgetDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsupdateDiscussionCommentInOrgResponse parses an HTTP response from a TeamsupdateDiscussionCommentInOrgWithResponse call
func ParseTeamsupdateDiscussionCommentInOrgResponse(rsp *http.Response) (*TeamsupdateDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionslistForTeamDiscussionCommentInOrgResponse parses an HTTP response from a ReactionslistForTeamDiscussionCommentInOrgWithResponse call
func ParseReactionslistForTeamDiscussionCommentInOrgResponse(rsp *http.Response) (*ReactionslistForTeamDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForTeamDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionscreateForTeamDiscussionCommentInOrgResponse parses an HTTP response from a ReactionscreateForTeamDiscussionCommentInOrgWithResponse call
func ParseReactionscreateForTeamDiscussionCommentInOrgResponse(rsp *http.Response) (*ReactionscreateForTeamDiscussionCommentInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForTeamDiscussionCommentInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForTeamDiscussionCommentResponse parses an HTTP response from a ReactionsdeleteForTeamDiscussionCommentWithResponse call
func ParseReactionsdeleteForTeamDiscussionCommentResponse(rsp *http.Response) (*ReactionsdeleteForTeamDiscussionCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForTeamDiscussionCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReactionslistForTeamDiscussionInOrgResponse parses an HTTP response from a ReactionslistForTeamDiscussionInOrgWithResponse call
func ParseReactionslistForTeamDiscussionInOrgResponse(rsp *http.Response) (*ReactionslistForTeamDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForTeamDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionscreateForTeamDiscussionInOrgResponse parses an HTTP response from a ReactionscreateForTeamDiscussionInOrgWithResponse call
func ParseReactionscreateForTeamDiscussionInOrgResponse(rsp *http.Response) (*ReactionscreateForTeamDiscussionInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForTeamDiscussionInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForTeamDiscussionResponse parses an HTTP response from a ReactionsdeleteForTeamDiscussionWithResponse call
func ParseReactionsdeleteForTeamDiscussionResponse(rsp *http.Response) (*ReactionsdeleteForTeamDiscussionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForTeamDiscussionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsunlinkExternalIdpGroupFromTeamForOrgResponse parses an HTTP response from a TeamsunlinkExternalIdpGroupFromTeamForOrgWithResponse call
func ParseTeamsunlinkExternalIdpGroupFromTeamForOrgResponse(rsp *http.Response) (*TeamsunlinkExternalIdpGroupFromTeamForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsunlinkExternalIdpGroupFromTeamForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamslistLinkedExternalIdpGroupsToTeamForOrgResponse parses an HTTP response from a TeamslistLinkedExternalIdpGroupsToTeamForOrgWithResponse call
func ParseTeamslistLinkedExternalIdpGroupsToTeamForOrgResponse(rsp *http.Response) (*TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistLinkedExternalIdpGroupsToTeamForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslinkExternalIdpGroupToTeamForOrgResponse parses an HTTP response from a TeamslinkExternalIdpGroupToTeamForOrgWithResponse call
func ParseTeamslinkExternalIdpGroupToTeamForOrgResponse(rsp *http.Response) (*TeamslinkExternalIdpGroupToTeamForOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslinkExternalIdpGroupToTeamForOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistPendingInvitationsInOrgResponse parses an HTTP response from a TeamslistPendingInvitationsInOrgWithResponse call
func ParseTeamslistPendingInvitationsInOrgResponse(rsp *http.Response) (*TeamslistPendingInvitationsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistPendingInvitationsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistMembersInOrgResponse parses an HTTP response from a TeamslistMembersInOrgWithResponse call
func ParseTeamslistMembersInOrgResponse(rsp *http.Response) (*TeamslistMembersInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistMembersInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsremoveMembershipForUserInOrgResponse parses an HTTP response from a TeamsremoveMembershipForUserInOrgWithResponse call
func ParseTeamsremoveMembershipForUserInOrgResponse(rsp *http.Response) (*TeamsremoveMembershipForUserInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveMembershipForUserInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetMembershipForUserInOrgResponse parses an HTTP response from a TeamsgetMembershipForUserInOrgWithResponse call
func ParseTeamsgetMembershipForUserInOrgResponse(rsp *http.Response) (*TeamsgetMembershipForUserInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetMembershipForUserInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateMembershipForUserInOrgResponse parses an HTTP response from a TeamsaddOrUpdateMembershipForUserInOrgWithResponse call
func ParseTeamsaddOrUpdateMembershipForUserInOrgResponse(rsp *http.Response) (*TeamsaddOrUpdateMembershipForUserInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateMembershipForUserInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistProjectsInOrgResponse parses an HTTP response from a TeamslistProjectsInOrgWithResponse call
func ParseTeamslistProjectsInOrgResponse(rsp *http.Response) (*TeamslistProjectsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistProjectsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsremoveProjectInOrgResponse parses an HTTP response from a TeamsremoveProjectInOrgWithResponse call
func ParseTeamsremoveProjectInOrgResponse(rsp *http.Response) (*TeamsremoveProjectInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveProjectInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamscheckPermissionsForProjectInOrgResponse parses an HTTP response from a TeamscheckPermissionsForProjectInOrgWithResponse call
func ParseTeamscheckPermissionsForProjectInOrgResponse(rsp *http.Response) (*TeamscheckPermissionsForProjectInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscheckPermissionsForProjectInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateProjectPermissionsInOrgResponse parses an HTTP response from a TeamsaddOrUpdateProjectPermissionsInOrgWithResponse call
func ParseTeamsaddOrUpdateProjectPermissionsInOrgResponse(rsp *http.Response) (*TeamsaddOrUpdateProjectPermissionsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateProjectPermissionsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTeamslistReposInOrgResponse parses an HTTP response from a TeamslistReposInOrgWithResponse call
func ParseTeamslistReposInOrgResponse(rsp *http.Response) (*TeamslistReposInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistReposInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsremoveRepoInOrgResponse parses an HTTP response from a TeamsremoveRepoInOrgWithResponse call
func ParseTeamsremoveRepoInOrgResponse(rsp *http.Response) (*TeamsremoveRepoInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveRepoInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamscheckPermissionsForRepoInOrgResponse parses an HTTP response from a TeamscheckPermissionsForRepoInOrgWithResponse call
func ParseTeamscheckPermissionsForRepoInOrgResponse(rsp *http.Response) (*TeamscheckPermissionsForRepoInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscheckPermissionsForRepoInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateRepoPermissionsInOrgResponse parses an HTTP response from a TeamsaddOrUpdateRepoPermissionsInOrgWithResponse call
func ParseTeamsaddOrUpdateRepoPermissionsInOrgResponse(rsp *http.Response) (*TeamsaddOrUpdateRepoPermissionsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateRepoPermissionsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamslistIdpGroupsInOrgResponse parses an HTTP response from a TeamslistIdpGroupsInOrgWithResponse call
func ParseTeamslistIdpGroupsInOrgResponse(rsp *http.Response) (*TeamslistIdpGroupsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistIdpGroupsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamscreateOrUpdateIdpGroupConnectionsInOrgResponse parses an HTTP response from a TeamscreateOrUpdateIdpGroupConnectionsInOrgWithResponse call
func ParseTeamscreateOrUpdateIdpGroupConnectionsInOrgResponse(rsp *http.Response) (*TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateOrUpdateIdpGroupConnectionsInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistChildInOrgResponse parses an HTTP response from a TeamslistChildInOrgWithResponse call
func ParseTeamslistChildInOrgResponse(rsp *http.Response) (*TeamslistChildInOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistChildInOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseProjectsdeleteCardResponse parses an HTTP response from a ProjectsdeleteCardWithResponse call
func ParseProjectsdeleteCardResponse(rsp *http.Response) (*ProjectsdeleteCardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsdeleteCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string   `json:"documentation_url,omitempty"`
			Errors           *[]string `json:"errors,omitempty"`
			Message          *string   `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectsgetCardResponse parses an HTTP response from a ProjectsgetCardWithResponse call
func ParseProjectsgetCardResponse(rsp *http.Response) (*ProjectsgetCardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsgetCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectsupdateCardResponse parses an HTTP response from a ProjectsupdateCardWithResponse call
func ParseProjectsupdateCardResponse(rsp *http.Response) (*ProjectsupdateCardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsupdateCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsmoveCardResponse parses an HTTP response from a ProjectsmoveCardWithResponse call
func ParseProjectsmoveCardResponse(rsp *http.Response) (*ProjectsmoveCardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsmoveCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Errors           *[]struct {
				Code     *string `json:"code,omitempty"`
				Field    *string `json:"field,omitempty"`
				Message  *string `json:"message,omitempty"`
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Errors           *[]struct {
				Code    *string `json:"code,omitempty"`
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseProjectsdeleteColumnResponse parses an HTTP response from a ProjectsdeleteColumnWithResponse call
func ParseProjectsdeleteColumnResponse(rsp *http.Response) (*ProjectsdeleteColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsdeleteColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProjectsgetColumnResponse parses an HTTP response from a ProjectsgetColumnWithResponse call
func ParseProjectsgetColumnResponse(rsp *http.Response) (*ProjectsgetColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsgetColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectsupdateColumnResponse parses an HTTP response from a ProjectsupdateColumnWithResponse call
func ParseProjectsupdateColumnResponse(rsp *http.Response) (*ProjectsupdateColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsupdateColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProjectslistCardsResponse parses an HTTP response from a ProjectslistCardsWithResponse call
func ParseProjectslistCardsResponse(rsp *http.Response) (*ProjectslistCardsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistCardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProjectCard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProjectscreateCardResponse parses an HTTP response from a ProjectscreateCardWithResponse call
func ParseProjectscreateCardResponse(rsp *http.Response) (*ProjectscreateCardResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectscreateCardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProjectCard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Errors           *[]struct {
				Code    *string `json:"code,omitempty"`
				Message *string `json:"message,omitempty"`
			} `json:"errors,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseProjectsmoveColumnResponse parses an HTTP response from a ProjectsmoveColumnWithResponse call
func ParseProjectsmoveColumnResponse(rsp *http.Response) (*ProjectsmoveColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsmoveColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsdeleteResponse parses an HTTP response from a ProjectsdeleteWithResponse call
func ParseProjectsdeleteResponse(rsp *http.Response) (*ProjectsdeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsdeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string   `json:"documentation_url,omitempty"`
			Errors           *[]string `json:"errors,omitempty"`
			Message          *string   `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseProjectsgetResponse parses an HTTP response from a ProjectsgetWithResponse call
func ParseProjectsgetResponse(rsp *http.Response) (*ProjectsgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProjectsupdateResponse parses an HTTP response from a ProjectsupdateWithResponse call
func ParseProjectsupdateResponse(rsp *http.Response) (*ProjectsupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string   `json:"documentation_url,omitempty"`
			Errors           *[]string `json:"errors,omitempty"`
			Message          *string   `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectslistCollaboratorsResponse parses an HTTP response from a ProjectslistCollaboratorsWithResponse call
func ParseProjectslistCollaboratorsResponse(rsp *http.Response) (*ProjectslistCollaboratorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistCollaboratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsremoveCollaboratorResponse parses an HTTP response from a ProjectsremoveCollaboratorWithResponse call
func ParseProjectsremoveCollaboratorResponse(rsp *http.Response) (*ProjectsremoveCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsremoveCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsaddCollaboratorResponse parses an HTTP response from a ProjectsaddCollaboratorWithResponse call
func ParseProjectsaddCollaboratorResponse(rsp *http.Response) (*ProjectsaddCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsaddCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectsgetPermissionForUserResponse parses an HTTP response from a ProjectsgetPermissionForUserWithResponse call
func ParseProjectsgetPermissionForUserResponse(rsp *http.Response) (*ProjectsgetPermissionForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsgetPermissionForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectCollaboratorPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectslistColumnsResponse parses an HTTP response from a ProjectslistColumnsWithResponse call
func ParseProjectslistColumnsResponse(rsp *http.Response) (*ProjectslistColumnsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistColumnsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ProjectColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseProjectscreateColumnResponse parses an HTTP response from a ProjectscreateColumnWithResponse call
func ParseProjectscreateColumnResponse(rsp *http.Response) (*ProjectscreateColumnResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectscreateColumnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ProjectColumn
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRateLimitgetResponse parses an HTTP response from a RateLimitgetWithResponse call
func ParseRateLimitgetResponse(rsp *http.Response) (*RateLimitgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RateLimitgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RateLimitOverview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdeleteResponse parses an HTTP response from a ReposdeleteWithResponse call
func ParseReposdeleteResponse(rsp *http.Response) (*ReposdeleteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetResponse parses an HTTP response from a ReposgetWithResponse call
func ParseReposgetResponse(rsp *http.Response) (*ReposgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FullRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateResponse parses an HTTP response from a ReposupdateWithResponse call
func ParseReposupdateResponse(rsp *http.Response) (*ReposupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FullRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 307:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON307 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionslistArtifactsForRepoResponse parses an HTTP response from a ActionslistArtifactsForRepoWithResponse call
func ParseActionslistArtifactsForRepoResponse(rsp *http.Response) (*ActionslistArtifactsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistArtifactsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Artifacts  []Artifact `json:"artifacts"`
			TotalCount int        `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteArtifactResponse parses an HTTP response from a ActionsdeleteArtifactWithResponse call
func ParseActionsdeleteArtifactResponse(rsp *http.Response) (*ActionsdeleteArtifactResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetArtifactResponse parses an HTTP response from a ActionsgetArtifactWithResponse call
func ParseActionsgetArtifactResponse(rsp *http.Response) (*ActionsgetArtifactResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Artifact
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdownloadArtifactResponse parses an HTTP response from a ActionsdownloadArtifactWithResponse call
func ParseActionsdownloadArtifactResponse(rsp *http.Response) (*ActionsdownloadArtifactResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdownloadArtifactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetActionsCacheUsageResponse parses an HTTP response from a ActionsgetActionsCacheUsageWithResponse call
func ParseActionsgetActionsCacheUsageResponse(rsp *http.Response) (*ActionsgetActionsCacheUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetActionsCacheUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsCacheUsageByRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetJobForWorkflowRunResponse parses an HTTP response from a ActionsgetJobForWorkflowRunWithResponse call
func ParseActionsgetJobForWorkflowRunResponse(rsp *http.Response) (*ActionsgetJobForWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetJobForWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Job
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdownloadJobLogsForWorkflowRunResponse parses an HTTP response from a ActionsdownloadJobLogsForWorkflowRunWithResponse call
func ParseActionsdownloadJobLogsForWorkflowRunResponse(rsp *http.Response) (*ActionsdownloadJobLogsForWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdownloadJobLogsForWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsreRunJobForWorkflowRunResponse parses an HTTP response from a ActionsreRunJobForWorkflowRunWithResponse call
func ParseActionsreRunJobForWorkflowRunResponse(rsp *http.Response) (*ActionsreRunJobForWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsreRunJobForWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActionsgetGithubActionsPermissionsRepositoryResponse parses an HTTP response from a ActionsgetGithubActionsPermissionsRepositoryWithResponse call
func ParseActionsgetGithubActionsPermissionsRepositoryResponse(rsp *http.Response) (*ActionsgetGithubActionsPermissionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetGithubActionsPermissionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsRepositoryPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetGithubActionsPermissionsRepositoryResponse parses an HTTP response from a ActionssetGithubActionsPermissionsRepositoryWithResponse call
func ParseActionssetGithubActionsPermissionsRepositoryResponse(rsp *http.Response) (*ActionssetGithubActionsPermissionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetGithubActionsPermissionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetWorkflowAccessToRepositoryResponse parses an HTTP response from a ActionsgetWorkflowAccessToRepositoryWithResponse call
func ParseActionsgetWorkflowAccessToRepositoryResponse(rsp *http.Response) (*ActionsgetWorkflowAccessToRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowAccessToRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsWorkflowAccessToRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetWorkflowAccessToRepositoryResponse parses an HTTP response from a ActionssetWorkflowAccessToRepositoryWithResponse call
func ParseActionssetWorkflowAccessToRepositoryResponse(rsp *http.Response) (*ActionssetWorkflowAccessToRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetWorkflowAccessToRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetAllowedActionsRepositoryResponse parses an HTTP response from a ActionsgetAllowedActionsRepositoryWithResponse call
func ParseActionsgetAllowedActionsRepositoryResponse(rsp *http.Response) (*ActionsgetAllowedActionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetAllowedActionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SelectedActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetAllowedActionsRepositoryResponse parses an HTTP response from a ActionssetAllowedActionsRepositoryWithResponse call
func ParseActionssetAllowedActionsRepositoryResponse(rsp *http.Response) (*ActionssetAllowedActionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetAllowedActionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse parses an HTTP response from a ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse call
func ParseActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse(rsp *http.Response) (*ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsGetDefaultWorkflowPermissions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse parses an HTTP response from a ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryWithResponse call
func ParseActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse(rsp *http.Response) (*ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetGithubActionsDefaultWorkflowPermissionsRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistSelfHostedRunnersForRepoResponse parses an HTTP response from a ActionslistSelfHostedRunnersForRepoWithResponse call
func ParseActionslistSelfHostedRunnersForRepoResponse(rsp *http.Response) (*ActionslistSelfHostedRunnersForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistSelfHostedRunnersForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Runners    []Runner `json:"runners"`
			TotalCount int      `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionslistRunnerApplicationsForRepoResponse parses an HTTP response from a ActionslistRunnerApplicationsForRepoWithResponse call
func ParseActionslistRunnerApplicationsForRepoResponse(rsp *http.Response) (*ActionslistRunnerApplicationsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistRunnerApplicationsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RunnerApplication
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateRegistrationTokenForRepoResponse parses an HTTP response from a ActionscreateRegistrationTokenForRepoWithResponse call
func ParseActionscreateRegistrationTokenForRepoResponse(rsp *http.Response) (*ActionscreateRegistrationTokenForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateRegistrationTokenForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionscreateRemoveTokenForRepoResponse parses an HTTP response from a ActionscreateRemoveTokenForRepoWithResponse call
func ParseActionscreateRemoveTokenForRepoResponse(rsp *http.Response) (*ActionscreateRemoveTokenForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateRemoveTokenForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AuthenticationToken
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionsdeleteSelfHostedRunnerFromRepoResponse parses an HTTP response from a ActionsdeleteSelfHostedRunnerFromRepoWithResponse call
func ParseActionsdeleteSelfHostedRunnerFromRepoResponse(rsp *http.Response) (*ActionsdeleteSelfHostedRunnerFromRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteSelfHostedRunnerFromRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionsgetSelfHostedRunnerForRepoWithResponse call
func ParseActionsgetSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionsgetSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Runner
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoWithResponse call
func ParseActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionslistLabelsForSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionslistLabelsForSelfHostedRunnerForRepoWithResponse call
func ParseActionslistLabelsForSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionslistLabelsForSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistLabelsForSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionsaddCustomLabelsToSelfHostedRunnerForRepoWithResponse call
func ParseActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsaddCustomLabelsToSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionssetCustomLabelsForSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionssetCustomLabelsForSelfHostedRunnerForRepoWithResponse call
func ParseActionssetCustomLabelsForSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionssetCustomLabelsForSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse parses an HTTP response from a ActionsremoveCustomLabelFromSelfHostedRunnerForRepoWithResponse call
func ParseActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse(rsp *http.Response) (*ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsremoveCustomLabelFromSelfHostedRunnerForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Labels     []RunnerLabel `json:"labels"`
			TotalCount int           `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionslistWorkflowRunsForRepoResponse parses an HTTP response from a ActionslistWorkflowRunsForRepoWithResponse call
func ParseActionslistWorkflowRunsForRepoResponse(rsp *http.Response) (*ActionslistWorkflowRunsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistWorkflowRunsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TotalCount   int           `json:"total_count"`
			WorkflowRuns []WorkflowRun `json:"workflow_runs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteWorkflowRunResponse parses an HTTP response from a ActionsdeleteWorkflowRunWithResponse call
func ParseActionsdeleteWorkflowRunResponse(rsp *http.Response) (*ActionsdeleteWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetWorkflowRunResponse parses an HTTP response from a ActionsgetWorkflowRunWithResponse call
func ParseActionsgetWorkflowRunResponse(rsp *http.Response) (*ActionsgetWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetReviewsForRunResponse parses an HTTP response from a ActionsgetReviewsForRunWithResponse call
func ParseActionsgetReviewsForRunResponse(rsp *http.Response) (*ActionsgetReviewsForRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetReviewsForRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []EnvironmentApprovals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsapproveWorkflowRunResponse parses an HTTP response from a ActionsapproveWorkflowRunWithResponse call
func ParseActionsapproveWorkflowRunResponse(rsp *http.Response) (*ActionsapproveWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsapproveWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionslistWorkflowRunArtifactsResponse parses an HTTP response from a ActionslistWorkflowRunArtifactsWithResponse call
func ParseActionslistWorkflowRunArtifactsResponse(rsp *http.Response) (*ActionslistWorkflowRunArtifactsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistWorkflowRunArtifactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Artifacts  []Artifact `json:"artifacts"`
			TotalCount int        `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetWorkflowRunAttemptResponse parses an HTTP response from a ActionsgetWorkflowRunAttemptWithResponse call
func ParseActionsgetWorkflowRunAttemptResponse(rsp *http.Response) (*ActionsgetWorkflowRunAttemptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowRunAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionslistJobsForWorkflowRunAttemptResponse parses an HTTP response from a ActionslistJobsForWorkflowRunAttemptWithResponse call
func ParseActionslistJobsForWorkflowRunAttemptResponse(rsp *http.Response) (*ActionslistJobsForWorkflowRunAttemptResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistJobsForWorkflowRunAttemptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Jobs       []Job `json:"jobs"`
			TotalCount int   `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActionsdownloadWorkflowRunAttemptLogsResponse parses an HTTP response from a ActionsdownloadWorkflowRunAttemptLogsWithResponse call
func ParseActionsdownloadWorkflowRunAttemptLogsResponse(rsp *http.Response) (*ActionsdownloadWorkflowRunAttemptLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdownloadWorkflowRunAttemptLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionscancelWorkflowRunResponse parses an HTTP response from a ActionscancelWorkflowRunWithResponse call
func ParseActionscancelWorkflowRunResponse(rsp *http.Response) (*ActionscancelWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscancelWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseActionslistJobsForWorkflowRunResponse parses an HTTP response from a ActionslistJobsForWorkflowRunWithResponse call
func ParseActionslistJobsForWorkflowRunResponse(rsp *http.Response) (*ActionslistJobsForWorkflowRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistJobsForWorkflowRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Jobs       []Job `json:"jobs"`
			TotalCount int   `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteWorkflowRunLogsResponse parses an HTTP response from a ActionsdeleteWorkflowRunLogsWithResponse call
func ParseActionsdeleteWorkflowRunLogsResponse(rsp *http.Response) (*ActionsdeleteWorkflowRunLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteWorkflowRunLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseActionsdownloadWorkflowRunLogsResponse parses an HTTP response from a ActionsdownloadWorkflowRunLogsWithResponse call
func ParseActionsdownloadWorkflowRunLogsResponse(rsp *http.Response) (*ActionsdownloadWorkflowRunLogsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdownloadWorkflowRunLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetPendingDeploymentsForRunResponse parses an HTTP response from a ActionsgetPendingDeploymentsForRunWithResponse call
func ParseActionsgetPendingDeploymentsForRunResponse(rsp *http.Response) (*ActionsgetPendingDeploymentsForRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetPendingDeploymentsForRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PendingDeployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsreviewPendingDeploymentsForRunResponse parses an HTTP response from a ActionsreviewPendingDeploymentsForRunWithResponse call
func ParseActionsreviewPendingDeploymentsForRunResponse(rsp *http.Response) (*ActionsreviewPendingDeploymentsForRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsreviewPendingDeploymentsForRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsreRunWorkflowResponse parses an HTTP response from a ActionsreRunWorkflowWithResponse call
func ParseActionsreRunWorkflowResponse(rsp *http.Response) (*ActionsreRunWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsreRunWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionsreRunWorkflowFailedJobsResponse parses an HTTP response from a ActionsreRunWorkflowFailedJobsWithResponse call
func ParseActionsreRunWorkflowFailedJobsResponse(rsp *http.Response) (*ActionsreRunWorkflowFailedJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsreRunWorkflowFailedJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionsgetWorkflowRunUsageResponse parses an HTTP response from a ActionsgetWorkflowRunUsageWithResponse call
func ParseActionsgetWorkflowRunUsageResponse(rsp *http.Response) (*ActionsgetWorkflowRunUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowRunUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowRunUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionslistRepoSecretsResponse parses an HTTP response from a ActionslistRepoSecretsWithResponse call
func ParseActionslistRepoSecretsResponse(rsp *http.Response) (*ActionslistRepoSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistRepoSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []ActionsSecret `json:"secrets"`
			TotalCount int             `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetRepoPublicKeyResponse parses an HTTP response from a ActionsgetRepoPublicKeyWithResponse call
func ParseActionsgetRepoPublicKeyResponse(rsp *http.Response) (*ActionsgetRepoPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetRepoPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteRepoSecretResponse parses an HTTP response from a ActionsdeleteRepoSecretWithResponse call
func ParseActionsdeleteRepoSecretResponse(rsp *http.Response) (*ActionsdeleteRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetRepoSecretResponse parses an HTTP response from a ActionsgetRepoSecretWithResponse call
func ParseActionsgetRepoSecretResponse(rsp *http.Response) (*ActionsgetRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateOrUpdateRepoSecretResponse parses an HTTP response from a ActionscreateOrUpdateRepoSecretWithResponse call
func ParseActionscreateOrUpdateRepoSecretResponse(rsp *http.Response) (*ActionscreateOrUpdateRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateOrUpdateRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActionslistRepoWorkflowsResponse parses an HTTP response from a ActionslistRepoWorkflowsWithResponse call
func ParseActionslistRepoWorkflowsResponse(rsp *http.Response) (*ActionslistRepoWorkflowsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistRepoWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TotalCount int        `json:"total_count"`
			Workflows  []Workflow `json:"workflows"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetWorkflowResponse parses an HTTP response from a ActionsgetWorkflowWithResponse call
func ParseActionsgetWorkflowResponse(rsp *http.Response) (*ActionsgetWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Workflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdisableWorkflowResponse parses an HTTP response from a ActionsdisableWorkflowWithResponse call
func ParseActionsdisableWorkflowResponse(rsp *http.Response) (*ActionsdisableWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdisableWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionscreateWorkflowDispatchResponse parses an HTTP response from a ActionscreateWorkflowDispatchWithResponse call
func ParseActionscreateWorkflowDispatchResponse(rsp *http.Response) (*ActionscreateWorkflowDispatchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateWorkflowDispatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsenableWorkflowResponse parses an HTTP response from a ActionsenableWorkflowWithResponse call
func ParseActionsenableWorkflowResponse(rsp *http.Response) (*ActionsenableWorkflowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsenableWorkflowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionslistWorkflowRunsResponse parses an HTTP response from a ActionslistWorkflowRunsWithResponse call
func ParseActionslistWorkflowRunsResponse(rsp *http.Response) (*ActionslistWorkflowRunsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistWorkflowRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			TotalCount   int           `json:"total_count"`
			WorkflowRuns []WorkflowRun `json:"workflow_runs"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetWorkflowUsageResponse parses an HTTP response from a ActionsgetWorkflowUsageWithResponse call
func ParseActionsgetWorkflowUsageResponse(rsp *http.Response) (*ActionsgetWorkflowUsageResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetWorkflowUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueslistAssigneesResponse parses an HTTP response from a IssueslistAssigneesWithResponse call
func ParseIssueslistAssigneesResponse(rsp *http.Response) (*IssueslistAssigneesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistAssigneesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuescheckUserCanBeAssignedResponse parses an HTTP response from a IssuescheckUserCanBeAssignedWithResponse call
func ParseIssuescheckUserCanBeAssignedResponse(rsp *http.Response) (*IssuescheckUserCanBeAssignedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuescheckUserCanBeAssignedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistAutolinksResponse parses an HTTP response from a ReposlistAutolinksWithResponse call
func ParseReposlistAutolinksResponse(rsp *http.Response) (*ReposlistAutolinksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistAutolinksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Autolink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateAutolinkResponse parses an HTTP response from a ReposcreateAutolinkWithResponse call
func ParseReposcreateAutolinkResponse(rsp *http.Response) (*ReposcreateAutolinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateAutolinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Autolink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteAutolinkResponse parses an HTTP response from a ReposdeleteAutolinkWithResponse call
func ParseReposdeleteAutolinkResponse(rsp *http.Response) (*ReposdeleteAutolinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteAutolinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetAutolinkResponse parses an HTTP response from a ReposgetAutolinkWithResponse call
func ParseReposgetAutolinkResponse(rsp *http.Response) (*ReposgetAutolinkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAutolinkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Autolink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdisableAutomatedSecurityFixesResponse parses an HTTP response from a ReposdisableAutomatedSecurityFixesWithResponse call
func ParseReposdisableAutomatedSecurityFixesResponse(rsp *http.Response) (*ReposdisableAutomatedSecurityFixesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdisableAutomatedSecurityFixesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposenableAutomatedSecurityFixesResponse parses an HTTP response from a ReposenableAutomatedSecurityFixesWithResponse call
func ParseReposenableAutomatedSecurityFixesResponse(rsp *http.Response) (*ReposenableAutomatedSecurityFixesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposenableAutomatedSecurityFixesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposlistBranchesResponse parses an HTTP response from a ReposlistBranchesWithResponse call
func ParseReposlistBranchesResponse(rsp *http.Response) (*ReposlistBranchesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistBranchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ShortBranch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetBranchResponse parses an HTTP response from a ReposgetBranchWithResponse call
func ParseReposgetBranchResponse(rsp *http.Response) (*ReposgetBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchWithProtection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdeleteBranchProtectionResponse parses an HTTP response from a ReposdeleteBranchProtectionWithResponse call
func ParseReposdeleteBranchProtectionResponse(rsp *http.Response) (*ReposdeleteBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReposgetBranchProtectionResponse parses an HTTP response from a ReposgetBranchProtectionWithResponse call
func ParseReposgetBranchProtectionResponse(rsp *http.Response) (*ReposgetBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchProtection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateBranchProtectionResponse parses an HTTP response from a ReposupdateBranchProtectionWithResponse call
func ParseReposupdateBranchProtectionResponse(rsp *http.Response) (*ReposupdateBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteAdminBranchProtectionResponse parses an HTTP response from a ReposdeleteAdminBranchProtectionWithResponse call
func ParseReposdeleteAdminBranchProtectionResponse(rsp *http.Response) (*ReposdeleteAdminBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteAdminBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetAdminBranchProtectionResponse parses an HTTP response from a ReposgetAdminBranchProtectionWithResponse call
func ParseReposgetAdminBranchProtectionResponse(rsp *http.Response) (*ReposgetAdminBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAdminBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchAdminEnforced
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRepossetAdminBranchProtectionResponse parses an HTTP response from a RepossetAdminBranchProtectionWithResponse call
func ParseRepossetAdminBranchProtectionResponse(rsp *http.Response) (*RepossetAdminBranchProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepossetAdminBranchProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchAdminEnforced
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposdeletePullRequestReviewProtectionResponse parses an HTTP response from a ReposdeletePullRequestReviewProtectionWithResponse call
func ParseReposdeletePullRequestReviewProtectionResponse(rsp *http.Response) (*ReposdeletePullRequestReviewProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeletePullRequestReviewProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetPullRequestReviewProtectionResponse parses an HTTP response from a ReposgetPullRequestReviewProtectionWithResponse call
func ParseReposgetPullRequestReviewProtectionResponse(rsp *http.Response) (*ReposgetPullRequestReviewProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetPullRequestReviewProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchPullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposupdatePullRequestReviewProtectionResponse parses an HTTP response from a ReposupdatePullRequestReviewProtectionWithResponse call
func ParseReposupdatePullRequestReviewProtectionResponse(rsp *http.Response) (*ReposupdatePullRequestReviewProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdatePullRequestReviewProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchPullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteCommitSignatureProtectionResponse parses an HTTP response from a ReposdeleteCommitSignatureProtectionWithResponse call
func ParseReposdeleteCommitSignatureProtectionResponse(rsp *http.Response) (*ReposdeleteCommitSignatureProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteCommitSignatureProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetCommitSignatureProtectionResponse parses an HTTP response from a ReposgetCommitSignatureProtectionWithResponse call
func ParseReposgetCommitSignatureProtectionResponse(rsp *http.Response) (*ReposgetCommitSignatureProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommitSignatureProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchAdminEnforced
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateCommitSignatureProtectionResponse parses an HTTP response from a ReposcreateCommitSignatureProtectionWithResponse call
func ParseReposcreateCommitSignatureProtectionResponse(rsp *http.Response) (*ReposcreateCommitSignatureProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateCommitSignatureProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProtectedBranchAdminEnforced
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposremoveStatusCheckProtectionResponse parses an HTTP response from a ReposremoveStatusCheckProtectionWithResponse call
func ParseReposremoveStatusCheckProtectionResponse(rsp *http.Response) (*ReposremoveStatusCheckProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveStatusCheckProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetStatusChecksProtectionResponse parses an HTTP response from a ReposgetStatusChecksProtectionWithResponse call
func ParseReposgetStatusChecksProtectionResponse(rsp *http.Response) (*ReposgetStatusChecksProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetStatusChecksProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusCheckPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateStatusCheckProtectionResponse parses an HTTP response from a ReposupdateStatusCheckProtectionWithResponse call
func ParseReposupdateStatusCheckProtectionResponse(rsp *http.Response) (*ReposupdateStatusCheckProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateStatusCheckProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StatusCheckPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposremoveStatusCheckContextsResponse parses an HTTP response from a ReposremoveStatusCheckContextsWithResponse call
func ParseReposremoveStatusCheckContextsResponse(rsp *http.Response) (*ReposremoveStatusCheckContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveStatusCheckContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetAllStatusCheckContextsResponse parses an HTTP response from a ReposgetAllStatusCheckContextsWithResponse call
func ParseReposgetAllStatusCheckContextsResponse(rsp *http.Response) (*ReposgetAllStatusCheckContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAllStatusCheckContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposaddStatusCheckContextsResponse parses an HTTP response from a ReposaddStatusCheckContextsWithResponse call
func ParseReposaddStatusCheckContextsResponse(rsp *http.Response) (*ReposaddStatusCheckContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposaddStatusCheckContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepossetStatusCheckContextsResponse parses an HTTP response from a RepossetStatusCheckContextsWithResponse call
func ParseRepossetStatusCheckContextsResponse(rsp *http.Response) (*RepossetStatusCheckContextsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepossetStatusCheckContextsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteAccessRestrictionsResponse parses an HTTP response from a ReposdeleteAccessRestrictionsWithResponse call
func ParseReposdeleteAccessRestrictionsResponse(rsp *http.Response) (*ReposdeleteAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetAccessRestrictionsResponse parses an HTTP response from a ReposgetAccessRestrictionsWithResponse call
func ParseReposgetAccessRestrictionsResponse(rsp *http.Response) (*ReposgetAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BranchRestrictionPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposremoveAppAccessRestrictionsResponse parses an HTTP response from a ReposremoveAppAccessRestrictionsWithResponse call
func ParseReposremoveAppAccessRestrictionsResponse(rsp *http.Response) (*ReposremoveAppAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveAppAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetAppsWithAccessToProtectedBranchResponse parses an HTTP response from a ReposgetAppsWithAccessToProtectedBranchWithResponse call
func ParseReposgetAppsWithAccessToProtectedBranchResponse(rsp *http.Response) (*ReposgetAppsWithAccessToProtectedBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAppsWithAccessToProtectedBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposaddAppAccessRestrictionsResponse parses an HTTP response from a ReposaddAppAccessRestrictionsWithResponse call
func ParseReposaddAppAccessRestrictionsResponse(rsp *http.Response) (*ReposaddAppAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposaddAppAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepossetAppAccessRestrictionsResponse parses an HTTP response from a RepossetAppAccessRestrictionsWithResponse call
func ParseRepossetAppAccessRestrictionsResponse(rsp *http.Response) (*RepossetAppAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepossetAppAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Integration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposremoveTeamAccessRestrictionsResponse parses an HTTP response from a ReposremoveTeamAccessRestrictionsWithResponse call
func ParseReposremoveTeamAccessRestrictionsResponse(rsp *http.Response) (*ReposremoveTeamAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveTeamAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetTeamsWithAccessToProtectedBranchResponse parses an HTTP response from a ReposgetTeamsWithAccessToProtectedBranchWithResponse call
func ParseReposgetTeamsWithAccessToProtectedBranchResponse(rsp *http.Response) (*ReposgetTeamsWithAccessToProtectedBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetTeamsWithAccessToProtectedBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposaddTeamAccessRestrictionsResponse parses an HTTP response from a ReposaddTeamAccessRestrictionsWithResponse call
func ParseReposaddTeamAccessRestrictionsResponse(rsp *http.Response) (*ReposaddTeamAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposaddTeamAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepossetTeamAccessRestrictionsResponse parses an HTTP response from a RepossetTeamAccessRestrictionsWithResponse call
func ParseRepossetTeamAccessRestrictionsResponse(rsp *http.Response) (*RepossetTeamAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepossetTeamAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposremoveUserAccessRestrictionsResponse parses an HTTP response from a ReposremoveUserAccessRestrictionsWithResponse call
func ParseReposremoveUserAccessRestrictionsResponse(rsp *http.Response) (*ReposremoveUserAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveUserAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetUsersWithAccessToProtectedBranchResponse parses an HTTP response from a ReposgetUsersWithAccessToProtectedBranchWithResponse call
func ParseReposgetUsersWithAccessToProtectedBranchResponse(rsp *http.Response) (*ReposgetUsersWithAccessToProtectedBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetUsersWithAccessToProtectedBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposaddUserAccessRestrictionsResponse parses an HTTP response from a ReposaddUserAccessRestrictionsWithResponse call
func ParseReposaddUserAccessRestrictionsResponse(rsp *http.Response) (*ReposaddUserAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposaddUserAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseRepossetUserAccessRestrictionsResponse parses an HTTP response from a RepossetUserAccessRestrictionsWithResponse call
func ParseRepossetUserAccessRestrictionsResponse(rsp *http.Response) (*RepossetUserAccessRestrictionsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepossetUserAccessRestrictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposrenameBranchResponse parses an HTTP response from a ReposrenameBranchWithResponse call
func ParseReposrenameBranchResponse(rsp *http.Response) (*ReposrenameBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposrenameBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BranchWithProtection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCheckscreateResponse parses an HTTP response from a CheckscreateWithResponse call
func ParseCheckscreateResponse(rsp *http.Response) (*CheckscreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckscreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CheckRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseChecksgetResponse parses an HTTP response from a ChecksgetWithResponse call
func ParseChecksgetResponse(rsp *http.Response) (*ChecksgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChecksgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChecksupdateResponse parses an HTTP response from a ChecksupdateWithResponse call
func ParseChecksupdateResponse(rsp *http.Response) (*ChecksupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChecksupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckslistAnnotationsResponse parses an HTTP response from a CheckslistAnnotationsWithResponse call
func ParseCheckslistAnnotationsResponse(rsp *http.Response) (*CheckslistAnnotationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckslistAnnotationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CheckAnnotation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChecksrerequestRunResponse parses an HTTP response from a ChecksrerequestRunWithResponse call
func ParseChecksrerequestRunResponse(rsp *http.Response) (*ChecksrerequestRunResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChecksrerequestRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCheckscreateSuiteResponse parses an HTTP response from a CheckscreateSuiteWithResponse call
func ParseCheckscreateSuiteResponse(rsp *http.Response) (*CheckscreateSuiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckscreateSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CheckSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCheckssetSuitesPreferencesResponse parses an HTTP response from a CheckssetSuitesPreferencesWithResponse call
func ParseCheckssetSuitesPreferencesResponse(rsp *http.Response) (*CheckssetSuitesPreferencesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckssetSuitesPreferencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckSuitePreference
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChecksgetSuiteResponse parses an HTTP response from a ChecksgetSuiteWithResponse call
func ParseChecksgetSuiteResponse(rsp *http.Response) (*ChecksgetSuiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChecksgetSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckSuite
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckslistForSuiteResponse parses an HTTP response from a CheckslistForSuiteWithResponse call
func ParseCheckslistForSuiteResponse(rsp *http.Response) (*CheckslistForSuiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckslistForSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CheckRuns  []CheckRun `json:"check_runs"`
			TotalCount int        `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChecksrerequestSuiteResponse parses an HTTP response from a ChecksrerequestSuiteWithResponse call
func ParseChecksrerequestSuiteResponse(rsp *http.Response) (*ChecksrerequestSuiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChecksrerequestSuiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseCodeScanninglistAlertsForRepoResponse parses an HTTP response from a CodeScanninglistAlertsForRepoWithResponse call
func ParseCodeScanninglistAlertsForRepoResponse(rsp *http.Response) (*CodeScanninglistAlertsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninglistAlertsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeScanningAlertItems
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanninggetAlertResponse parses an HTTP response from a CodeScanninggetAlertWithResponse call
func ParseCodeScanninggetAlertResponse(rsp *http.Response) (*CodeScanninggetAlertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninggetAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanningupdateAlertResponse parses an HTTP response from a CodeScanningupdateAlertWithResponse call
func ParseCodeScanningupdateAlertResponse(rsp *http.Response) (*CodeScanningupdateAlertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanningupdateAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanninglistAlertInstancesResponse parses an HTTP response from a CodeScanninglistAlertInstancesWithResponse call
func ParseCodeScanninglistAlertInstancesResponse(rsp *http.Response) (*CodeScanninglistAlertInstancesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninglistAlertInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeScanningAlertInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanninglistRecentAnalysesResponse parses an HTTP response from a CodeScanninglistRecentAnalysesWithResponse call
func ParseCodeScanninglistRecentAnalysesResponse(rsp *http.Response) (*CodeScanninglistRecentAnalysesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninglistRecentAnalysesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeScanningAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanningdeleteAnalysisResponse parses an HTTP response from a CodeScanningdeleteAnalysisWithResponse call
func ParseCodeScanningdeleteAnalysisResponse(rsp *http.Response) (*CodeScanningdeleteAnalysisResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanningdeleteAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeScanningAnalysisDeletion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseCodeScanninggetAnalysisResponse parses an HTTP response from a CodeScanninggetAnalysisWithResponse call
func ParseCodeScanninggetAnalysisResponse(rsp *http.Response) (*CodeScanninggetAnalysisResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninggetAnalysisResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeScanningAnalysis
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/json+sarif) unsupported

	}

	return response, nil
}

// ParseCodeScanninguploadSarifResponse parses an HTTP response from a CodeScanninguploadSarifWithResponse call
func ParseCodeScanninguploadSarifResponse(rsp *http.Response) (*CodeScanninguploadSarifResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninguploadSarifResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CodeScanningSarifsReceipt
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseCodeScanninggetSarifResponse parses an HTTP response from a CodeScanninggetSarifWithResponse call
func ParseCodeScanninggetSarifResponse(rsp *http.Response) (*CodeScanninggetSarifResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodeScanninggetSarifResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeScanningSarifsStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReposcodeownersErrorsResponse parses an HTTP response from a ReposcodeownersErrorsWithResponse call
func ParseReposcodeownersErrorsResponse(rsp *http.Response) (*ReposcodeownersErrorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcodeownersErrorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodeownersErrors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespaceslistInRepositoryForAuthenticatedUserResponse parses an HTTP response from a CodespaceslistInRepositoryForAuthenticatedUserWithResponse call
func ParseCodespaceslistInRepositoryForAuthenticatedUserResponse(rsp *http.Response) (*CodespaceslistInRepositoryForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistInRepositoryForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Codespaces []Codespace `json:"codespaces"`
			TotalCount int         `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacescreateWithRepoForAuthenticatedUserResponse parses an HTTP response from a CodespacescreateWithRepoForAuthenticatedUserWithResponse call
func ParseCodespacescreateWithRepoForAuthenticatedUserResponse(rsp *http.Response) (*CodespacescreateWithRepoForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescreateWithRepoForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse parses an HTTP response from a CodespaceslistDevcontainersInRepositoryForAuthenticatedUserWithResponse call
func ParseCodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse(rsp *http.Response) (*CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistDevcontainersInRepositoryForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Devcontainers []struct {
				Name *string `json:"name,omitempty"`
				Path string  `json:"path"`
			} `json:"devcontainers"`
			TotalCount int `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseCodespacesrepoMachinesForAuthenticatedUserResponse parses an HTTP response from a CodespacesrepoMachinesForAuthenticatedUserWithResponse call
func ParseCodespacesrepoMachinesForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesrepoMachinesForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesrepoMachinesForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Machines   []CodespaceMachine `json:"machines"`
			TotalCount int                `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespaceslistRepoSecretsResponse parses an HTTP response from a CodespaceslistRepoSecretsWithResponse call
func ParseCodespaceslistRepoSecretsResponse(rsp *http.Response) (*CodespaceslistRepoSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistRepoSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []RepoCodespacesSecret `json:"secrets"`
			TotalCount int                    `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacesgetRepoPublicKeyResponse parses an HTTP response from a CodespacesgetRepoPublicKeyWithResponse call
func ParseCodespacesgetRepoPublicKeyResponse(rsp *http.Response) (*CodespacesgetRepoPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetRepoPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodespacesPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacesdeleteRepoSecretResponse parses an HTTP response from a CodespacesdeleteRepoSecretWithResponse call
func ParseCodespacesdeleteRepoSecretResponse(rsp *http.Response) (*CodespacesdeleteRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesdeleteRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCodespacesgetRepoSecretResponse parses an HTTP response from a CodespacesgetRepoSecretWithResponse call
func ParseCodespacesgetRepoSecretResponse(rsp *http.Response) (*CodespacesgetRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepoCodespacesSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacescreateOrUpdateRepoSecretResponse parses an HTTP response from a CodespacescreateOrUpdateRepoSecretWithResponse call
func ParseCodespacescreateOrUpdateRepoSecretResponse(rsp *http.Response) (*CodespacescreateOrUpdateRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescreateOrUpdateRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReposlistCollaboratorsResponse parses an HTTP response from a ReposlistCollaboratorsWithResponse call
func ParseReposlistCollaboratorsResponse(rsp *http.Response) (*ReposlistCollaboratorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistCollaboratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Collaborator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposremoveCollaboratorResponse parses an HTTP response from a ReposremoveCollaboratorWithResponse call
func ParseReposremoveCollaboratorResponse(rsp *http.Response) (*ReposremoveCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposremoveCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposcheckCollaboratorResponse parses an HTTP response from a ReposcheckCollaboratorWithResponse call
func ParseReposcheckCollaboratorResponse(rsp *http.Response) (*ReposcheckCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcheckCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposaddCollaboratorResponse parses an HTTP response from a ReposaddCollaboratorWithResponse call
func ParseReposaddCollaboratorResponse(rsp *http.Response) (*ReposaddCollaboratorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposaddCollaboratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RepositoryInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetCollaboratorPermissionLevelResponse parses an HTTP response from a ReposgetCollaboratorPermissionLevelWithResponse call
func ParseReposgetCollaboratorPermissionLevelResponse(rsp *http.Response) (*ReposgetCollaboratorPermissionLevelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCollaboratorPermissionLevelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryCollaboratorPermission
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistCommitCommentsForRepoResponse parses an HTTP response from a ReposlistCommitCommentsForRepoWithResponse call
func ParseReposlistCommitCommentsForRepoResponse(rsp *http.Response) (*ReposlistCommitCommentsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistCommitCommentsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CommitComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposdeleteCommitCommentResponse parses an HTTP response from a ReposdeleteCommitCommentWithResponse call
func ParseReposdeleteCommitCommentResponse(rsp *http.Response) (*ReposdeleteCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetCommitCommentResponse parses an HTTP response from a ReposgetCommitCommentWithResponse call
func ParseReposgetCommitCommentResponse(rsp *http.Response) (*ReposgetCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateCommitCommentResponse parses an HTTP response from a ReposupdateCommitCommentWithResponse call
func ParseReposupdateCommitCommentResponse(rsp *http.Response) (*ReposupdateCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReactionslistForCommitCommentResponse parses an HTTP response from a ReactionslistForCommitCommentWithResponse call
func ParseReactionslistForCommitCommentResponse(rsp *http.Response) (*ReactionslistForCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReactionscreateForCommitCommentResponse parses an HTTP response from a ReactionscreateForCommitCommentWithResponse call
func ParseReactionscreateForCommitCommentResponse(rsp *http.Response) (*ReactionscreateForCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForCommitCommentResponse parses an HTTP response from a ReactionsdeleteForCommitCommentWithResponse call
func ParseReactionsdeleteForCommitCommentResponse(rsp *http.Response) (*ReactionsdeleteForCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposlistCommitsResponse parses an HTTP response from a ReposlistCommitsWithResponse call
func ParseReposlistCommitsResponse(rsp *http.Response) (*ReposlistCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposlistBranchesForHeadCommitResponse parses an HTTP response from a ReposlistBranchesForHeadCommitWithResponse call
func ParseReposlistBranchesForHeadCommitResponse(rsp *http.Response) (*ReposlistBranchesForHeadCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistBranchesForHeadCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BranchShort
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposlistCommentsForCommitResponse parses an HTTP response from a ReposlistCommentsForCommitWithResponse call
func ParseReposlistCommentsForCommitResponse(rsp *http.Response) (*ReposlistCommentsForCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistCommentsForCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CommitComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateCommitCommentResponse parses an HTTP response from a ReposcreateCommitCommentWithResponse call
func ParseReposcreateCommitCommentResponse(rsp *http.Response) (*ReposcreateCommitCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateCommitCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CommitComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposlistPullRequestsAssociatedWithCommitResponse parses an HTTP response from a ReposlistPullRequestsAssociatedWithCommitWithResponse call
func ParseReposlistPullRequestsAssociatedWithCommitResponse(rsp *http.Response) (*ReposlistPullRequestsAssociatedWithCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistPullRequestsAssociatedWithCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PullRequestSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetCommitResponse parses an HTTP response from a ReposgetCommitWithResponse call
func ParseReposgetCommitResponse(rsp *http.Response) (*ReposgetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCheckslistForRefResponse parses an HTTP response from a CheckslistForRefWithResponse call
func ParseCheckslistForRefResponse(rsp *http.Response) (*CheckslistForRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckslistForRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CheckRuns  []CheckRun `json:"check_runs"`
			TotalCount int        `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckslistSuitesForRefResponse parses an HTTP response from a CheckslistSuitesForRefWithResponse call
func ParseCheckslistSuitesForRefResponse(rsp *http.Response) (*CheckslistSuitesForRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckslistSuitesForRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CheckSuites []CheckSuite `json:"check_suites"`
			TotalCount  int          `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetCombinedStatusForRefResponse parses an HTTP response from a ReposgetCombinedStatusForRefWithResponse call
func ParseReposgetCombinedStatusForRefResponse(rsp *http.Response) (*ReposgetCombinedStatusForRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCombinedStatusForRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CombinedCommitStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistCommitStatusesForRefResponse parses an HTTP response from a ReposlistCommitStatusesForRefWithResponse call
func ParseReposlistCommitStatusesForRefResponse(rsp *http.Response) (*ReposlistCommitStatusesForRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistCommitStatusesForRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	}

	return response, nil
}

// ParseReposgetCommunityProfileMetricsResponse parses an HTTP response from a ReposgetCommunityProfileMetricsWithResponse call
func ParseReposgetCommunityProfileMetricsResponse(rsp *http.Response) (*ReposgetCommunityProfileMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommunityProfileMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommunityProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcompareCommitsResponse parses an HTTP response from a ReposcompareCommitsWithResponse call
func ParseReposcompareCommitsResponse(rsp *http.Response) (*ReposcompareCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcompareCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CommitComparison
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseReposdeleteFileResponse parses an HTTP response from a ReposdeleteFileWithResponse call
func ParseReposdeleteFileResponse(rsp *http.Response) (*ReposdeleteFileResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseReposgetContentResponse parses an HTTP response from a ReposgetContentWithResponse call
func ParseReposgetContentResponse(rsp *http.Response) (*ReposgetContentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.github.v3.object) unsupported

	}

	return response, nil
}

// ParseReposcreateOrUpdateFileContentsResponse parses an HTTP response from a ReposcreateOrUpdateFileContentsWithResponse call
func ParseReposcreateOrUpdateFileContentsResponse(rsp *http.Response) (*ReposcreateOrUpdateFileContentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateOrUpdateFileContentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FileCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FileCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposlistContributorsResponse parses an HTTP response from a ReposlistContributorsWithResponse call
func ParseReposlistContributorsResponse(rsp *http.Response) (*ReposlistContributorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistContributorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Contributor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDependabotlistRepoSecretsResponse parses an HTTP response from a DependabotlistRepoSecretsWithResponse call
func ParseDependabotlistRepoSecretsResponse(rsp *http.Response) (*DependabotlistRepoSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotlistRepoSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []DependabotSecret `json:"secrets"`
			TotalCount int                `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotgetRepoPublicKeyResponse parses an HTTP response from a DependabotgetRepoPublicKeyWithResponse call
func ParseDependabotgetRepoPublicKeyResponse(rsp *http.Response) (*DependabotgetRepoPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotgetRepoPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DependabotPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotdeleteRepoSecretResponse parses an HTTP response from a DependabotdeleteRepoSecretWithResponse call
func ParseDependabotdeleteRepoSecretResponse(rsp *http.Response) (*DependabotdeleteRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotdeleteRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDependabotgetRepoSecretResponse parses an HTTP response from a DependabotgetRepoSecretWithResponse call
func ParseDependabotgetRepoSecretResponse(rsp *http.Response) (*DependabotgetRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotgetRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DependabotSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDependabotcreateOrUpdateRepoSecretResponse parses an HTTP response from a DependabotcreateOrUpdateRepoSecretWithResponse call
func ParseDependabotcreateOrUpdateRepoSecretResponse(rsp *http.Response) (*DependabotcreateOrUpdateRepoSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependabotcreateOrUpdateRepoSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDependencyGraphdiffRangeResponse parses an HTTP response from a DependencyGraphdiffRangeWithResponse call
func ParseDependencyGraphdiffRangeResponse(rsp *http.Response) (*DependencyGraphdiffRangeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DependencyGraphdiffRangeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DependencyGraphDiff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistDeploymentsResponse parses an HTTP response from a ReposlistDeploymentsWithResponse call
func ParseReposlistDeploymentsResponse(rsp *http.Response) (*ReposlistDeploymentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistDeploymentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateDeploymentResponse parses an HTTP response from a ReposcreateDeploymentWithResponse call
func ParseReposcreateDeploymentResponse(rsp *http.Response) (*ReposcreateDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteDeploymentResponse parses an HTTP response from a ReposdeleteDeploymentWithResponse call
func ParseReposdeleteDeploymentResponse(rsp *http.Response) (*ReposdeleteDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetDeploymentResponse parses an HTTP response from a ReposgetDeploymentWithResponse call
func ParseReposgetDeploymentResponse(rsp *http.Response) (*ReposgetDeploymentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetDeploymentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Deployment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistDeploymentStatusesResponse parses an HTTP response from a ReposlistDeploymentStatusesWithResponse call
func ParseReposlistDeploymentStatusesResponse(rsp *http.Response) (*ReposlistDeploymentStatusesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistDeploymentStatusesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeploymentStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateDeploymentStatusResponse parses an HTTP response from a ReposcreateDeploymentStatusWithResponse call
func ParseReposcreateDeploymentStatusResponse(rsp *http.Response) (*ReposcreateDeploymentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DeploymentStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetDeploymentStatusResponse parses an HTTP response from a ReposgetDeploymentStatusWithResponse call
func ParseReposgetDeploymentStatusResponse(rsp *http.Response) (*ReposgetDeploymentStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetDeploymentStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeploymentStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateDispatchEventResponse parses an HTTP response from a ReposcreateDispatchEventWithResponse call
func ParseReposcreateDispatchEventResponse(rsp *http.Response) (*ReposcreateDispatchEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateDispatchEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetAllEnvironmentsResponse parses an HTTP response from a ReposgetAllEnvironmentsWithResponse call
func ParseReposgetAllEnvironmentsResponse(rsp *http.Response) (*ReposgetAllEnvironmentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAllEnvironmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Environments *[]Environment `json:"environments,omitempty"`

			// The number of environments in this repository
			TotalCount *int `json:"total_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposdeleteAnEnvironmentResponse parses an HTTP response from a ReposdeleteAnEnvironmentWithResponse call
func ParseReposdeleteAnEnvironmentResponse(rsp *http.Response) (*ReposdeleteAnEnvironmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteAnEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetEnvironmentResponse parses an HTTP response from a ReposgetEnvironmentWithResponse call
func ParseReposgetEnvironmentResponse(rsp *http.Response) (*ReposgetEnvironmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateOrUpdateEnvironmentResponse parses an HTTP response from a ReposcreateOrUpdateEnvironmentWithResponse call
func ParseReposcreateOrUpdateEnvironmentResponse(rsp *http.Response) (*ReposcreateOrUpdateEnvironmentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateOrUpdateEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActivitylistRepoEventsResponse parses an HTTP response from a ActivitylistRepoEventsWithResponse call
func ParseActivitylistRepoEventsResponse(rsp *http.Response) (*ActivitylistRepoEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistRepoEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistForksResponse parses an HTTP response from a ReposlistForksWithResponse call
func ParseReposlistForksResponse(rsp *http.Response) (*ReposlistForksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistForksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposcreateForkResponse parses an HTTP response from a ReposcreateForkWithResponse call
func ParseReposcreateForkResponse(rsp *http.Response) (*ReposcreateForkResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateForkResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FullRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseGitcreateBlobResponse parses an HTTP response from a GitcreateBlobWithResponse call
func ParseGitcreateBlobResponse(rsp *http.Response) (*GitcreateBlobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitcreateBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ShortBlob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitgetBlobResponse parses an HTTP response from a GitgetBlobWithResponse call
func ParseGitgetBlobResponse(rsp *http.Response) (*GitgetBlobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitgetBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitcreateCommitResponse parses an HTTP response from a GitcreateCommitWithResponse call
func ParseGitcreateCommitResponse(rsp *http.Response) (*GitcreateCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitcreateCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GitCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitgetCommitResponse parses an HTTP response from a GitgetCommitWithResponse call
func ParseGitgetCommitResponse(rsp *http.Response) (*GitgetCommitResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitgetCommitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitCommit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGitlistMatchingRefsResponse parses an HTTP response from a GitlistMatchingRefsWithResponse call
func ParseGitlistMatchingRefsResponse(rsp *http.Response) (*GitlistMatchingRefsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitlistMatchingRefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GitRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGitgetRefResponse parses an HTTP response from a GitgetRefWithResponse call
func ParseGitgetRefResponse(rsp *http.Response) (*GitgetRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitgetRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGitcreateRefResponse parses an HTTP response from a GitcreateRefWithResponse call
func ParseGitcreateRefResponse(rsp *http.Response) (*GitcreateRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitcreateRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GitRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitdeleteRefResponse parses an HTTP response from a GitdeleteRefWithResponse call
func ParseGitdeleteRefResponse(rsp *http.Response) (*GitdeleteRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitdeleteRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitupdateRefResponse parses an HTTP response from a GitupdateRefWithResponse call
func ParseGitupdateRefResponse(rsp *http.Response) (*GitupdateRefResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitupdateRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitRef
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitcreateTagResponse parses an HTTP response from a GitcreateTagWithResponse call
func ParseGitcreateTagResponse(rsp *http.Response) (*GitcreateTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitcreateTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GitTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitgetTagResponse parses an HTTP response from a GitgetTagWithResponse call
func ParseGitgetTagResponse(rsp *http.Response) (*GitgetTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitgetTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitTag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGitcreateTreeResponse parses an HTTP response from a GitcreateTreeWithResponse call
func ParseGitcreateTreeResponse(rsp *http.Response) (*GitcreateTreeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitcreateTreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GitTree
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGitgetTreeResponse parses an HTTP response from a GitgetTreeWithResponse call
func ParseGitgetTreeResponse(rsp *http.Response) (*GitgetTreeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GitgetTreeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitTree
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposlistWebhooksResponse parses an HTTP response from a ReposlistWebhooksWithResponse call
func ParseReposlistWebhooksResponse(rsp *http.Response) (*ReposlistWebhooksResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Hook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateWebhookResponse parses an HTTP response from a ReposcreateWebhookWithResponse call
func ParseReposcreateWebhookResponse(rsp *http.Response) (*ReposcreateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Hook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteWebhookResponse parses an HTTP response from a ReposdeleteWebhookWithResponse call
func ParseReposdeleteWebhookResponse(rsp *http.Response) (*ReposdeleteWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetWebhookResponse parses an HTTP response from a ReposgetWebhookWithResponse call
func ParseReposgetWebhookResponse(rsp *http.Response) (*ReposgetWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Hook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateWebhookResponse parses an HTTP response from a ReposupdateWebhookWithResponse call
func ParseReposupdateWebhookResponse(rsp *http.Response) (*ReposupdateWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Hook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetWebhookConfigForRepoResponse parses an HTTP response from a ReposgetWebhookConfigForRepoWithResponse call
func ParseReposgetWebhookConfigForRepoResponse(rsp *http.Response) (*ReposgetWebhookConfigForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetWebhookConfigForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposupdateWebhookConfigForRepoResponse parses an HTTP response from a ReposupdateWebhookConfigForRepoWithResponse call
func ParseReposupdateWebhookConfigForRepoResponse(rsp *http.Response) (*ReposupdateWebhookConfigForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateWebhookConfigForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookConfig
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistWebhookDeliveriesResponse parses an HTTP response from a ReposlistWebhookDeliveriesWithResponse call
func ParseReposlistWebhookDeliveriesResponse(rsp *http.Response) (*ReposlistWebhookDeliveriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistWebhookDeliveriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []HookDeliveryItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposgetWebhookDeliveryResponse parses an HTTP response from a ReposgetWebhookDeliveryWithResponse call
func ParseReposgetWebhookDeliveryResponse(rsp *http.Response) (*ReposgetWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HookDelivery
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposredeliverWebhookDeliveryResponse parses an HTTP response from a ReposredeliverWebhookDeliveryWithResponse call
func ParseReposredeliverWebhookDeliveryResponse(rsp *http.Response) (*ReposredeliverWebhookDeliveryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposredeliverWebhookDeliveryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseRepospingWebhookResponse parses an HTTP response from a RepospingWebhookWithResponse call
func ParseRepospingWebhookResponse(rsp *http.Response) (*RepospingWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepospingWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRepostestPushWebhookResponse parses an HTTP response from a RepostestPushWebhookWithResponse call
func ParseRepostestPushWebhookResponse(rsp *http.Response) (*RepostestPushWebhookResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepostestPushWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationscancelImportResponse parses an HTTP response from a MigrationscancelImportWithResponse call
func ParseMigrationscancelImportResponse(rsp *http.Response) (*MigrationscancelImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationscancelImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMigrationsgetImportStatusResponse parses an HTTP response from a MigrationsgetImportStatusWithResponse call
func ParseMigrationsgetImportStatusResponse(rsp *http.Response) (*MigrationsgetImportStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetImportStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Import
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsupdateImportResponse parses an HTTP response from a MigrationsupdateImportWithResponse call
func ParseMigrationsupdateImportResponse(rsp *http.Response) (*MigrationsupdateImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsupdateImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Import
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMigrationsstartImportResponse parses an HTTP response from a MigrationsstartImportWithResponse call
func ParseMigrationsstartImportResponse(rsp *http.Response) (*MigrationsstartImportResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsstartImportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Import
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationsgetCommitAuthorsResponse parses an HTTP response from a MigrationsgetCommitAuthorsWithResponse call
func ParseMigrationsgetCommitAuthorsResponse(rsp *http.Response) (*MigrationsgetCommitAuthorsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetCommitAuthorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PorterAuthor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsmapCommitAuthorResponse parses an HTTP response from a MigrationsmapCommitAuthorWithResponse call
func ParseMigrationsmapCommitAuthorResponse(rsp *http.Response) (*MigrationsmapCommitAuthorResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsmapCommitAuthorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PorterAuthor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationsgetLargeFilesResponse parses an HTTP response from a MigrationsgetLargeFilesWithResponse call
func ParseMigrationsgetLargeFilesResponse(rsp *http.Response) (*MigrationsgetLargeFilesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetLargeFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PorterLargeFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMigrationssetLfsPreferenceResponse parses an HTTP response from a MigrationssetLfsPreferenceWithResponse call
func ParseMigrationssetLfsPreferenceResponse(rsp *http.Response) (*MigrationssetLfsPreferenceResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationssetLfsPreferenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Import
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsgetRepoInstallationResponse parses an HTTP response from a AppsgetRepoInstallationWithResponse call
func ParseAppsgetRepoInstallationResponse(rsp *http.Response) (*AppsgetRepoInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetRepoInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInteractionsremoveRestrictionsForRepoResponse parses an HTTP response from a InteractionsremoveRestrictionsForRepoWithResponse call
func ParseInteractionsremoveRestrictionsForRepoResponse(rsp *http.Response) (*InteractionsremoveRestrictionsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsremoveRestrictionsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInteractionsgetRestrictionsForRepoResponse parses an HTTP response from a InteractionsgetRestrictionsForRepoWithResponse call
func ParseInteractionsgetRestrictionsForRepoResponse(rsp *http.Response) (*InteractionsgetRestrictionsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsgetRestrictionsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInteractionssetRestrictionsForRepoResponse parses an HTTP response from a InteractionssetRestrictionsForRepoWithResponse call
func ParseInteractionssetRestrictionsForRepoResponse(rsp *http.Response) (*InteractionssetRestrictionsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionssetRestrictionsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InteractionLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistInvitationsResponse parses an HTTP response from a ReposlistInvitationsWithResponse call
func ParseReposlistInvitationsResponse(rsp *http.Response) (*ReposlistInvitationsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistInvitationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RepositoryInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposdeleteInvitationResponse parses an HTTP response from a ReposdeleteInvitationWithResponse call
func ParseReposdeleteInvitationResponse(rsp *http.Response) (*ReposdeleteInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposupdateInvitationResponse parses an HTTP response from a ReposupdateInvitationWithResponse call
func ParseReposupdateInvitationResponse(rsp *http.Response) (*ReposupdateInvitationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositoryInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueslistForRepoResponse parses an HTTP response from a IssueslistForRepoWithResponse call
func ParseIssueslistForRepoResponse(rsp *http.Response) (*IssueslistForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuescreateResponse parses an HTTP response from a IssuescreateWithResponse call
func ParseIssuescreateResponse(rsp *http.Response) (*IssuescreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuescreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIssueslistCommentsForRepoResponse parses an HTTP response from a IssueslistCommentsForRepoWithResponse call
func ParseIssueslistCommentsForRepoResponse(rsp *http.Response) (*IssueslistCommentsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistCommentsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IssueComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesdeleteCommentResponse parses an HTTP response from a IssuesdeleteCommentWithResponse call
func ParseIssuesdeleteCommentResponse(rsp *http.Response) (*IssuesdeleteCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesdeleteCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssuesgetCommentResponse parses an HTTP response from a IssuesgetCommentWithResponse call
func ParseIssuesgetCommentResponse(rsp *http.Response) (*IssuesgetCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesgetCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuesupdateCommentResponse parses an HTTP response from a IssuesupdateCommentWithResponse call
func ParseIssuesupdateCommentResponse(rsp *http.Response) (*IssuesupdateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesupdateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionslistForIssueCommentResponse parses an HTTP response from a ReactionslistForIssueCommentWithResponse call
func ParseReactionslistForIssueCommentResponse(rsp *http.Response) (*ReactionslistForIssueCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForIssueCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReactionscreateForIssueCommentResponse parses an HTTP response from a ReactionscreateForIssueCommentWithResponse call
func ParseReactionscreateForIssueCommentResponse(rsp *http.Response) (*ReactionscreateForIssueCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForIssueCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForIssueCommentResponse parses an HTTP response from a ReactionsdeleteForIssueCommentWithResponse call
func ParseReactionsdeleteForIssueCommentResponse(rsp *http.Response) (*ReactionsdeleteForIssueCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForIssueCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueslistEventsForRepoResponse parses an HTTP response from a IssueslistEventsForRepoWithResponse call
func ParseIssueslistEventsForRepoResponse(rsp *http.Response) (*IssueslistEventsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistEventsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IssueEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesgetEventResponse parses an HTTP response from a IssuesgetEventWithResponse call
func ParseIssuesgetEventResponse(rsp *http.Response) (*IssuesgetEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesgetEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuesgetResponse parses an HTTP response from a IssuesgetWithResponse call
func ParseIssuesgetResponse(rsp *http.Response) (*IssuesgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuesupdateResponse parses an HTTP response from a IssuesupdateWithResponse call
func ParseIssuesupdateResponse(rsp *http.Response) (*IssuesupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 301:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON301 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseIssuesremoveAssigneesResponse parses an HTTP response from a IssuesremoveAssigneesWithResponse call
func ParseIssuesremoveAssigneesResponse(rsp *http.Response) (*IssuesremoveAssigneesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesremoveAssigneesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssuesaddAssigneesResponse parses an HTTP response from a IssuesaddAssigneesWithResponse call
func ParseIssuesaddAssigneesResponse(rsp *http.Response) (*IssuesaddAssigneesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesaddAssigneesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseIssueslistCommentsResponse parses an HTTP response from a IssueslistCommentsWithResponse call
func ParseIssueslistCommentsResponse(rsp *http.Response) (*IssueslistCommentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IssueComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuescreateCommentResponse parses an HTTP response from a IssuescreateCommentWithResponse call
func ParseIssuescreateCommentResponse(rsp *http.Response) (*IssuescreateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuescreateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IssueComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssueslistEventsResponse parses an HTTP response from a IssueslistEventsWithResponse call
func ParseIssueslistEventsResponse(rsp *http.Response) (*IssueslistEventsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []IssueEventForIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuesremoveAllLabelsResponse parses an HTTP response from a IssuesremoveAllLabelsWithResponse call
func ParseIssuesremoveAllLabelsResponse(rsp *http.Response) (*IssuesremoveAllLabelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesremoveAllLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssueslistLabelsOnIssueResponse parses an HTTP response from a IssueslistLabelsOnIssueWithResponse call
func ParseIssueslistLabelsOnIssueResponse(rsp *http.Response) (*IssueslistLabelsOnIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistLabelsOnIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuesaddLabelsResponse parses an HTTP response from a IssuesaddLabelsWithResponse call
func ParseIssuesaddLabelsResponse(rsp *http.Response) (*IssuesaddLabelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesaddLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuessetLabelsResponse parses an HTTP response from a IssuessetLabelsWithResponse call
func ParseIssuessetLabelsResponse(rsp *http.Response) (*IssuessetLabelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuessetLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesremoveLabelResponse parses an HTTP response from a IssuesremoveLabelWithResponse call
func ParseIssuesremoveLabelResponse(rsp *http.Response) (*IssuesremoveLabelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesremoveLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseIssuesunlockResponse parses an HTTP response from a IssuesunlockWithResponse call
func ParseIssuesunlockResponse(rsp *http.Response) (*IssuesunlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesunlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssueslockResponse parses an HTTP response from a IssueslockWithResponse call
func ParseIssueslockResponse(rsp *http.Response) (*IssueslockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionslistForIssueResponse parses an HTTP response from a ReactionslistForIssueWithResponse call
func ParseReactionslistForIssueResponse(rsp *http.Response) (*ReactionslistForIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseReactionscreateForIssueResponse parses an HTTP response from a ReactionscreateForIssueWithResponse call
func ParseReactionscreateForIssueResponse(rsp *http.Response) (*ReactionscreateForIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForIssueResponse parses an HTTP response from a ReactionsdeleteForIssueWithResponse call
func ParseReactionsdeleteForIssueResponse(rsp *http.Response) (*ReactionsdeleteForIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssueslistEventsForTimelineResponse parses an HTTP response from a IssueslistEventsForTimelineWithResponse call
func ParseIssueslistEventsForTimelineResponse(rsp *http.Response) (*IssueslistEventsForTimelineResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistEventsForTimelineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TimelineIssueEvents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	}

	return response, nil
}

// ParseReposlistDeployKeysResponse parses an HTTP response from a ReposlistDeployKeysWithResponse call
func ParseReposlistDeployKeysResponse(rsp *http.Response) (*ReposlistDeployKeysResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistDeployKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DeployKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateDeployKeyResponse parses an HTTP response from a ReposcreateDeployKeyWithResponse call
func ParseReposcreateDeployKeyResponse(rsp *http.Response) (*ReposcreateDeployKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateDeployKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DeployKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteDeployKeyResponse parses an HTTP response from a ReposdeleteDeployKeyWithResponse call
func ParseReposdeleteDeployKeyResponse(rsp *http.Response) (*ReposdeleteDeployKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteDeployKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetDeployKeyResponse parses an HTTP response from a ReposgetDeployKeyWithResponse call
func ParseReposgetDeployKeyResponse(rsp *http.Response) (*ReposgetDeployKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetDeployKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeployKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssueslistLabelsForRepoResponse parses an HTTP response from a IssueslistLabelsForRepoWithResponse call
func ParseIssueslistLabelsForRepoResponse(rsp *http.Response) (*IssueslistLabelsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistLabelsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuescreateLabelResponse parses an HTTP response from a IssuescreateLabelWithResponse call
func ParseIssuescreateLabelResponse(rsp *http.Response) (*IssuescreateLabelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuescreateLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesdeleteLabelResponse parses an HTTP response from a IssuesdeleteLabelWithResponse call
func ParseIssuesdeleteLabelResponse(rsp *http.Response) (*IssuesdeleteLabelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesdeleteLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIssuesgetLabelResponse parses an HTTP response from a IssuesgetLabelWithResponse call
func ParseIssuesgetLabelResponse(rsp *http.Response) (*IssuesgetLabelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesgetLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuesupdateLabelResponse parses an HTTP response from a IssuesupdateLabelWithResponse call
func ParseIssuesupdateLabelResponse(rsp *http.Response) (*IssuesupdateLabelResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesupdateLabelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistLanguagesResponse parses an HTTP response from a ReposlistLanguagesWithResponse call
func ParseReposlistLanguagesResponse(rsp *http.Response) (*ReposlistLanguagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistLanguagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Language
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposdisableLfsForRepoResponse parses an HTTP response from a ReposdisableLfsForRepoWithResponse call
func ParseReposdisableLfsForRepoResponse(rsp *http.Response) (*ReposdisableLfsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdisableLfsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposenableLfsForRepoResponse parses an HTTP response from a ReposenableLfsForRepoWithResponse call
func ParseReposenableLfsForRepoResponse(rsp *http.Response) (*ReposenableLfsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposenableLfsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseLicensesgetForRepoResponse parses an HTTP response from a LicensesgetForRepoWithResponse call
func ParseLicensesgetForRepoResponse(rsp *http.Response) (*LicensesgetForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LicensesgetForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LicenseContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposmergeUpstreamResponse parses an HTTP response from a ReposmergeUpstreamWithResponse call
func ParseReposmergeUpstreamResponse(rsp *http.Response) (*ReposmergeUpstreamResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposmergeUpstreamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MergedUpstream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposmergeResponse parses an HTTP response from a ReposmergeWithResponse call
func ParseReposmergeResponse(rsp *http.Response) (*ReposmergeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposmergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssueslistMilestonesResponse parses an HTTP response from a IssueslistMilestonesWithResponse call
func ParseIssueslistMilestonesResponse(rsp *http.Response) (*IssueslistMilestonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistMilestonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Milestone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuescreateMilestoneResponse parses an HTTP response from a IssuescreateMilestoneWithResponse call
func ParseIssuescreateMilestoneResponse(rsp *http.Response) (*IssuescreateMilestoneResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuescreateMilestoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Milestone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssuesdeleteMilestoneResponse parses an HTTP response from a IssuesdeleteMilestoneWithResponse call
func ParseIssuesdeleteMilestoneResponse(rsp *http.Response) (*IssuesdeleteMilestoneResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesdeleteMilestoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuesgetMilestoneResponse parses an HTTP response from a IssuesgetMilestoneWithResponse call
func ParseIssuesgetMilestoneResponse(rsp *http.Response) (*IssuesgetMilestoneResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesgetMilestoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Milestone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseIssuesupdateMilestoneResponse parses an HTTP response from a IssuesupdateMilestoneWithResponse call
func ParseIssuesupdateMilestoneResponse(rsp *http.Response) (*IssuesupdateMilestoneResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesupdateMilestoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Milestone
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseIssueslistLabelsForMilestoneResponse parses an HTTP response from a IssueslistLabelsForMilestoneWithResponse call
func ParseIssueslistLabelsForMilestoneResponse(rsp *http.Response) (*IssueslistLabelsForMilestoneResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistLabelsForMilestoneResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Label
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistRepoNotificationsForAuthenticatedUserResponse parses an HTTP response from a ActivitylistRepoNotificationsForAuthenticatedUserWithResponse call
func ParseActivitylistRepoNotificationsForAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistRepoNotificationsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistRepoNotificationsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Thread
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitymarkRepoNotificationsAsReadResponse parses an HTTP response from a ActivitymarkRepoNotificationsAsReadWithResponse call
func ParseActivitymarkRepoNotificationsAsReadResponse(rsp *http.Response) (*ActivitymarkRepoNotificationsAsReadResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitymarkRepoNotificationsAsReadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Url     *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseReposdeletePagesSiteResponse parses an HTTP response from a ReposdeletePagesSiteWithResponse call
func ParseReposdeletePagesSiteResponse(rsp *http.Response) (*ReposdeletePagesSiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeletePagesSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetPagesResponse parses an HTTP response from a ReposgetPagesWithResponse call
func ParseReposgetPagesResponse(rsp *http.Response) (*ReposgetPagesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetPagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreatePagesSiteResponse parses an HTTP response from a ReposcreatePagesSiteWithResponse call
func ParseReposcreatePagesSiteResponse(rsp *http.Response) (*ReposcreatePagesSiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreatePagesSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Page
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposupdateInformationAboutPagesSiteResponse parses an HTTP response from a ReposupdateInformationAboutPagesSiteWithResponse call
func ParseReposupdateInformationAboutPagesSiteResponse(rsp *http.Response) (*ReposupdateInformationAboutPagesSiteResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateInformationAboutPagesSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposlistPagesBuildsResponse parses an HTTP response from a ReposlistPagesBuildsWithResponse call
func ParseReposlistPagesBuildsResponse(rsp *http.Response) (*ReposlistPagesBuildsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistPagesBuildsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PageBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposrequestPagesBuildResponse parses an HTTP response from a ReposrequestPagesBuildWithResponse call
func ParseReposrequestPagesBuildResponse(rsp *http.Response) (*ReposrequestPagesBuildResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposrequestPagesBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PageBuildStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReposgetLatestPagesBuildResponse parses an HTTP response from a ReposgetLatestPagesBuildWithResponse call
func ParseReposgetLatestPagesBuildResponse(rsp *http.Response) (*ReposgetLatestPagesBuildResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetLatestPagesBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetPagesBuildResponse parses an HTTP response from a ReposgetPagesBuildWithResponse call
func ParseReposgetPagesBuildResponse(rsp *http.Response) (*ReposgetPagesBuildResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetPagesBuildResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PageBuild
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetPagesHealthCheckResponse parses an HTTP response from a ReposgetPagesHealthCheckWithResponse call
func ParseReposgetPagesHealthCheckResponse(rsp *http.Response) (*ReposgetPagesHealthCheckResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetPagesHealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PagesHealthCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectslistForRepoResponse parses an HTTP response from a ProjectslistForRepoWithResponse call
func ParseProjectslistForRepoResponse(rsp *http.Response) (*ProjectslistForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseProjectscreateForRepoResponse parses an HTTP response from a ProjectscreateForRepoWithResponse call
func ParseProjectscreateForRepoResponse(rsp *http.Response) (*ProjectscreateForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectscreateForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 410:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON410 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullslistResponse parses an HTTP response from a PullslistWithResponse call
func ParsePullslistResponse(rsp *http.Response) (*PullslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PullRequestSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullscreateResponse parses an HTTP response from a PullscreateWithResponse call
func ParsePullscreateResponse(rsp *http.Response) (*PullscreateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullscreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullslistReviewCommentsForRepoResponse parses an HTTP response from a PullslistReviewCommentsForRepoWithResponse call
func ParsePullslistReviewCommentsForRepoResponse(rsp *http.Response) (*PullslistReviewCommentsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistReviewCommentsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullsdeleteReviewCommentResponse parses an HTTP response from a PullsdeleteReviewCommentWithResponse call
func ParsePullsdeleteReviewCommentResponse(rsp *http.Response) (*PullsdeleteReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsdeleteReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullsgetReviewCommentResponse parses an HTTP response from a PullsgetReviewCommentWithResponse call
func ParsePullsgetReviewCommentResponse(rsp *http.Response) (*PullsgetReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsgetReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullsupdateReviewCommentResponse parses an HTTP response from a PullsupdateReviewCommentWithResponse call
func ParsePullsupdateReviewCommentResponse(rsp *http.Response) (*PullsupdateReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsupdateReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionslistForPullRequestReviewCommentResponse parses an HTTP response from a ReactionslistForPullRequestReviewCommentWithResponse call
func ParseReactionslistForPullRequestReviewCommentResponse(rsp *http.Response) (*ReactionslistForPullRequestReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForPullRequestReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReactionscreateForPullRequestReviewCommentResponse parses an HTTP response from a ReactionscreateForPullRequestReviewCommentWithResponse call
func ParseReactionscreateForPullRequestReviewCommentResponse(rsp *http.Response) (*ReactionscreateForPullRequestReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForPullRequestReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForPullRequestCommentResponse parses an HTTP response from a ReactionsdeleteForPullRequestCommentWithResponse call
func ParseReactionsdeleteForPullRequestCommentResponse(rsp *http.Response) (*ReactionsdeleteForPullRequestCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForPullRequestCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePullsgetResponse parses an HTTP response from a PullsgetWithResponse call
func ParsePullsgetResponse(rsp *http.Response) (*PullsgetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsgetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePullsupdateResponse parses an HTTP response from a PullsupdateWithResponse call
func ParsePullsupdateResponse(rsp *http.Response) (*PullsupdateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsupdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCodespacescreateWithPrForAuthenticatedUserResponse parses an HTTP response from a CodespacescreateWithPrForAuthenticatedUserWithResponse call
func ParseCodespacescreateWithPrForAuthenticatedUserResponse(rsp *http.Response) (*CodespacescreateWithPrForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescreateWithPrForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullslistReviewCommentsResponse parses an HTTP response from a PullslistReviewCommentsWithResponse call
func ParsePullslistReviewCommentsResponse(rsp *http.Response) (*PullslistReviewCommentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistReviewCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullscreateReviewCommentResponse parses an HTTP response from a PullscreateReviewCommentWithResponse call
func ParsePullscreateReviewCommentResponse(rsp *http.Response) (*PullscreateReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullscreateReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullscreateReplyForReviewCommentResponse parses an HTTP response from a PullscreateReplyForReviewCommentWithResponse call
func ParsePullscreateReplyForReviewCommentResponse(rsp *http.Response) (*PullscreateReplyForReviewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullscreateReplyForReviewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequestReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullslistCommitsResponse parses an HTTP response from a PullslistCommitsWithResponse call
func ParsePullslistCommitsResponse(rsp *http.Response) (*PullslistCommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistCommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Commit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullslistFilesResponse parses an HTTP response from a PullslistFilesWithResponse call
func ParsePullslistFilesResponse(rsp *http.Response) (*PullslistFilesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []DiffEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePullscheckIfMergedResponse parses an HTTP response from a PullscheckIfMergedWithResponse call
func ParsePullscheckIfMergedResponse(rsp *http.Response) (*PullscheckIfMergedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullscheckIfMergedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePullsmergeResponse parses an HTTP response from a PullsmergeWithResponse call
func ParsePullsmergeResponse(rsp *http.Response) (*PullsmergeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsmergeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestMergeResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullsremoveRequestedReviewersResponse parses an HTTP response from a PullsremoveRequestedReviewersWithResponse call
func ParsePullsremoveRequestedReviewersResponse(rsp *http.Response) (*PullsremoveRequestedReviewersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsremoveRequestedReviewersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullslistRequestedReviewersResponse parses an HTTP response from a PullslistRequestedReviewersWithResponse call
func ParsePullslistRequestedReviewersResponse(rsp *http.Response) (*PullslistRequestedReviewersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistRequestedReviewersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReviewRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullsrequestReviewersResponse parses an HTTP response from a PullsrequestReviewersWithResponse call
func ParsePullsrequestReviewersResponse(rsp *http.Response) (*PullsrequestReviewersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsrequestReviewersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PullRequestSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePullslistReviewsResponse parses an HTTP response from a PullslistReviewsWithResponse call
func ParsePullslistReviewsResponse(rsp *http.Response) (*PullslistReviewsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePullscreateReviewResponse parses an HTTP response from a PullscreateReviewWithResponse call
func ParsePullscreateReviewResponse(rsp *http.Response) (*PullscreateReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullscreateReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullsdeletePendingReviewResponse parses an HTTP response from a PullsdeletePendingReviewWithResponse call
func ParsePullsdeletePendingReviewResponse(rsp *http.Response) (*PullsdeletePendingReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsdeletePendingReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullsgetReviewResponse parses an HTTP response from a PullsgetReviewWithResponse call
func ParsePullsgetReviewResponse(rsp *http.Response) (*PullsgetReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsgetReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullsupdateReviewResponse parses an HTTP response from a PullsupdateReviewWithResponse call
func ParsePullsupdateReviewResponse(rsp *http.Response) (*PullsupdateReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsupdateReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullslistCommentsForReviewResponse parses an HTTP response from a PullslistCommentsForReviewWithResponse call
func ParsePullslistCommentsForReviewResponse(rsp *http.Response) (*PullslistCommentsForReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullslistCommentsForReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ReviewComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePullsdismissReviewResponse parses an HTTP response from a PullsdismissReviewWithResponse call
func ParsePullsdismissReviewResponse(rsp *http.Response) (*PullsdismissReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsdismissReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullssubmitReviewResponse parses an HTTP response from a PullssubmitReviewWithResponse call
func ParsePullssubmitReviewResponse(rsp *http.Response) (*PullssubmitReviewResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullssubmitReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PullRequestReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParsePullsupdateBranchResponse parses an HTTP response from a PullsupdateBranchWithResponse call
func ParsePullsupdateBranchResponse(rsp *http.Response) (*PullsupdateBranchResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PullsupdateBranchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Message *string `json:"message,omitempty"`
			Url     *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetReadmeResponse parses an HTTP response from a ReposgetReadmeWithResponse call
func ParseReposgetReadmeResponse(rsp *http.Response) (*ReposgetReadmeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetReadmeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetReadmeInDirectoryResponse parses an HTTP response from a ReposgetReadmeInDirectoryWithResponse call
func ParseReposgetReadmeInDirectoryResponse(rsp *http.Response) (*ReposgetReadmeInDirectoryResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetReadmeInDirectoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContentFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposlistReleasesResponse parses an HTTP response from a ReposlistReleasesWithResponse call
func ParseReposlistReleasesResponse(rsp *http.Response) (*ReposlistReleasesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistReleasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateReleaseResponse parses an HTTP response from a ReposcreateReleaseWithResponse call
func ParseReposcreateReleaseResponse(rsp *http.Response) (*ReposcreateReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposdeleteReleaseAssetResponse parses an HTTP response from a ReposdeleteReleaseAssetWithResponse call
func ParseReposdeleteReleaseAssetResponse(rsp *http.Response) (*ReposdeleteReleaseAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteReleaseAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetReleaseAssetResponse parses an HTTP response from a ReposgetReleaseAssetWithResponse call
func ParseReposgetReleaseAssetResponse(rsp *http.Response) (*ReposgetReleaseAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetReleaseAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReleaseAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateReleaseAssetResponse parses an HTTP response from a ReposupdateReleaseAssetWithResponse call
func ParseReposupdateReleaseAssetResponse(rsp *http.Response) (*ReposupdateReleaseAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateReleaseAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReleaseAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgenerateReleaseNotesResponse parses an HTTP response from a ReposgenerateReleaseNotesWithResponse call
func ParseReposgenerateReleaseNotesResponse(rsp *http.Response) (*ReposgenerateReleaseNotesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgenerateReleaseNotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReleaseNotesContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetLatestReleaseResponse parses an HTTP response from a ReposgetLatestReleaseWithResponse call
func ParseReposgetLatestReleaseResponse(rsp *http.Response) (*ReposgetLatestReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetLatestReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetReleaseByTagResponse parses an HTTP response from a ReposgetReleaseByTagWithResponse call
func ParseReposgetReleaseByTagResponse(rsp *http.Response) (*ReposgetReleaseByTagResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetReleaseByTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdeleteReleaseResponse parses an HTTP response from a ReposdeleteReleaseWithResponse call
func ParseReposdeleteReleaseResponse(rsp *http.Response) (*ReposdeleteReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposgetReleaseResponse parses an HTTP response from a ReposgetReleaseWithResponse call
func ParseReposgetReleaseResponse(rsp *http.Response) (*ReposgetReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposupdateReleaseResponse parses an HTTP response from a ReposupdateReleaseWithResponse call
func ParseReposupdateReleaseResponse(rsp *http.Response) (*ReposupdateReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposupdateReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Release
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistReleaseAssetsResponse parses an HTTP response from a ReposlistReleaseAssetsWithResponse call
func ParseReposlistReleaseAssetsResponse(rsp *http.Response) (*ReposlistReleaseAssetsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistReleaseAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ReleaseAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposuploadReleaseAssetResponse parses an HTTP response from a ReposuploadReleaseAssetWithResponse call
func ParseReposuploadReleaseAssetResponse(rsp *http.Response) (*ReposuploadReleaseAssetResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposuploadReleaseAssetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ReleaseAsset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReactionslistForReleaseResponse parses an HTTP response from a ReactionslistForReleaseWithResponse call
func ParseReactionslistForReleaseResponse(rsp *http.Response) (*ReactionslistForReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReactionscreateForReleaseResponse parses an HTTP response from a ReactionscreateForReleaseWithResponse call
func ParseReactionscreateForReleaseResponse(rsp *http.Response) (*ReactionscreateForReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReactionsdeleteForReleaseResponse parses an HTTP response from a ReactionsdeleteForReleaseWithResponse call
func ParseReactionsdeleteForReleaseResponse(rsp *http.Response) (*ReactionsdeleteForReleaseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionsdeleteForReleaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSecretScanninglistAlertsForRepoResponse parses an HTTP response from a SecretScanninglistAlertsForRepoWithResponse call
func ParseSecretScanninglistAlertsForRepoResponse(rsp *http.Response) (*SecretScanninglistAlertsForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanninglistAlertsForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SecretScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSecretScanninggetAlertResponse parses an HTTP response from a SecretScanninggetAlertWithResponse call
func ParseSecretScanninggetAlertResponse(rsp *http.Response) (*SecretScanninggetAlertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanninggetAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecretScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSecretScanningupdateAlertResponse parses an HTTP response from a SecretScanningupdateAlertWithResponse call
func ParseSecretScanningupdateAlertResponse(rsp *http.Response) (*SecretScanningupdateAlertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanningupdateAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecretScanningAlert
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSecretScanninglistLocationsForAlertResponse parses an HTTP response from a SecretScanninglistLocationsForAlertWithResponse call
func ParseSecretScanninglistLocationsForAlertResponse(rsp *http.Response) (*SecretScanninglistLocationsForAlertResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SecretScanninglistLocationsForAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SecretScanningLocation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseActivitylistStargazersForRepoResponse parses an HTTP response from a ActivitylistStargazersForRepoWithResponse call
func ParseActivitylistStargazersForRepoResponse(rsp *http.Response) (*ActivitylistStargazersForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistStargazersForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetCodeFrequencyStatsResponse parses an HTTP response from a ReposgetCodeFrequencyStatsWithResponse call
func ParseReposgetCodeFrequencyStatsResponse(rsp *http.Response) (*ReposgetCodeFrequencyStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCodeFrequencyStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeFrequencyStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseReposgetCommitActivityStatsResponse parses an HTTP response from a ReposgetCommitActivityStatsWithResponse call
func ParseReposgetCommitActivityStatsResponse(rsp *http.Response) (*ReposgetCommitActivityStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetCommitActivityStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CommitActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseReposgetContributorsStatsResponse parses an HTTP response from a ReposgetContributorsStatsWithResponse call
func ParseReposgetContributorsStatsResponse(rsp *http.Response) (*ReposgetContributorsStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetContributorsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ContributorActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseReposgetParticipationStatsResponse parses an HTTP response from a ReposgetParticipationStatsWithResponse call
func ParseReposgetParticipationStatsResponse(rsp *http.Response) (*ReposgetParticipationStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetParticipationStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ParticipationStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposgetPunchCardStatsResponse parses an HTTP response from a ReposgetPunchCardStatsWithResponse call
func ParseReposgetPunchCardStatsResponse(rsp *http.Response) (*ReposgetPunchCardStatsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetPunchCardStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CodeFrequencyStat
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposcreateCommitStatusResponse parses an HTTP response from a ReposcreateCommitStatusWithResponse call
func ParseReposcreateCommitStatusResponse(rsp *http.Response) (*ReposcreateCommitStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateCommitStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Status
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseActivitylistWatchersForRepoResponse parses an HTTP response from a ActivitylistWatchersForRepoWithResponse call
func ParseActivitylistWatchersForRepoResponse(rsp *http.Response) (*ActivitylistWatchersForRepoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistWatchersForRepoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitydeleteRepoSubscriptionResponse parses an HTTP response from a ActivitydeleteRepoSubscriptionWithResponse call
func ParseActivitydeleteRepoSubscriptionResponse(rsp *http.Response) (*ActivitydeleteRepoSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitydeleteRepoSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActivitygetRepoSubscriptionResponse parses an HTTP response from a ActivitygetRepoSubscriptionWithResponse call
func ParseActivitygetRepoSubscriptionResponse(rsp *http.Response) (*ActivitygetRepoSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitygetRepoSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositorySubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseActivitysetRepoSubscriptionResponse parses an HTTP response from a ActivitysetRepoSubscriptionWithResponse call
func ParseActivitysetRepoSubscriptionResponse(rsp *http.Response) (*ActivitysetRepoSubscriptionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitysetRepoSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RepositorySubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistTagsResponse parses an HTTP response from a ReposlistTagsWithResponse call
func ParseReposlistTagsResponse(rsp *http.Response) (*ReposlistTagsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Tag
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistTagProtectionResponse parses an HTTP response from a ReposlistTagProtectionWithResponse call
func ParseReposlistTagProtectionResponse(rsp *http.Response) (*ReposlistTagProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistTagProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TagProtection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposcreateTagProtectionResponse parses an HTTP response from a ReposcreateTagProtectionWithResponse call
func ParseReposcreateTagProtectionResponse(rsp *http.Response) (*ReposcreateTagProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateTagProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TagProtection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdeleteTagProtectionResponse parses an HTTP response from a ReposdeleteTagProtectionWithResponse call
func ParseReposdeleteTagProtectionResponse(rsp *http.Response) (*ReposdeleteTagProtectionResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeleteTagProtectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdownloadTarballArchiveResponse parses an HTTP response from a ReposdownloadTarballArchiveWithResponse call
func ParseReposdownloadTarballArchiveResponse(rsp *http.Response) (*ReposdownloadTarballArchiveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdownloadTarballArchiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposlistTeamsResponse parses an HTTP response from a ReposlistTeamsWithResponse call
func ParseReposlistTeamsResponse(rsp *http.Response) (*ReposlistTeamsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposgetAllTopicsResponse parses an HTTP response from a ReposgetAllTopicsWithResponse call
func ParseReposgetAllTopicsResponse(rsp *http.Response) (*ReposgetAllTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetAllTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Topic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposreplaceAllTopicsResponse parses an HTTP response from a ReposreplaceAllTopicsWithResponse call
func ParseReposreplaceAllTopicsResponse(rsp *http.Response) (*ReposreplaceAllTopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposreplaceAllTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Topic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposgetClonesResponse parses an HTTP response from a ReposgetClonesWithResponse call
func ParseReposgetClonesResponse(rsp *http.Response) (*ReposgetClonesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetClonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CloneTraffic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReposgetTopPathsResponse parses an HTTP response from a ReposgetTopPathsWithResponse call
func ParseReposgetTopPathsResponse(rsp *http.Response) (*ReposgetTopPathsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetTopPathsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ContentTraffic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReposgetTopReferrersResponse parses an HTTP response from a ReposgetTopReferrersWithResponse call
func ParseReposgetTopReferrersResponse(rsp *http.Response) (*ReposgetTopReferrersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetTopReferrersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ReferrerTraffic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseReposgetViewsResponse parses an HTTP response from a ReposgetViewsWithResponse call
func ParseReposgetViewsResponse(rsp *http.Response) (*ReposgetViewsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposgetViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ViewTraffic
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseRepostransferResponse parses an HTTP response from a RepostransferWithResponse call
func ParseRepostransferResponse(rsp *http.Response) (*RepostransferResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RepostransferResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseReposdisableVulnerabilityAlertsResponse parses an HTTP response from a ReposdisableVulnerabilityAlertsWithResponse call
func ParseReposdisableVulnerabilityAlertsResponse(rsp *http.Response) (*ReposdisableVulnerabilityAlertsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdisableVulnerabilityAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposcheckVulnerabilityAlertsResponse parses an HTTP response from a ReposcheckVulnerabilityAlertsWithResponse call
func ParseReposcheckVulnerabilityAlertsResponse(rsp *http.Response) (*ReposcheckVulnerabilityAlertsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcheckVulnerabilityAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposenableVulnerabilityAlertsResponse parses an HTTP response from a ReposenableVulnerabilityAlertsWithResponse call
func ParseReposenableVulnerabilityAlertsResponse(rsp *http.Response) (*ReposenableVulnerabilityAlertsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposenableVulnerabilityAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposdownloadZipballArchiveResponse parses an HTTP response from a ReposdownloadZipballArchiveWithResponse call
func ParseReposdownloadZipballArchiveResponse(rsp *http.Response) (*ReposdownloadZipballArchiveResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdownloadZipballArchiveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReposcreateUsingTemplateResponse parses an HTTP response from a ReposcreateUsingTemplateWithResponse call
func ParseReposcreateUsingTemplateResponse(rsp *http.Response) (*ReposcreateUsingTemplateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateUsingTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReposlistPublicResponse parses an HTTP response from a ReposlistPublicWithResponse call
func ParseReposlistPublicResponse(rsp *http.Response) (*ReposlistPublicResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistPublicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActionslistEnvironmentSecretsResponse parses an HTTP response from a ActionslistEnvironmentSecretsWithResponse call
func ParseActionslistEnvironmentSecretsResponse(rsp *http.Response) (*ActionslistEnvironmentSecretsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionslistEnvironmentSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []ActionsSecret `json:"secrets"`
			TotalCount int             `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsgetEnvironmentPublicKeyResponse parses an HTTP response from a ActionsgetEnvironmentPublicKeyWithResponse call
func ParseActionsgetEnvironmentPublicKeyResponse(rsp *http.Response) (*ActionsgetEnvironmentPublicKeyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetEnvironmentPublicKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionsdeleteEnvironmentSecretResponse parses an HTTP response from a ActionsdeleteEnvironmentSecretWithResponse call
func ParseActionsdeleteEnvironmentSecretResponse(rsp *http.Response) (*ActionsdeleteEnvironmentSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsdeleteEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseActionsgetEnvironmentSecretResponse parses an HTTP response from a ActionsgetEnvironmentSecretWithResponse call
func ParseActionsgetEnvironmentSecretResponse(rsp *http.Response) (*ActionsgetEnvironmentSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionsgetEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActionscreateOrUpdateEnvironmentSecretResponse parses an HTTP response from a ActionscreateOrUpdateEnvironmentSecretWithResponse call
func ParseActionscreateOrUpdateEnvironmentSecretResponse(rsp *http.Response) (*ActionscreateOrUpdateEnvironmentSecretResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActionscreateOrUpdateEnvironmentSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminlistProvisionedGroupsEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistProvisionedGroupsEnterpriseWithResponse call
func ParseEnterpriseAdminlistProvisionedGroupsEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistProvisionedGroupsEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistProvisionedGroupsEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimGroupListEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminprovisionAndInviteEnterpriseGroupResponse parses an HTTP response from a EnterpriseAdminprovisionAndInviteEnterpriseGroupWithResponse call
func ParseEnterpriseAdminprovisionAndInviteEnterpriseGroupResponse(rsp *http.Response) (*EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminprovisionAndInviteEnterpriseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ScimEnterpriseGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmindeleteScimGroupFromEnterpriseResponse parses an HTTP response from a EnterpriseAdmindeleteScimGroupFromEnterpriseWithResponse call
func ParseEnterpriseAdmindeleteScimGroupFromEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmindeleteScimGroupFromEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmindeleteScimGroupFromEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse parses an HTTP response from a EnterpriseAdmingetProvisioningInformationForEnterpriseGroupWithResponse call
func ParseEnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse(rsp *http.Response) (*EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetProvisioningInformationForEnterpriseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminupdateAttributeForEnterpriseGroupResponse parses an HTTP response from a EnterpriseAdminupdateAttributeForEnterpriseGroupWithResponse call
func ParseEnterpriseAdminupdateAttributeForEnterpriseGroupResponse(rsp *http.Response) (*EnterpriseAdminupdateAttributeForEnterpriseGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminupdateAttributeForEnterpriseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse parses an HTTP response from a EnterpriseAdminsetInformationForProvisionedEnterpriseGroupWithResponse call
func ParseEnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse(rsp *http.Response) (*EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetInformationForProvisionedEnterpriseGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse parses an HTTP response from a EnterpriseAdminlistProvisionedIdentitiesEnterpriseWithResponse call
func ParseEnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse(rsp *http.Response) (*EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminlistProvisionedIdentitiesEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimUserListEnterprise
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminprovisionAndInviteEnterpriseUserResponse parses an HTTP response from a EnterpriseAdminprovisionAndInviteEnterpriseUserWithResponse call
func ParseEnterpriseAdminprovisionAndInviteEnterpriseUserResponse(rsp *http.Response) (*EnterpriseAdminprovisionAndInviteEnterpriseUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminprovisionAndInviteEnterpriseUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ScimEnterpriseUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdmindeleteUserFromEnterpriseResponse parses an HTTP response from a EnterpriseAdmindeleteUserFromEnterpriseWithResponse call
func ParseEnterpriseAdmindeleteUserFromEnterpriseResponse(rsp *http.Response) (*EnterpriseAdmindeleteUserFromEnterpriseResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmindeleteUserFromEnterpriseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse parses an HTTP response from a EnterpriseAdmingetProvisioningInformationForEnterpriseUserWithResponse call
func ParseEnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse(rsp *http.Response) (*EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdmingetProvisioningInformationForEnterpriseUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminupdateAttributeForEnterpriseUserResponse parses an HTTP response from a EnterpriseAdminupdateAttributeForEnterpriseUserWithResponse call
func ParseEnterpriseAdminupdateAttributeForEnterpriseUserResponse(rsp *http.Response) (*EnterpriseAdminupdateAttributeForEnterpriseUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminupdateAttributeForEnterpriseUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse parses an HTTP response from a EnterpriseAdminsetInformationForProvisionedEnterpriseUserWithResponse call
func ParseEnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse(rsp *http.Response) (*EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnterpriseAdminsetInformationForProvisionedEnterpriseUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScimEnterpriseUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScimlistProvisionedIdentitiesResponse parses an HTTP response from a ScimlistProvisionedIdentitiesWithResponse call
func ParseScimlistProvisionedIdentitiesResponse(rsp *http.Response) (*ScimlistProvisionedIdentitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimlistProvisionedIdentitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 429:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseScimprovisionAndInviteUserResponse parses an HTTP response from a ScimprovisionAndInviteUserWithResponse call
func ParseScimprovisionAndInviteUserResponse(rsp *http.Response) (*ScimprovisionAndInviteUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimprovisionAndInviteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 409:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 500:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseScimdeleteUserFromOrgResponse parses an HTTP response from a ScimdeleteUserFromOrgWithResponse call
func ParseScimdeleteUserFromOrgResponse(rsp *http.Response) (*ScimdeleteUserFromOrgResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimdeleteUserFromOrgResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseScimgetProvisioningInformationForUserResponse parses an HTTP response from a ScimgetProvisioningInformationForUserWithResponse call
func ParseScimgetProvisioningInformationForUserResponse(rsp *http.Response) (*ScimgetProvisioningInformationForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimgetProvisioningInformationForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseScimupdateAttributeForUserResponse parses an HTTP response from a ScimupdateAttributeForUserWithResponse call
func ParseScimupdateAttributeForUserResponse(rsp *http.Response) (*ScimupdateAttributeForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimupdateAttributeForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case rsp.StatusCode == 400:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseScimsetInformationForProvisionedUserResponse parses an HTTP response from a ScimsetInformationForProvisionedUserWithResponse call
func ParseScimsetInformationForProvisionedUserResponse(rsp *http.Response) (*ScimsetInformationForProvisionedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScimsetInformationForProvisionedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ScimError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case rsp.StatusCode == 403:
	// Content-type (application/scim+json) unsupported

	case rsp.StatusCode == 404:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseSearchcodeResponse parses an HTTP response from a SearchcodeWithResponse call
func ParseSearchcodeResponse(rsp *http.Response) (*SearchcodeResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchcodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                   `json:"incomplete_results"`
			Items             []CodeSearchResultItem `json:"items"`
			TotalCount        int                    `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchcommitsResponse parses an HTTP response from a SearchcommitsWithResponse call
func ParseSearchcommitsResponse(rsp *http.Response) (*SearchcommitsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchcommitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                     `json:"incomplete_results"`
			Items             []CommitSearchResultItem `json:"items"`
			TotalCount        int                      `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchissuesAndPullRequestsResponse parses an HTTP response from a SearchissuesAndPullRequestsWithResponse call
func ParseSearchissuesAndPullRequestsResponse(rsp *http.Response) (*SearchissuesAndPullRequestsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchissuesAndPullRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                    `json:"incomplete_results"`
			Items             []IssueSearchResultItem `json:"items"`
			TotalCount        int                     `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchlabelsResponse parses an HTTP response from a SearchlabelsWithResponse call
func ParseSearchlabelsResponse(rsp *http.Response) (*SearchlabelsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchlabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                    `json:"incomplete_results"`
			Items             []LabelSearchResultItem `json:"items"`
			TotalCount        int                     `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseSearchreposResponse parses an HTTP response from a SearchreposWithResponse call
func ParseSearchreposResponse(rsp *http.Response) (*SearchreposResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchreposResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                   `json:"incomplete_results"`
			Items             []RepoSearchResultItem `json:"items"`
			TotalCount        int                    `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseSearchtopicsResponse parses an HTTP response from a SearchtopicsWithResponse call
func ParseSearchtopicsResponse(rsp *http.Response) (*SearchtopicsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchtopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                    `json:"incomplete_results"`
			Items             []TopicSearchResultItem `json:"items"`
			TotalCount        int                     `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchusersResponse parses an HTTP response from a SearchusersWithResponse call
func ParseSearchusersResponse(rsp *http.Response) (*SearchusersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchusersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IncompleteResults bool                   `json:"incomplete_results"`
			Items             []UserSearchResultItem `json:"items"`
			TotalCount        int                    `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest struct {
			Code             *string `json:"code,omitempty"`
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteLegacyResponse parses an HTTP response from a TeamsdeleteLegacyWithResponse call
func ParseTeamsdeleteLegacyResponse(rsp *http.Response) (*TeamsdeleteLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamsgetLegacyResponse parses an HTTP response from a TeamsgetLegacyWithResponse call
func ParseTeamsgetLegacyResponse(rsp *http.Response) (*TeamsgetLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsupdateLegacyResponse parses an HTTP response from a TeamsupdateLegacyWithResponse call
func ParseTeamsupdateLegacyResponse(rsp *http.Response) (*TeamsupdateLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamslistDiscussionsLegacyResponse parses an HTTP response from a TeamslistDiscussionsLegacyWithResponse call
func ParseTeamslistDiscussionsLegacyResponse(rsp *http.Response) (*TeamslistDiscussionsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistDiscussionsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamscreateDiscussionLegacyResponse parses an HTTP response from a TeamscreateDiscussionLegacyWithResponse call
func ParseTeamscreateDiscussionLegacyResponse(rsp *http.Response) (*TeamscreateDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteDiscussionLegacyResponse parses an HTTP response from a TeamsdeleteDiscussionLegacyWithResponse call
func ParseTeamsdeleteDiscussionLegacyResponse(rsp *http.Response) (*TeamsdeleteDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetDiscussionLegacyResponse parses an HTTP response from a TeamsgetDiscussionLegacyWithResponse call
func ParseTeamsgetDiscussionLegacyResponse(rsp *http.Response) (*TeamsgetDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsupdateDiscussionLegacyResponse parses an HTTP response from a TeamsupdateDiscussionLegacyWithResponse call
func ParseTeamsupdateDiscussionLegacyResponse(rsp *http.Response) (*TeamsupdateDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistDiscussionCommentsLegacyResponse parses an HTTP response from a TeamslistDiscussionCommentsLegacyWithResponse call
func ParseTeamslistDiscussionCommentsLegacyResponse(rsp *http.Response) (*TeamslistDiscussionCommentsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistDiscussionCommentsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamscreateDiscussionCommentLegacyResponse parses an HTTP response from a TeamscreateDiscussionCommentLegacyWithResponse call
func ParseTeamscreateDiscussionCommentLegacyResponse(rsp *http.Response) (*TeamscreateDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamsdeleteDiscussionCommentLegacyResponse parses an HTTP response from a TeamsdeleteDiscussionCommentLegacyWithResponse call
func ParseTeamsdeleteDiscussionCommentLegacyResponse(rsp *http.Response) (*TeamsdeleteDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsdeleteDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetDiscussionCommentLegacyResponse parses an HTTP response from a TeamsgetDiscussionCommentLegacyWithResponse call
func ParseTeamsgetDiscussionCommentLegacyResponse(rsp *http.Response) (*TeamsgetDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsupdateDiscussionCommentLegacyResponse parses an HTTP response from a TeamsupdateDiscussionCommentLegacyWithResponse call
func ParseTeamsupdateDiscussionCommentLegacyResponse(rsp *http.Response) (*TeamsupdateDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsupdateDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamDiscussionComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionslistForTeamDiscussionCommentLegacyResponse parses an HTTP response from a ReactionslistForTeamDiscussionCommentLegacyWithResponse call
func ParseReactionslistForTeamDiscussionCommentLegacyResponse(rsp *http.Response) (*ReactionslistForTeamDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForTeamDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionscreateForTeamDiscussionCommentLegacyResponse parses an HTTP response from a ReactionscreateForTeamDiscussionCommentLegacyWithResponse call
func ParseReactionscreateForTeamDiscussionCommentLegacyResponse(rsp *http.Response) (*ReactionscreateForTeamDiscussionCommentLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForTeamDiscussionCommentLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseReactionslistForTeamDiscussionLegacyResponse parses an HTTP response from a ReactionslistForTeamDiscussionLegacyWithResponse call
func ParseReactionslistForTeamDiscussionLegacyResponse(rsp *http.Response) (*ReactionslistForTeamDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionslistForTeamDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReactionscreateForTeamDiscussionLegacyResponse parses an HTTP response from a ReactionscreateForTeamDiscussionLegacyWithResponse call
func ParseReactionscreateForTeamDiscussionLegacyResponse(rsp *http.Response) (*ReactionscreateForTeamDiscussionLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReactionscreateForTeamDiscussionLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Reaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseTeamslistPendingInvitationsLegacyResponse parses an HTTP response from a TeamslistPendingInvitationsLegacyWithResponse call
func ParseTeamslistPendingInvitationsLegacyResponse(rsp *http.Response) (*TeamslistPendingInvitationsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistPendingInvitationsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamslistMembersLegacyResponse parses an HTTP response from a TeamslistMembersLegacyWithResponse call
func ParseTeamslistMembersLegacyResponse(rsp *http.Response) (*TeamslistMembersLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistMembersLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsremoveMemberLegacyResponse parses an HTTP response from a TeamsremoveMemberLegacyWithResponse call
func ParseTeamsremoveMemberLegacyResponse(rsp *http.Response) (*TeamsremoveMemberLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveMemberLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetMemberLegacyResponse parses an HTTP response from a TeamsgetMemberLegacyWithResponse call
func ParseTeamsgetMemberLegacyResponse(rsp *http.Response) (*TeamsgetMemberLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetMemberLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsaddMemberLegacyResponse parses an HTTP response from a TeamsaddMemberLegacyWithResponse call
func ParseTeamsaddMemberLegacyResponse(rsp *http.Response) (*TeamsaddMemberLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddMemberLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTeamsremoveMembershipForUserLegacyResponse parses an HTTP response from a TeamsremoveMembershipForUserLegacyWithResponse call
func ParseTeamsremoveMembershipForUserLegacyResponse(rsp *http.Response) (*TeamsremoveMembershipForUserLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveMembershipForUserLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamsgetMembershipForUserLegacyResponse parses an HTTP response from a TeamsgetMembershipForUserLegacyWithResponse call
func ParseTeamsgetMembershipForUserLegacyResponse(rsp *http.Response) (*TeamsgetMembershipForUserLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsgetMembershipForUserLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateMembershipForUserLegacyResponse parses an HTTP response from a TeamsaddOrUpdateMembershipForUserLegacyWithResponse call
func ParseTeamsaddOrUpdateMembershipForUserLegacyResponse(rsp *http.Response) (*TeamsaddOrUpdateMembershipForUserLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateMembershipForUserLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamslistProjectsLegacyResponse parses an HTTP response from a TeamslistProjectsLegacyWithResponse call
func ParseTeamslistProjectsLegacyResponse(rsp *http.Response) (*TeamslistProjectsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistProjectsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsremoveProjectLegacyResponse parses an HTTP response from a TeamsremoveProjectLegacyWithResponse call
func ParseTeamsremoveProjectLegacyResponse(rsp *http.Response) (*TeamsremoveProjectLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveProjectLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamscheckPermissionsForProjectLegacyResponse parses an HTTP response from a TeamscheckPermissionsForProjectLegacyWithResponse call
func ParseTeamscheckPermissionsForProjectLegacyResponse(rsp *http.Response) (*TeamscheckPermissionsForProjectLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscheckPermissionsForProjectLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamProject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateProjectPermissionsLegacyResponse parses an HTTP response from a TeamsaddOrUpdateProjectPermissionsLegacyWithResponse call
func ParseTeamsaddOrUpdateProjectPermissionsLegacyResponse(rsp *http.Response) (*TeamsaddOrUpdateProjectPermissionsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateProjectPermissionsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			DocumentationUrl *string `json:"documentation_url,omitempty"`
			Message          *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamslistReposLegacyResponse parses an HTTP response from a TeamslistReposLegacyWithResponse call
func ParseTeamslistReposLegacyResponse(rsp *http.Response) (*TeamslistReposLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistReposLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamsremoveRepoLegacyResponse parses an HTTP response from a TeamsremoveRepoLegacyWithResponse call
func ParseTeamsremoveRepoLegacyResponse(rsp *http.Response) (*TeamsremoveRepoLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsremoveRepoLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTeamscheckPermissionsForRepoLegacyResponse parses an HTTP response from a TeamscheckPermissionsForRepoLegacyWithResponse call
func ParseTeamscheckPermissionsForRepoLegacyResponse(rsp *http.Response) (*TeamscheckPermissionsForRepoLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscheckPermissionsForRepoLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTeamsaddOrUpdateRepoPermissionsLegacyResponse parses an HTTP response from a TeamsaddOrUpdateRepoPermissionsLegacyWithResponse call
func ParseTeamsaddOrUpdateRepoPermissionsLegacyResponse(rsp *http.Response) (*TeamsaddOrUpdateRepoPermissionsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamsaddOrUpdateRepoPermissionsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamslistIdpGroupsForLegacyResponse parses an HTTP response from a TeamslistIdpGroupsForLegacyWithResponse call
func ParseTeamslistIdpGroupsForLegacyResponse(rsp *http.Response) (*TeamslistIdpGroupsForLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistIdpGroupsForLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTeamscreateOrUpdateIdpGroupConnectionsLegacyResponse parses an HTTP response from a TeamscreateOrUpdateIdpGroupConnectionsLegacyWithResponse call
func ParseTeamscreateOrUpdateIdpGroupConnectionsLegacyResponse(rsp *http.Response) (*TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamscreateOrUpdateIdpGroupConnectionsLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMapping
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseTeamslistChildLegacyResponse parses an HTTP response from a TeamslistChildLegacyWithResponse call
func ParseTeamslistChildLegacyResponse(rsp *http.Response) (*TeamslistChildLegacyResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistChildLegacyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersgetAuthenticatedResponse parses an HTTP response from a UsersgetAuthenticatedWithResponse call
func ParseUsersgetAuthenticatedResponse(rsp *http.Response) (*UsersgetAuthenticatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersgetAuthenticatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUsersupdateAuthenticatedResponse parses an HTTP response from a UsersupdateAuthenticatedWithResponse call
func ParseUsersupdateAuthenticatedResponse(rsp *http.Response) (*UsersupdateAuthenticatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersupdateAuthenticatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrivateUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserslistBlockedByAuthenticatedUserResponse parses an HTTP response from a UserslistBlockedByAuthenticatedUserWithResponse call
func ParseUserslistBlockedByAuthenticatedUserResponse(rsp *http.Response) (*UserslistBlockedByAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistBlockedByAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersunblockResponse parses an HTTP response from a UsersunblockWithResponse call
func ParseUsersunblockResponse(rsp *http.Response) (*UsersunblockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersunblockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserscheckBlockedResponse parses an HTTP response from a UserscheckBlockedWithResponse call
func ParseUserscheckBlockedResponse(rsp *http.Response) (*UserscheckBlockedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserscheckBlockedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersblockResponse parses an HTTP response from a UsersblockWithResponse call
func ParseUsersblockResponse(rsp *http.Response) (*UsersblockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersblockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCodespaceslistForAuthenticatedUserResponse parses an HTTP response from a CodespaceslistForAuthenticatedUserWithResponse call
func ParseCodespaceslistForAuthenticatedUserResponse(rsp *http.Response) (*CodespaceslistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Codespaces []Codespace `json:"codespaces"`
			TotalCount int         `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacescreateForAuthenticatedUserResponse parses an HTTP response from a CodespacescreateForAuthenticatedUserWithResponse call
func ParseCodespacescreateForAuthenticatedUserResponse(rsp *http.Response) (*CodespacescreateForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescreateForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCodespaceslistSecretsForAuthenticatedUserResponse parses an HTTP response from a CodespaceslistSecretsForAuthenticatedUserWithResponse call
func ParseCodespaceslistSecretsForAuthenticatedUserResponse(rsp *http.Response) (*CodespaceslistSecretsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistSecretsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Secrets    []CodespacesSecret `json:"secrets"`
			TotalCount int                `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacesgetPublicKeyForAuthenticatedUserResponse parses an HTTP response from a CodespacesgetPublicKeyForAuthenticatedUserWithResponse call
func ParseCodespacesgetPublicKeyForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesgetPublicKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetPublicKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodespacesUserPublicKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacesdeleteSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacesdeleteSecretForAuthenticatedUserWithResponse call
func ParseCodespacesdeleteSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesdeleteSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesdeleteSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCodespacesgetSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacesgetSecretForAuthenticatedUserWithResponse call
func ParseCodespacesgetSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesgetSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodespacesSecret
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCodespacescreateOrUpdateSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacescreateOrUpdateSecretForAuthenticatedUserWithResponse call
func ParseCodespacescreateOrUpdateSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacescreateOrUpdateSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescreateOrUpdateSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCodespaceslistRepositoriesForSecretForAuthenticatedUserResponse parses an HTTP response from a CodespaceslistRepositoriesForSecretForAuthenticatedUserWithResponse call
func ParseCodespaceslistRepositoriesForSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespaceslistRepositoriesForSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories []MinimalRepository `json:"repositories"`
			TotalCount   int                 `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacessetRepositoriesForSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacessetRepositoriesForSecretForAuthenticatedUserWithResponse call
func ParseCodespacessetRepositoriesForSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacessetRepositoriesForSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacessetRepositoriesForSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesremoveRepositoryForSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacesremoveRepositoryForSecretForAuthenticatedUserWithResponse call
func ParseCodespacesremoveRepositoryForSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesremoveRepositoryForSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesaddRepositoryForSecretForAuthenticatedUserResponse parses an HTTP response from a CodespacesaddRepositoryForSecretForAuthenticatedUserWithResponse call
func ParseCodespacesaddRepositoryForSecretForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesaddRepositoryForSecretForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesaddRepositoryForSecretForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesdeleteForAuthenticatedUserResponse parses an HTTP response from a CodespacesdeleteForAuthenticatedUserWithResponse call
func ParseCodespacesdeleteForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesdeleteForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesdeleteForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesgetForAuthenticatedUserResponse parses an HTTP response from a CodespacesgetForAuthenticatedUserWithResponse call
func ParseCodespacesgetForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesgetForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesupdateForAuthenticatedUserResponse parses an HTTP response from a CodespacesupdateForAuthenticatedUserWithResponse call
func ParseCodespacesupdateForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesupdateForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesupdateForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCodespacesexportForAuthenticatedUserResponse parses an HTTP response from a CodespacesexportForAuthenticatedUserWithResponse call
func ParseCodespacesexportForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesexportForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesexportForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CodespaceExportDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesgetExportDetailsForAuthenticatedUserResponse parses an HTTP response from a CodespacesgetExportDetailsForAuthenticatedUserWithResponse call
func ParseCodespacesgetExportDetailsForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesgetExportDetailsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesgetExportDetailsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CodespaceExportDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCodespacescodespaceMachinesForAuthenticatedUserResponse parses an HTTP response from a CodespacescodespaceMachinesForAuthenticatedUserWithResponse call
func ParseCodespacescodespaceMachinesForAuthenticatedUserResponse(rsp *http.Response) (*CodespacescodespaceMachinesForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacescodespaceMachinesForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Machines   []CodespaceMachine `json:"machines"`
			TotalCount int                `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCodespacesstartForAuthenticatedUserResponse parses an HTTP response from a CodespacesstartForAuthenticatedUserWithResponse call
func ParseCodespacesstartForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesstartForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesstartForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseCodespacesstopForAuthenticatedUserResponse parses an HTTP response from a CodespacesstopForAuthenticatedUserWithResponse call
func ParseCodespacesstopForAuthenticatedUserResponse(rsp *http.Response) (*CodespacesstopForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CodespacesstopForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Codespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUserssetPrimaryEmailVisibilityForAuthenticatedUserResponse parses an HTTP response from a UserssetPrimaryEmailVisibilityForAuthenticatedUserWithResponse call
func ParseUserssetPrimaryEmailVisibilityForAuthenticatedUserResponse(rsp *http.Response) (*UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserssetPrimaryEmailVisibilityForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersdeleteEmailForAuthenticatedUserResponse parses an HTTP response from a UsersdeleteEmailForAuthenticatedUserWithResponse call
func ParseUsersdeleteEmailForAuthenticatedUserResponse(rsp *http.Response) (*UsersdeleteEmailForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersdeleteEmailForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserslistEmailsForAuthenticatedUserResponse parses an HTTP response from a UserslistEmailsForAuthenticatedUserWithResponse call
func ParseUserslistEmailsForAuthenticatedUserResponse(rsp *http.Response) (*UserslistEmailsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistEmailsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersaddEmailForAuthenticatedUserResponse parses an HTTP response from a UsersaddEmailForAuthenticatedUserWithResponse call
func ParseUsersaddEmailForAuthenticatedUserResponse(rsp *http.Response) (*UsersaddEmailForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersaddEmailForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest []Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserslistFollowersForAuthenticatedUserResponse parses an HTTP response from a UserslistFollowersForAuthenticatedUserWithResponse call
func ParseUserslistFollowersForAuthenticatedUserResponse(rsp *http.Response) (*UserslistFollowersForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistFollowersForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUserslistFollowedByAuthenticatedUserResponse parses an HTTP response from a UserslistFollowedByAuthenticatedUserWithResponse call
func ParseUserslistFollowedByAuthenticatedUserResponse(rsp *http.Response) (*UserslistFollowedByAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistFollowedByAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUsersunfollowResponse parses an HTTP response from a UsersunfollowWithResponse call
func ParseUsersunfollowResponse(rsp *http.Response) (*UsersunfollowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersunfollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserscheckPersonIsFollowedByAuthenticatedResponse parses an HTTP response from a UserscheckPersonIsFollowedByAuthenticatedWithResponse call
func ParseUserscheckPersonIsFollowedByAuthenticatedResponse(rsp *http.Response) (*UserscheckPersonIsFollowedByAuthenticatedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserscheckPersonIsFollowedByAuthenticatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersfollowResponse parses an HTTP response from a UsersfollowWithResponse call
func ParseUsersfollowResponse(rsp *http.Response) (*UsersfollowResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersfollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserslistGpgKeysForAuthenticatedUserResponse parses an HTTP response from a UserslistGpgKeysForAuthenticatedUserWithResponse call
func ParseUserslistGpgKeysForAuthenticatedUserResponse(rsp *http.Response) (*UserslistGpgKeysForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistGpgKeysForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GpgKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserscreateGpgKeyForAuthenticatedUserResponse parses an HTTP response from a UserscreateGpgKeyForAuthenticatedUserWithResponse call
func ParseUserscreateGpgKeyForAuthenticatedUserResponse(rsp *http.Response) (*UserscreateGpgKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserscreateGpgKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GpgKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersdeleteGpgKeyForAuthenticatedUserResponse parses an HTTP response from a UsersdeleteGpgKeyForAuthenticatedUserWithResponse call
func ParseUsersdeleteGpgKeyForAuthenticatedUserResponse(rsp *http.Response) (*UsersdeleteGpgKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersdeleteGpgKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersgetGpgKeyForAuthenticatedUserResponse parses an HTTP response from a UsersgetGpgKeyForAuthenticatedUserWithResponse call
func ParseUsersgetGpgKeyForAuthenticatedUserResponse(rsp *http.Response) (*UsersgetGpgKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersgetGpgKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GpgKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppslistInstallationsForAuthenticatedUserResponse parses an HTTP response from a AppslistInstallationsForAuthenticatedUserWithResponse call
func ParseAppslistInstallationsForAuthenticatedUserResponse(rsp *http.Response) (*AppslistInstallationsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistInstallationsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Installations []Installation `json:"installations"`
			TotalCount    int            `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseAppslistInstallationReposForAuthenticatedUserResponse parses an HTTP response from a AppslistInstallationReposForAuthenticatedUserWithResponse call
func ParseAppslistInstallationReposForAuthenticatedUserResponse(rsp *http.Response) (*AppslistInstallationReposForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistInstallationReposForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Repositories        []Repository `json:"repositories"`
			RepositorySelection *string      `json:"repository_selection,omitempty"`
			TotalCount          int          `json:"total_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsremoveRepoFromInstallationForAuthenticatedUserResponse parses an HTTP response from a AppsremoveRepoFromInstallationForAuthenticatedUserWithResponse call
func ParseAppsremoveRepoFromInstallationForAuthenticatedUserResponse(rsp *http.Response) (*AppsremoveRepoFromInstallationForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsremoveRepoFromInstallationForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppsaddRepoToInstallationForAuthenticatedUserResponse parses an HTTP response from a AppsaddRepoToInstallationForAuthenticatedUserWithResponse call
func ParseAppsaddRepoToInstallationForAuthenticatedUserResponse(rsp *http.Response) (*AppsaddRepoToInstallationForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsaddRepoToInstallationForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseInteractionsremoveRestrictionsForAuthenticatedUserResponse parses an HTTP response from a InteractionsremoveRestrictionsForAuthenticatedUserWithResponse call
func ParseInteractionsremoveRestrictionsForAuthenticatedUserResponse(rsp *http.Response) (*InteractionsremoveRestrictionsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsremoveRestrictionsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInteractionsgetRestrictionsForAuthenticatedUserResponse parses an HTTP response from a InteractionsgetRestrictionsForAuthenticatedUserWithResponse call
func ParseInteractionsgetRestrictionsForAuthenticatedUserResponse(rsp *http.Response) (*InteractionsgetRestrictionsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionsgetRestrictionsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseInteractionssetRestrictionsForAuthenticatedUserResponse parses an HTTP response from a InteractionssetRestrictionsForAuthenticatedUserWithResponse call
func ParseInteractionssetRestrictionsForAuthenticatedUserResponse(rsp *http.Response) (*InteractionssetRestrictionsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InteractionssetRestrictionsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InteractionLimitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseIssueslistForAuthenticatedUserResponse parses an HTTP response from a IssueslistForAuthenticatedUserWithResponse call
func ParseIssueslistForAuthenticatedUserResponse(rsp *http.Response) (*IssueslistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssueslistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserslistPublicSshKeysForAuthenticatedUserResponse parses an HTTP response from a UserslistPublicSshKeysForAuthenticatedUserWithResponse call
func ParseUserslistPublicSshKeysForAuthenticatedUserResponse(rsp *http.Response) (*UserslistPublicSshKeysForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistPublicSshKeysForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserscreatePublicSshKeyForAuthenticatedUserResponse parses an HTTP response from a UserscreatePublicSshKeyForAuthenticatedUserWithResponse call
func ParseUserscreatePublicSshKeyForAuthenticatedUserResponse(rsp *http.Response) (*UserscreatePublicSshKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserscreatePublicSshKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUsersdeletePublicSshKeyForAuthenticatedUserResponse parses an HTTP response from a UsersdeletePublicSshKeyForAuthenticatedUserWithResponse call
func ParseUsersdeletePublicSshKeyForAuthenticatedUserResponse(rsp *http.Response) (*UsersdeletePublicSshKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersdeletePublicSshKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUsersgetPublicSshKeyForAuthenticatedUserResponse parses an HTTP response from a UsersgetPublicSshKeyForAuthenticatedUserWithResponse call
func ParseUsersgetPublicSshKeyForAuthenticatedUserResponse(rsp *http.Response) (*UsersgetPublicSshKeyForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersgetPublicSshKeyForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Key
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppslistSubscriptionsForAuthenticatedUserResponse parses an HTTP response from a AppslistSubscriptionsForAuthenticatedUserWithResponse call
func ParseAppslistSubscriptionsForAuthenticatedUserResponse(rsp *http.Response) (*AppslistSubscriptionsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistSubscriptionsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserMarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAppslistSubscriptionsForAuthenticatedUserStubbedResponse parses an HTTP response from a AppslistSubscriptionsForAuthenticatedUserStubbedWithResponse call
func ParseAppslistSubscriptionsForAuthenticatedUserStubbedResponse(rsp *http.Response) (*AppslistSubscriptionsForAuthenticatedUserStubbedResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppslistSubscriptionsForAuthenticatedUserStubbedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []UserMarketplacePurchase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseOrgslistMembershipsForAuthenticatedUserResponse parses an HTTP response from a OrgslistMembershipsForAuthenticatedUserWithResponse call
func ParseOrgslistMembershipsForAuthenticatedUserResponse(rsp *http.Response) (*OrgslistMembershipsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistMembershipsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrgMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseOrgsgetMembershipForAuthenticatedUserResponse parses an HTTP response from a OrgsgetMembershipForAuthenticatedUserWithResponse call
func ParseOrgsgetMembershipForAuthenticatedUserResponse(rsp *http.Response) (*OrgsgetMembershipForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsgetMembershipForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgsupdateMembershipForAuthenticatedUserResponse parses an HTTP response from a OrgsupdateMembershipForAuthenticatedUserWithResponse call
func ParseOrgsupdateMembershipForAuthenticatedUserResponse(rsp *http.Response) (*OrgsupdateMembershipForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgsupdateMembershipForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrgMembership
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationslistForAuthenticatedUserResponse parses an HTTP response from a MigrationslistForAuthenticatedUserWithResponse call
func ParseMigrationslistForAuthenticatedUserResponse(rsp *http.Response) (*MigrationslistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationslistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMigrationsstartForAuthenticatedUserResponse parses an HTTP response from a MigrationsstartForAuthenticatedUserWithResponse call
func ParseMigrationsstartForAuthenticatedUserResponse(rsp *http.Response) (*MigrationsstartForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsstartForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseMigrationsgetStatusForAuthenticatedUserResponse parses an HTTP response from a MigrationsgetStatusForAuthenticatedUserWithResponse call
func ParseMigrationsgetStatusForAuthenticatedUserResponse(rsp *http.Response) (*MigrationsgetStatusForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetStatusForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Migration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsdeleteArchiveForAuthenticatedUserResponse parses an HTTP response from a MigrationsdeleteArchiveForAuthenticatedUserWithResponse call
func ParseMigrationsdeleteArchiveForAuthenticatedUserResponse(rsp *http.Response) (*MigrationsdeleteArchiveForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsdeleteArchiveForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationsgetArchiveForAuthenticatedUserResponse parses an HTTP response from a MigrationsgetArchiveForAuthenticatedUserWithResponse call
func ParseMigrationsgetArchiveForAuthenticatedUserResponse(rsp *http.Response) (*MigrationsgetArchiveForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsgetArchiveForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseMigrationsunlockRepoForAuthenticatedUserResponse parses an HTTP response from a MigrationsunlockRepoForAuthenticatedUserWithResponse call
func ParseMigrationsunlockRepoForAuthenticatedUserResponse(rsp *http.Response) (*MigrationsunlockRepoForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationsunlockRepoForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseMigrationslistReposForAuthenticatedUserResponse parses an HTTP response from a MigrationslistReposForAuthenticatedUserWithResponse call
func ParseMigrationslistReposForAuthenticatedUserResponse(rsp *http.Response) (*MigrationslistReposForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MigrationslistReposForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseOrgslistForAuthenticatedUserResponse parses an HTTP response from a OrgslistForAuthenticatedUserWithResponse call
func ParseOrgslistForAuthenticatedUserResponse(rsp *http.Response) (*OrgslistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePackageslistPackagesForAuthenticatedUserResponse parses an HTTP response from a PackageslistPackagesForAuthenticatedUserWithResponse call
func ParsePackageslistPackagesForAuthenticatedUserResponse(rsp *http.Response) (*PackageslistPackagesForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackageslistPackagesForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageForAuthenticatedUserResponse parses an HTTP response from a PackagesdeletePackageForAuthenticatedUserWithResponse call
func ParsePackagesdeletePackageForAuthenticatedUserResponse(rsp *http.Response) (*PackagesdeletePackageForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageForAuthenticatedUserResponse parses an HTTP response from a PackagesgetPackageForAuthenticatedUserWithResponse call
func ParsePackagesgetPackageForAuthenticatedUserResponse(rsp *http.Response) (*PackagesgetPackageForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageForAuthenticatedUserResponse parses an HTTP response from a PackagesrestorePackageForAuthenticatedUserWithResponse call
func ParsePackagesrestorePackageForAuthenticatedUserResponse(rsp *http.Response) (*PackagesrestorePackageForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse parses an HTTP response from a PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserWithResponse call
func ParsePackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse(rsp *http.Response) (*PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageVersionForAuthenticatedUserResponse parses an HTTP response from a PackagesdeletePackageVersionForAuthenticatedUserWithResponse call
func ParsePackagesdeletePackageVersionForAuthenticatedUserResponse(rsp *http.Response) (*PackagesdeletePackageVersionForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageVersionForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageVersionForAuthenticatedUserResponse parses an HTTP response from a PackagesgetPackageVersionForAuthenticatedUserWithResponse call
func ParsePackagesgetPackageVersionForAuthenticatedUserResponse(rsp *http.Response) (*PackagesgetPackageVersionForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageVersionForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageVersionForAuthenticatedUserResponse parses an HTTP response from a PackagesrestorePackageVersionForAuthenticatedUserWithResponse call
func ParsePackagesrestorePackageVersionForAuthenticatedUserResponse(rsp *http.Response) (*PackagesrestorePackageVersionForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageVersionForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectscreateForAuthenticatedUserResponse parses an HTTP response from a ProjectscreateForAuthenticatedUserWithResponse call
func ParseProjectscreateForAuthenticatedUserResponse(rsp *http.Response) (*ProjectscreateForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectscreateForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationErrorSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserslistPublicEmailsForAuthenticatedUserResponse parses an HTTP response from a UserslistPublicEmailsForAuthenticatedUserWithResponse call
func ParseUserslistPublicEmailsForAuthenticatedUserResponse(rsp *http.Response) (*UserslistPublicEmailsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistPublicEmailsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Email
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposlistForAuthenticatedUserResponse parses an HTTP response from a ReposlistForAuthenticatedUserWithResponse call
func ParseReposlistForAuthenticatedUserResponse(rsp *http.Response) (*ReposlistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseReposcreateForAuthenticatedUserResponse parses an HTTP response from a ReposcreateForAuthenticatedUserWithResponse call
func ParseReposcreateForAuthenticatedUserResponse(rsp *http.Response) (*ReposcreateForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposcreateForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case rsp.StatusCode == 400:
		// Content-type (application/scim+json) unsupported

	}

	return response, nil
}

// ParseReposlistInvitationsForAuthenticatedUserResponse parses an HTTP response from a ReposlistInvitationsForAuthenticatedUserWithResponse call
func ParseReposlistInvitationsForAuthenticatedUserResponse(rsp *http.Response) (*ReposlistInvitationsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistInvitationsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []RepositoryInvitation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReposdeclineInvitationForAuthenticatedUserResponse parses an HTTP response from a ReposdeclineInvitationForAuthenticatedUserWithResponse call
func ParseReposdeclineInvitationForAuthenticatedUserResponse(rsp *http.Response) (*ReposdeclineInvitationForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposdeclineInvitationForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseReposacceptInvitationForAuthenticatedUserResponse parses an HTTP response from a ReposacceptInvitationForAuthenticatedUserWithResponse call
func ParseReposacceptInvitationForAuthenticatedUserResponse(rsp *http.Response) (*ReposacceptInvitationForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposacceptInvitationForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseActivitylistReposStarredByAuthenticatedUserResponse parses an HTTP response from a ActivitylistReposStarredByAuthenticatedUserWithResponse call
func ParseActivitylistReposStarredByAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistReposStarredByAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistReposStarredByAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case rsp.StatusCode == 200:
		// Content-type (application/vnd.github.v3.star+json) unsupported

	}

	return response, nil
}

// ParseActivityunstarRepoForAuthenticatedUserResponse parses an HTTP response from a ActivityunstarRepoForAuthenticatedUserWithResponse call
func ParseActivityunstarRepoForAuthenticatedUserResponse(rsp *http.Response) (*ActivityunstarRepoForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivityunstarRepoForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivitycheckRepoIsStarredByAuthenticatedUserResponse parses an HTTP response from a ActivitycheckRepoIsStarredByAuthenticatedUserWithResponse call
func ParseActivitycheckRepoIsStarredByAuthenticatedUserResponse(rsp *http.Response) (*ActivitycheckRepoIsStarredByAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitycheckRepoIsStarredByAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivitystarRepoForAuthenticatedUserResponse parses an HTTP response from a ActivitystarRepoForAuthenticatedUserWithResponse call
func ParseActivitystarRepoForAuthenticatedUserResponse(rsp *http.Response) (*ActivitystarRepoForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitystarRepoForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivitylistWatchedReposForAuthenticatedUserResponse parses an HTTP response from a ActivitylistWatchedReposForAuthenticatedUserWithResponse call
func ParseActivitylistWatchedReposForAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistWatchedReposForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistWatchedReposForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseTeamslistForAuthenticatedUserResponse parses an HTTP response from a TeamslistForAuthenticatedUserWithResponse call
func ParseTeamslistForAuthenticatedUserResponse(rsp *http.Response) (*TeamslistForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TeamslistForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []TeamFull
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUserslistResponse parses an HTTP response from a UserslistWithResponse call
func ParseUserslistResponse(rsp *http.Response) (*UserslistResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersgetByUsernameResponse parses an HTTP response from a UsersgetByUsernameWithResponse call
func ParseUsersgetByUsernameResponse(rsp *http.Response) (*UsersgetByUsernameResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersgetByUsernameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseActivitylistEventsForAuthenticatedUserResponse parses an HTTP response from a ActivitylistEventsForAuthenticatedUserWithResponse call
func ParseActivitylistEventsForAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistEventsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistEventsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistOrgEventsForAuthenticatedUserResponse parses an HTTP response from a ActivitylistOrgEventsForAuthenticatedUserWithResponse call
func ParseActivitylistOrgEventsForAuthenticatedUserResponse(rsp *http.Response) (*ActivitylistOrgEventsForAuthenticatedUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistOrgEventsForAuthenticatedUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistPublicEventsForUserResponse parses an HTTP response from a ActivitylistPublicEventsForUserWithResponse call
func ParseActivitylistPublicEventsForUserResponse(rsp *http.Response) (*ActivitylistPublicEventsForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistPublicEventsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserslistFollowersForUserResponse parses an HTTP response from a UserslistFollowersForUserWithResponse call
func ParseUserslistFollowersForUserResponse(rsp *http.Response) (*UserslistFollowersForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistFollowersForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserslistFollowingForUserResponse parses an HTTP response from a UserslistFollowingForUserWithResponse call
func ParseUserslistFollowingForUserResponse(rsp *http.Response) (*UserslistFollowingForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistFollowingForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []SimpleUser
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserscheckFollowingForUserResponse parses an HTTP response from a UserscheckFollowingForUserWithResponse call
func ParseUserscheckFollowingForUserResponse(rsp *http.Response) (*UserscheckFollowingForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserscheckFollowingForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGistslistForUserResponse parses an HTTP response from a GistslistForUserWithResponse call
func ParseGistslistForUserResponse(rsp *http.Response) (*GistslistForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GistslistForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BaseGist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUserslistGpgKeysForUserResponse parses an HTTP response from a UserslistGpgKeysForUserWithResponse call
func ParseUserslistGpgKeysForUserResponse(rsp *http.Response) (*UserslistGpgKeysForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistGpgKeysForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GpgKey
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersgetContextForUserResponse parses an HTTP response from a UsersgetContextForUserWithResponse call
func ParseUsersgetContextForUserResponse(rsp *http.Response) (*UsersgetContextForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersgetContextForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Hovercard
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseAppsgetUserInstallationResponse parses an HTTP response from a AppsgetUserInstallationWithResponse call
func ParseAppsgetUserInstallationResponse(rsp *http.Response) (*AppsgetUserInstallationResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AppsgetUserInstallationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Installation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserslistPublicKeysForUserResponse parses an HTTP response from a UserslistPublicKeysForUserWithResponse call
func ParseUserslistPublicKeysForUserResponse(rsp *http.Response) (*UserslistPublicKeysForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserslistPublicKeysForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []KeySimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseOrgslistForUserResponse parses an HTTP response from a OrgslistForUserWithResponse call
func ParseOrgslistForUserResponse(rsp *http.Response) (*OrgslistForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &OrgslistForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OrganizationSimple
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackageslistPackagesForUserResponse parses an HTTP response from a PackageslistPackagesForUserWithResponse call
func ParsePackageslistPackagesForUserResponse(rsp *http.Response) (*PackageslistPackagesForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackageslistPackagesForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageForUserResponse parses an HTTP response from a PackagesdeletePackageForUserWithResponse call
func ParsePackagesdeletePackageForUserResponse(rsp *http.Response) (*PackagesdeletePackageForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageForUserResponse parses an HTTP response from a PackagesgetPackageForUserWithResponse call
func ParsePackagesgetPackageForUserResponse(rsp *http.Response) (*PackagesgetPackageForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageForUserResponse parses an HTTP response from a PackagesrestorePackageForUserWithResponse call
func ParsePackagesrestorePackageForUserResponse(rsp *http.Response) (*PackagesrestorePackageForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetAllPackageVersionsForPackageOwnedByUserResponse parses an HTTP response from a PackagesgetAllPackageVersionsForPackageOwnedByUserWithResponse call
func ParsePackagesgetAllPackageVersionsForPackageOwnedByUserResponse(rsp *http.Response) (*PackagesgetAllPackageVersionsForPackageOwnedByUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetAllPackageVersionsForPackageOwnedByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesdeletePackageVersionForUserResponse parses an HTTP response from a PackagesdeletePackageVersionForUserWithResponse call
func ParsePackagesdeletePackageVersionForUserResponse(rsp *http.Response) (*PackagesdeletePackageVersionForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesdeletePackageVersionForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePackagesgetPackageVersionForUserResponse parses an HTTP response from a PackagesgetPackageVersionForUserWithResponse call
func ParsePackagesgetPackageVersionForUserResponse(rsp *http.Response) (*PackagesgetPackageVersionForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesgetPackageVersionForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePackagesrestorePackageVersionForUserResponse parses an HTTP response from a PackagesrestorePackageVersionForUserWithResponse call
func ParsePackagesrestorePackageVersionForUserResponse(rsp *http.Response) (*PackagesrestorePackageVersionForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PackagesrestorePackageVersionForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest BasicError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseProjectslistForUserResponse parses an HTTP response from a ProjectslistForUserWithResponse call
func ParseProjectslistForUserResponse(rsp *http.Response) (*ProjectslistForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectslistForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest ValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseActivitylistReceivedEventsForUserResponse parses an HTTP response from a ActivitylistReceivedEventsForUserWithResponse call
func ParseActivitylistReceivedEventsForUserResponse(rsp *http.Response) (*ActivitylistReceivedEventsForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistReceivedEventsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistReceivedPublicEventsForUserResponse parses an HTTP response from a ActivitylistReceivedPublicEventsForUserWithResponse call
func ParseActivitylistReceivedPublicEventsForUserResponse(rsp *http.Response) (*ActivitylistReceivedPublicEventsForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistReceivedPublicEventsForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReposlistForUserResponse parses an HTTP response from a ReposlistForUserWithResponse call
func ParseReposlistForUserResponse(rsp *http.Response) (*ReposlistForUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReposlistForUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubActionsBillingUserResponse parses an HTTP response from a BillinggetGithubActionsBillingUserWithResponse call
func ParseBillinggetGithubActionsBillingUserResponse(rsp *http.Response) (*BillinggetGithubActionsBillingUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubActionsBillingUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionsBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetGithubPackagesBillingUserResponse parses an HTTP response from a BillinggetGithubPackagesBillingUserWithResponse call
func ParseBillinggetGithubPackagesBillingUserResponse(rsp *http.Response) (*BillinggetGithubPackagesBillingUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetGithubPackagesBillingUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackagesBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBillinggetSharedStorageBillingUserResponse parses an HTTP response from a BillinggetSharedStorageBillingUserWithResponse call
func ParseBillinggetSharedStorageBillingUserResponse(rsp *http.Response) (*BillinggetSharedStorageBillingUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BillinggetSharedStorageBillingUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CombinedBillingUsage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistReposStarredByUserResponse parses an HTTP response from a ActivitylistReposStarredByUserWithResponse call
func ParseActivitylistReposStarredByUserResponse(rsp *http.Response) (*ActivitylistReposStarredByUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistReposStarredByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseActivitylistReposWatchedByUserResponse parses an HTTP response from a ActivitylistReposWatchedByUserWithResponse call
func ParseActivitylistReposWatchedByUserResponse(rsp *http.Response) (*ActivitylistReposWatchedByUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ActivitylistReposWatchedByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []MinimalRepository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMetagetZenResponse parses an HTTP response from a MetagetZenWithResponse call
func ParseMetagetZenResponse(rsp *http.Response) (*MetagetZenResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MetagetZenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
